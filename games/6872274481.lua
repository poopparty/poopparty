--This watermark is used to delete the file if its cached, remove it to make the file persist after vape updates.
local function safeGetProto(func, index)
    if not func then return nil end
    local success, proto = pcall(safeGetProto, func, index)
    if success then
        return proto
    end
end

local run = function(func)
	func()
end
local cloneref = cloneref or function(obj)
	return obj
end
local vapeEvents = setmetatable({}, {
	__index = function(self, index)
		self[index] = Instance.new('BindableEvent')
		return self[index]
	end
})

local playersService = cloneref(game:GetService('Players'))
local replicatedStorage = cloneref(game:GetService('ReplicatedStorage'))
local runService = cloneref(game:GetService('RunService'))
local inputService = cloneref(game:GetService('UserInputService'))
local tweenService = cloneref(game:GetService('TweenService'))
local httpService = cloneref(game:GetService('HttpService'))
local textChatService = cloneref(game:GetService('TextChatService'))
local collectionService = cloneref(game:GetService('CollectionService'))
local contextActionService = cloneref(game:GetService('ContextActionService'))
local guiService = cloneref(game:GetService('GuiService'))
local coreGui = cloneref(game:GetService('CoreGui'))
local starterGui = cloneref(game:GetService('StarterGui'))
local isnetworkowner = identifyexecutor and table.find({'AWP', 'Nihon'}, ({identifyexecutor()})[1]) and isnetworkowner or function()
	return true
end
local gameCamera = workspace.CurrentCamera
local lplr = playersService.LocalPlayer
local assetfunction = getcustomasset

local vape = shared.vape
local entitylib = vape.Libraries.entity
local targetinfo = vape.Libraries.targetinfo
local sessioninfo = vape.Libraries.sessioninfo
local uipallet = vape.Libraries.uipallet
local tween = vape.Libraries.tween
local color = vape.Libraries.color
local whitelist = vape.Libraries.whitelist
local prediction = vape.Libraries.prediction
local getfontsize = vape.Libraries.getfontsize
local getcustomasset = vape.Libraries.getcustomasset


local store = {
	attackReach = 0,
	attackReachUpdate = tick(),
	damage = {},
	damageBlockFail = tick(),
	hand = {},
	localHand = {},
	inventory = {
		inventory = {
			items = {},
			armor = {}
		},
		hotbar = {}
	},
	inventories = {},
	matchState = 0,
	queueType = 'bedwars_test',
	tools = {}
}
local Reach = {}
local HitBoxes = {}
local InfiniteFly = {}
local TrapDisabler
local AntiFallPart
local bedwars, remotes, sides, oldinvrender, oldSwing = {}, {}, {}

local function addBlur(parent)
	local blur = Instance.new('ImageLabel')
	blur.Name = 'Blur'
	blur.Size = UDim2.new(1, 89, 1, 52)
	blur.Position = UDim2.fromOffset(-48, -31)
	blur.BackgroundTransparency = 1
	blur.Image = getcustomasset('newvape/assets/new/blur.png')
	blur.ScaleType = Enum.ScaleType.Slice
	blur.SliceCenter = Rect.new(52, 31, 261, 502)
	blur.Parent = parent
	return blur
end

local function collection(tags, module, customadd, customremove)
	tags = typeof(tags) ~= 'table' and {tags} or tags
	local objs, connections = {}, {}

	for _, tag in tags do
		table.insert(connections, collectionService:GetInstanceAddedSignal(tag):Connect(function(v)
			if customadd then
				customadd(objs, v, tag)
				return
			end
			table.insert(objs, v)
		end))
		table.insert(connections, collectionService:GetInstanceRemovedSignal(tag):Connect(function(v)
			if customremove then
				customremove(objs, v, tag)
				return
			end
			v = table.find(objs, v)
			if v then
				table.remove(objs, v)
			end
		end))

		for _, v in collectionService:GetTagged(tag) do
			if customadd then
				customadd(objs, v, tag)
				continue
			end
			table.insert(objs, v)
		end
	end

	local cleanFunc = function(self)
		for _, v in connections do
			v:Disconnect()
		end
		table.clear(connections)
		table.clear(objs)
		table.clear(self)
	end
	if module then
		module:Clean(cleanFunc)
	end
	return objs, cleanFunc
end

local function getBestArmor(slot)
	local closest, mag = nil, 0

	for _, item in store.inventory.inventory.items do
		local meta = item and bedwars.ItemMeta[item.itemType] or {}

		if meta.armor and meta.armor.slot == slot then
			local newmag = (meta.armor.damageReductionMultiplier or 0)

			if newmag > mag then
				closest, mag = item, newmag
			end
		end
	end

	return closest
end

local function getBow()
	local bestBow, bestBowSlot, bestBowDamage = nil, nil, 0
	for slot, item in store.inventory.inventory.items do
		local bowMeta = bedwars.ItemMeta[item.itemType].projectileSource
		if bowMeta and table.find(bowMeta.ammoItemTypes, 'arrow') then
			local bowDamage = bedwars.ProjectileMeta[bowMeta.projectileType('arrow')].combat.damage or 0
			if bowDamage > bestBowDamage then
				bestBow, bestBowSlot, bestBowDamage = item, slot, bowDamage
			end
		end
	end
	return bestBow, bestBowSlot
end

local function getItem(itemName, inv)
	for slot, item in (inv or store.inventory.inventory.items) do
		if item.itemType == itemName then
			return item, slot
		end
	end
	return nil
end

local function GetItems(item: string): table
	local Items: table = {};
	for _, v in next, Enum[item]:GetEnumItems() do 
		table.insert(Items, v["Name"]) ;
	end;
	return Items;
end;

local function getRoactRender(func)
	return debug.getupvalue(debug.getupvalue(debug.getupvalue(func, 3).render, 2).render, 1)
end

local function getSword()
	local bestSword, bestSwordSlot, bestSwordDamage = nil, nil, 0
	for slot, item in store.inventory.inventory.items do
		local swordMeta = bedwars.ItemMeta[item.itemType].sword
		if swordMeta then
			local swordDamage = swordMeta.damage or 0
			if swordDamage > bestSwordDamage then
				bestSword, bestSwordSlot, bestSwordDamage = item, slot, swordDamage
			end
		end
	end
	return bestSword, bestSwordSlot
end

local function getTool(breakType)
	local bestTool, bestToolSlot, bestToolDamage = nil, nil, 0
	for slot, item in store.inventory.inventory.items do
		local toolMeta = bedwars.ItemMeta[item.itemType].breakBlock
		if toolMeta then
			local toolDamage = toolMeta[breakType] or 0
			if toolDamage > bestToolDamage then
				bestTool, bestToolSlot, bestToolDamage = item, slot, toolDamage
			end
		end
	end
	return bestTool, bestToolSlot
end

local function getWool()
	for _, wool in (inv or store.inventory.inventory.items) do
		if wool.itemType:find('wool') then
			return wool and wool.itemType, wool and wool.amount
		end
	end
end

local function getStrength(plr)
	if not plr.Player then
		return 0
	end

	local strength = 0
	for _, v in (store.inventories[plr.Player] or {items = {}}).items do
		local itemmeta = bedwars.ItemMeta[v.itemType]
		if itemmeta and itemmeta.sword and itemmeta.sword.damage > strength then
			strength = itemmeta.sword.damage
		end
	end

	return strength
end

local function getPlacedBlock(pos)
	if not pos then
		return
	end
	local roundedPosition = bedwars.BlockController:getBlockPosition(pos)
	return bedwars.BlockController:getStore():getBlockAt(roundedPosition), roundedPosition
end

local function getBlocksInPoints(s, e)
	local blocks, list = bedwars.BlockController:getStore(), {}
	for x = s.X, e.X do
		for y = s.Y, e.Y do
			for z = s.Z, e.Z do
				local vec = Vector3.new(x, y, z)
				if blocks:getBlockAt(vec) then
					table.insert(list, vec * 3)
				end
			end
		end
	end
	return list
end

local function getNearGround(range)
	range = Vector3.new(3, 3, 3) * (range or 10)
	local localPosition, mag, closest = entitylib.character.RootPart.Position, 60
	local blocks = getBlocksInPoints(bedwars.BlockController:getBlockPosition(localPosition - range), bedwars.BlockController:getBlockPosition(localPosition + range))

	for _, v in blocks do
		if not getPlacedBlock(v + Vector3.new(0, 3, 0)) then
			local newmag = (localPosition - v).Magnitude
			if newmag < mag then
				mag, closest = newmag, v + Vector3.new(0, 3, 0)
			end
		end
	end

	table.clear(blocks)
	return closest
end

local function getShieldAttribute(char)
	local returned = 0
	for name, val in char:GetAttributes() do
		if name:find('Shield') and type(val) == 'number' and val > 0 then
			returned += val
		end
	end
	return returned
end

local function getSpeed()
	local multi, increase, modifiers = 0, true, bedwars.SprintController:getMovementStatusModifier():getModifiers()

	for v in modifiers do
		local val = v.constantSpeedMultiplier and v.constantSpeedMultiplier or 0
		if val and val > math.max(multi, 1) then
			increase = false
			multi = val - (0.06 * math.round(val))
		end
	end

	for v in modifiers do
		multi += math.max((v.moveSpeedMultiplier or 0) - 1, 0)
	end

	if multi > 0 and increase then
		multi += 0.16 + (0.02 * math.round(multi))
	end

	return 20 * (multi + 1)
end

local function getTableSize(tab)
	local ind = 0
	for _ in tab do
		ind += 1
	end
	return ind
end

local function hotbarSwitch(slot)
	if slot and store.inventory.hotbarSlot ~= slot then
		bedwars.Store:dispatch({
			type = 'InventorySelectHotbarSlot',
			slot = slot
		})
		vapeEvents.InventoryChanged.Event:Wait()
		return true
	end
	return false
end

local function isFriend(plr, recolor)
	if vape.Categories.Friends.Options['Use friends'].Enabled then
		local friend = table.find(vape.Categories.Friends.ListEnabled, plr.Name) and true
		if recolor then
			friend = friend and vape.Categories.Friends.Options['Recolor visuals'].Enabled
		end
		return friend
	end
	return nil
end

local function isTarget(plr)
	return table.find(vape.Categories.Targets.ListEnabled, plr.Name) and true
end

local function notif(...) return
	vape:CreateNotification(...)
end

local function removeTags(str)
	str = str:gsub('<br%s*/>', '\n')
	return (str:gsub('<[^<>]->', ''))
end

local function roundPos(vec)
	return Vector3.new(math.round(vec.X / 3) * 3, math.round(vec.Y / 3) * 3, math.round(vec.Z / 3) * 3)
end

local function switchItem(tool, delayTime)
	delayTime = delayTime or 0.05
	local check = lplr.Character and lplr.Character:FindFirstChild('HandInvItem') or nil
	if check and check.Value ~= tool and tool.Parent ~= nil then
		task.spawn(function()
			bedwars.Client:Get(remotes.EquipItem):CallServerAsync({hand = tool})
		end)
		check.Value = tool
		if delayTime > 0 then
			task.wait(delayTime)
		end
		return true
	end
end

local function waitForChildOfType(obj, name, timeout, prop)
	local check, returned = tick() + timeout
	repeat
		returned = prop and obj[name] or obj:FindFirstChildOfClass(name)
		if returned and returned.Name ~= 'UpperTorso' or check < tick() then
			break
		end
		task.wait()
	until false
	return returned
end

local frictionTable, oldfrict = {}, {}
local frictionConnection
local frictionState

local function modifyVelocity(v)
	if v:IsA('BasePart') and v.Name ~= 'HumanoidRootPart' and not oldfrict[v] then
		oldfrict[v] = v.CustomPhysicalProperties or 'none'
		v.CustomPhysicalProperties = PhysicalProperties.new(0.0001, 0.2, 0.5, 1, 1)
	end
end

local function updateVelocity(force)
	local newState = getTableSize(frictionTable) > 0
	if frictionState ~= newState or force then
		if frictionConnection then
			frictionConnection:Disconnect()
		end
		if newState then
			if entitylib.isAlive then
				for _, v in entitylib.character.Character:GetDescendants() do
					modifyVelocity(v)
				end
				frictionConnection = entitylib.character.Character.DescendantAdded:Connect(modifyVelocity)
			end
		else
			for i, v in oldfrict do
				i.CustomPhysicalProperties = v ~= 'none' and v or nil
			end
			table.clear(oldfrict)
		end
	end
	frictionState = newState
end

local function isEveryoneDead()
	return #bedwars.Store:getState().Party.members <= 0
end
	
local function joinQueue()
	if not bedwars.Store:getState().Game.customMatch and bedwars.Store:getState().Party.leader.userId == lplr.UserId and bedwars.Store:getState().Party.queueState == 0 then
		bedwars.QueueController:joinQueue(store.queueType)
	end
end

local function lobby()
	game.ReplicatedStorage.rbxts_include.node_modules['@rbxts'].net.out._NetManaged.TeleportToLobby:FireServer()
end

local kitorder = {
	hannah = 5,
	spirit_assassin = 4,
	dasher = 3,
	jade = 2,
	regent = 1
}

local sortmethods = {
	Damage = function(a, b)
		return a.Entity.Character:GetAttribute('LastDamageTakenTime') < b.Entity.Character:GetAttribute('LastDamageTakenTime')
	end,
	Threat = function(a, b)
		return getStrength(a.Entity) > getStrength(b.Entity)
	end,
	Kit = function(a, b)
		return (a.Entity.Player and kitorder[a.Entity.Player:GetAttribute('PlayingAsKit')] or 0) > (b.Entity.Player and kitorder[b.Entity.Player:GetAttribute('PlayingAsKit')] or 0)
	end,
	Health = function(a, b)
		return a.Entity.Health < b.Entity.Health
	end,
	Angle = function(a, b)
		local selfrootpos = entitylib.character.RootPart.Position
		local localfacing = entitylib.character.RootPart.CFrame.LookVector * Vector3.new(1, 0, 1)
		local angle = math.acos(localfacing:Dot(((a.Entity.RootPart.Position - selfrootpos) * Vector3.new(1, 0, 1)).Unit))
		local angle2 = math.acos(localfacing:Dot(((b.Entity.RootPart.Position - selfrootpos) * Vector3.new(1, 0, 1)).Unit))
		return angle < angle2
	end
}

run(function()
	local oldstart = entitylib.start
	local function customEntity(ent)
		if ent:HasTag('inventory-entity') and not ent:HasTag('Monster') then
			return
		end

		entitylib.addEntity(ent, nil, ent:HasTag('Drone') and function(self)
			local droneplr = playersService:GetPlayerByUserId(self.Character:GetAttribute('PlayerUserId'))
			return not droneplr or lplr:GetAttribute('Team') ~= droneplr:GetAttribute('Team')
		end or function(self)
			return lplr:GetAttribute('Team') ~= self.Character:GetAttribute('Team')
		end)
	end

	entitylib.start = function()
		oldstart()
		if entitylib.Running then
			for _, ent in collectionService:GetTagged('entity') do
				customEntity(ent)
			end
			table.insert(entitylib.Connections, collectionService:GetInstanceAddedSignal('entity'):Connect(customEntity))
			table.insert(entitylib.Connections, collectionService:GetInstanceRemovedSignal('entity'):Connect(function(ent)
				entitylib.removeEntity(ent)
			end))
		end
	end

	entitylib.addPlayer = function(plr)
		if plr.Character then
			entitylib.refreshEntity(plr.Character, plr)
		end
		entitylib.PlayerConnections[plr] = {
			plr.CharacterAdded:Connect(function(char)
				entitylib.refreshEntity(char, plr)
			end),
			plr.CharacterRemoving:Connect(function(char)
				entitylib.removeEntity(char, plr == lplr)
			end),
			plr:GetAttributeChangedSignal('Team'):Connect(function()
				for _, v in entitylib.List do
					if v.Targetable ~= entitylib.targetCheck(v) then
						entitylib.refreshEntity(v.Character, v.Player)
					end
				end

				if plr == lplr then
					entitylib.start()
				else
					entitylib.refreshEntity(plr.Character, plr)
				end
			end)
		}
	end

	entitylib.addEntity = function(char, plr, teamfunc)
		if not char then return end
		entitylib.EntityThreads[char] = task.spawn(function()
			local hum, humrootpart, head
			if plr then
				hum = waitForChildOfType(char, 'Humanoid', 10)
				humrootpart = hum and waitForChildOfType(hum, 'RootPart', workspace.StreamingEnabled and 9e9 or 10, true)
				head = char:WaitForChild('Head', 10) or humrootpart
			else
				hum = {HipHeight = 0.5}
				humrootpart = waitForChildOfType(char, 'PrimaryPart', 10, true)
				head = humrootpart
			end
			local updateobjects = plr and plr ~= lplr and {
				char:WaitForChild('ArmorInvItem_0', 5),
				char:WaitForChild('ArmorInvItem_1', 5),
				char:WaitForChild('ArmorInvItem_2', 5),
				char:WaitForChild('HandInvItem', 5)
			} or {}

			if hum and humrootpart then
				local entity = {
					Connections = {},
					Character = char,
					Health = (char:GetAttribute('Health') or 100) + getShieldAttribute(char),
					Head = head,
					Humanoid = hum,
					HumanoidRootPart = humrootpart,
					HipHeight = hum.HipHeight + (humrootpart.Size.Y / 2) + (hum.RigType == Enum.HumanoidRigType.R6 and 2 or 0),
					Jumps = 0,
					JumpTick = tick(),
					Jumping = false,
					LandTick = tick(),
					MaxHealth = char:GetAttribute('MaxHealth') or 100,
					NPC = plr == nil,
					Player = plr,
					RootPart = humrootpart,
					TeamCheck = teamfunc
				}

				if plr == lplr then
					entity.AirTime = tick()
					entitylib.character = entity
					entitylib.isAlive = true
					entitylib.Events.LocalAdded:Fire(entity)
					table.insert(entitylib.Connections, char.AttributeChanged:Connect(function(attr)
						vapeEvents.AttributeChanged:Fire(attr)
					end))
				else
					entity.Targetable = entitylib.targetCheck(entity)

					for _, v in entitylib.getUpdateConnections(entity) do
						table.insert(entity.Connections, v:Connect(function()
							entity.Health = (char:GetAttribute('Health') or 100) + getShieldAttribute(char)
							entity.MaxHealth = char:GetAttribute('MaxHealth') or 100
							entitylib.Events.EntityUpdated:Fire(entity)
						end))
					end

					for _, v in updateobjects do
						table.insert(entity.Connections, v:GetPropertyChangedSignal('Value'):Connect(function()
							task.delay(0.1, function()
								if bedwars.getInventory then
									store.inventories[plr] = bedwars.getInventory(plr)
									entitylib.Events.EntityUpdated:Fire(entity)
								end
							end)
						end))
					end

					if plr then
						local anim = char:FindFirstChild('Animate')
						if anim then
							pcall(function()
								anim = anim.jump:FindFirstChildWhichIsA('Animation').AnimationId
								table.insert(entity.Connections, hum.Animator.AnimationPlayed:Connect(function(playedanim)
									if playedanim.Animation.AnimationId == anim then
										entity.JumpTick = tick()
										entity.Jumps += 1
										entity.LandTick = tick() + 1
										entity.Jumping = entity.Jumps > 1
									end
								end))
							end)
						end

						task.delay(0.1, function()
							if bedwars.getInventory then
								store.inventories[plr] = bedwars.getInventory(plr)
							end
						end)
					end
					table.insert(entitylib.List, entity)
					entitylib.Events.EntityAdded:Fire(entity)
				end

				table.insert(entity.Connections, char.ChildRemoved:Connect(function(part)
					if part == humrootpart or part == hum or part == head then
						if part == humrootpart and hum.RootPart then
							humrootpart = hum.RootPart
							entity.RootPart = hum.RootPart
							entity.HumanoidRootPart = hum.RootPart
							return
						end
						entitylib.removeEntity(char, plr == lplr)
					end
				end))
			end
			entitylib.EntityThreads[char] = nil
		end)
	end

	entitylib.getUpdateConnections = function(ent)
		local char = ent.Character
		local tab = {
			char:GetAttributeChangedSignal('Health'),
			char:GetAttributeChangedSignal('MaxHealth'),
			{
				Connect = function()
					ent.Friend = ent.Player and isFriend(ent.Player) or nil
					ent.Target = ent.Player and isTarget(ent.Player) or nil
					return {Disconnect = function() end}
				end
			}
		}

		if ent.Player then
			table.insert(tab, ent.Player:GetAttributeChangedSignal('PlayingAsKit'))
		end

		for name, val in char:GetAttributes() do
			if name:find('Shield') and type(val) == 'number' then
				table.insert(tab, char:GetAttributeChangedSignal(name))
			end
		end

		return tab
	end

	entitylib.targetCheck = function(ent)
		if ent.TeamCheck then
			return ent:TeamCheck()
		end
		if ent.NPC then return true end
		if isFriend(ent.Player) then return false end
		if not select(2, whitelist:get(ent.Player)) then return false end
		return lplr:GetAttribute('Team') ~= ent.Player:GetAttribute('Team')
	end
	vape:Clean(entitylib.Events.LocalAdded:Connect(updateVelocity))
end)
entitylib.start()

run(function()
	local KnitInit, Knit
	repeat
		KnitInit, Knit = pcall(function()
			return debug.getupvalue(require(lplr.PlayerScripts.TS.knit).setup, 9)
		end)
		if KnitInit then break end
		task.wait()
	until KnitInit

	if not debug.getupvalue(Knit.Start, 1) then
		repeat task.wait() until debug.getupvalue(Knit.Start, 1)
	end

	local Flamework = require(replicatedStorage['rbxts_include']['node_modules']['@flamework'].core.out).Flamework
	local InventoryUtil = require(replicatedStorage.TS.inventory['inventory-util']).InventoryUtil
	local Client = require(replicatedStorage.TS.remotes).default.Client
	local OldGet, OldBreak = Client.Get

	bedwars = setmetatable({
		AbilityController = Flamework.resolveDependency('@easy-games/game-core:client/controllers/ability/ability-controller@AbilityController'),
		AnimationType = require(replicatedStorage.TS.animation['animation-type']).AnimationType,
		AnimationUtil = require(replicatedStorage['rbxts_include']['node_modules']['@easy-games']['game-core'].out['shared'].util['animation-util']).AnimationUtil,
		AppController = require(replicatedStorage['rbxts_include']['node_modules']['@easy-games']['game-core'].out.client.controllers['app-controller']).AppController,
		BedBreakEffectMeta = require(replicatedStorage.TS.locker['bed-break-effect']['bed-break-effect-meta']).BedBreakEffectMeta,
		BedwarsKitMeta = require(replicatedStorage.TS.games.bedwars.kit['bedwars-kit-meta']).BedwarsKitMeta,
		BlockBreaker = Knit.Controllers.BlockBreakController.blockBreaker,
		MatchHistroyApp = require(lplr.PlayerScripts.TS.controllers.global["match-history"].ui["match-history-moderation-app"]).MatchHistoryModerationApp,
	 	MatchHistroyController = Knit.Controllers.MatchHistoryController,
		BlockController = require(replicatedStorage['rbxts_include']['node_modules']['@easy-games']['block-engine'].out).BlockEngine,
		BlockEngine = require(lplr.PlayerScripts.TS.lib['block-engine']['client-block-engine']).ClientBlockEngine,
		BlockPlacer = require(replicatedStorage['rbxts_include']['node_modules']['@easy-games']['block-engine'].out.client.placement['block-placer']).BlockPlacer,
		BowConstantsTable = debug.getupvalue(Knit.Controllers.ProjectileController.enableBeam, 8),
		ClickHold = require(replicatedStorage['rbxts_include']['node_modules']['@easy-games']['game-core'].out.client.ui.lib.util['click-hold']).ClickHold,
		Client = Client,
		ClientConstructor = require(replicatedStorage['rbxts_include']['node_modules']['@rbxts'].net.out.client),
		ClientDamageBlock = require(replicatedStorage['rbxts_include']['node_modules']['@easy-games']['block-engine'].out.shared.remotes).BlockEngineRemotes.Client,
		CombatConstant = require(replicatedStorage.TS.combat['combat-constant']).CombatConstant,
		DamageIndicator = Knit.Controllers.DamageIndicatorController.spawnDamageIndicator,
		DefaultKillEffect = require(lplr.PlayerScripts.TS.controllers.global.locker['kill-effect'].effects['default-kill-effect']),
		EmoteType = require(replicatedStorage.TS.locker.emote['emote-type']).EmoteType,
		GameAnimationUtil = require(replicatedStorage.TS.animation['animation-util']).GameAnimationUtil,
		getIcon = function(item, showinv)
			local itemmeta = bedwars.ItemMeta[item.itemType]
			return itemmeta and showinv and itemmeta.image or ''
		end,
		getInventory = function(plr)
			local suc, res = pcall(function()
				return InventoryUtil.getInventory(plr)
			end)
			return suc and res or {
				items = {},
				armor = {}
			}
		end,
		HudAliveCount = require(lplr.PlayerScripts.TS.controllers.global['top-bar'].ui.game['hud-alive-player-counts']).HudAlivePlayerCounts,
		MatchHistoryController = require(lplr.PlayerScripts.TS.controllers.global['match-history']['match-history-controller']),
		ItemMeta = debug.getupvalue(require(replicatedStorage.TS.item['item-meta']).getItemMeta, 1),
		KillEffectMeta = require(replicatedStorage.TS.locker['kill-effect']['kill-effect-meta']).KillEffectMeta,
		KillFeedController = Flamework.resolveDependency('client/controllers/game/kill-feed/kill-feed-controller@KillFeedController'),
		Knit = Knit,
		KnockbackUtil = require(replicatedStorage.TS.damage['knockback-util']).KnockbackUtil,
		MageKitUtil = require(replicatedStorage.TS.games.bedwars.kit.kits.mage['mage-kit-util']).MageKitUtil,
		NametagController = Knit.Controllers.NametagController,
		PartyController = Flamework.resolveDependency('@easy-games/lobby:client/controllers/party-controller@PartyController'),
		ProjectileMeta = require(replicatedStorage.TS.projectile['projectile-meta']).ProjectileMeta,
		QueryUtil = require(replicatedStorage['rbxts_include']['node_modules']['@easy-games']['game-core'].out).GameQueryUtil,
		QueueCard = require(lplr.PlayerScripts.TS.controllers.global.queue.ui['queue-card']).QueueCard,
		QueueMeta = require(replicatedStorage.TS.game['queue-meta']).QueueMeta,
		Roact = require(replicatedStorage['rbxts_include']['node_modules']['@rbxts']['roact'].src),
		RuntimeLib = require(replicatedStorage['rbxts_include'].RuntimeLib),
		SoundList = require(replicatedStorage.TS.sound['game-sound']).GameSound,
		SoundManager = require(replicatedStorage['rbxts_include']['node_modules']['@easy-games']['game-core'].out).SoundManager,
		Store = require(lplr.PlayerScripts.TS.ui.store).ClientStore,
		TeamUpgradeMeta = debug.getupvalue(require(replicatedStorage.TS.games.bedwars['team-upgrade']['team-upgrade-meta']).getTeamUpgradeMetaForQueue, 6),
		UILayers = require(replicatedStorage['rbxts_include']['node_modules']['@easy-games']['game-core'].out).UILayers,
		VisualizerUtils = require(lplr.PlayerScripts.TS.lib.visualizer['visualizer-utils']).VisualizerUtils,
		WeldTable = require(replicatedStorage.TS.util['weld-util']).WeldUtil,
		WinEffectMeta = require(replicatedStorage.TS.locker['win-effect']['win-effect-meta']).WinEffectMeta,
		ZapNetworking = require(lplr.PlayerScripts.TS.lib.network)
	}, {
		__index = function(self, ind)
			rawset(self, ind, Knit.Controllers[ind])
			return rawget(self, ind)
		end
	})

	local remoteNames = {
		AfkStatus = safeGetProto(Knit.Controllers.AfkController.KnitStart, 1),
		AttackEntity = Knit.Controllers.SwordController.sendServerRequest,
		BeePickup = Knit.Controllers.BeeNetController.trigger,
		CannonAim = safeGetProto(Knit.Controllers.CannonController.startAiming, 5),
		CannonLaunch = Knit.Controllers.CannonHandController.launchSelf,
		ConsumeBattery = safeGetProto(Knit.Controllers.BatteryController.onKitLocalActivated, 1),
		ConsumeItem = safeGetProto(Knit.Controllers.ConsumeController.onEnable, 1),
		ConsumeSoul = Knit.Controllers.GrimReaperController.consumeSoul,
		ConsumeTreeOrb = safeGetProto(Knit.Controllers.EldertreeController.createTreeOrbInteraction, 1),
		DepositPinata = safeGetProto(safeGetProto(Knit.Controllers.PiggyBankController.KnitStart, 2), 5),
		DragonBreath = safeGetProto(Knit.Controllers.VoidDragonController.onKitLocalActivated, 5),
		DragonEndFly = safeGetProto(Knit.Controllers.VoidDragonController.flapWings, 1),
		DragonFly = Knit.Controllers.VoidDragonController.flapWings,
		DropItem = Knit.Controllers.ItemDropController.dropItemInHand,
		EquipItem = safeGetProto(require(replicatedStorage.TS.entity.entities['inventory-entity']).InventoryEntity.equipItem, 3),
		FireProjectile = debug.getupvalue(Knit.Controllers.ProjectileController.launchProjectileWithValues, 2),
		GroundHit = Knit.Controllers.FallDamageController.KnitStart,
		GuitarHeal = Knit.Controllers.GuitarController.performHeal,
		HannahKill = safeGetProto(Knit.Controllers.HannahController.registerExecuteInteractions, 1),
		HarvestCrop = safeGetProto(safeGetProto(Knit.Controllers.CropController.KnitStart, 4), 1),
		KaliyahPunch = safeGetProto(Knit.Controllers.DragonSlayerController.onKitLocalActivated, 1),
		MageSelect = safeGetProto(Knit.Controllers.MageController.registerTomeInteraction, 1),
		MinerDig = safeGetProto(Knit.Controllers.MinerController.setupMinerPrompts, 1),
		PickupItem = Knit.Controllers.ItemDropController.checkForPickup,
		PickupMetal = safeGetProto(Knit.Controllers.HiddenMetalController.onKitLocalActivated, 4),
		ReportPlayer = require(lplr.PlayerScripts.TS.controllers.global.report['report-controller']).default.reportPlayer,
		ResetCharacter = safeGetProto(Knit.Controllers.ResetController.createBindable, 1),
		SummonerClawAttack = Knit.Controllers.SummonerClawHandController.attack,
		WarlockTarget = safeGetProto(Knit.Controllers.WarlockStaffController.KnitStart, 2)
	}

	local function dumpRemote(tab)
		local ind
		for i, v in tab do
			if v == 'Client' then
				ind = i
				break
			end
		end
		return ind and tab[ind + 1] or ''
	end

	local preDumped = {
		EquipItem = 'SetInvItem'
	}

	for i, v in remoteNames do
		local remote = dumpRemote(debug.getconstants(v))
		if remote == '' or remote == nil then
			if not preDumped[i] then
				notif('Vape', 'Failed to grab remote ('..tostring(i)..')', 10, 'alert')
			end
			remote = preDumped[i] or ''
		end
		remotes[i] = remote
	end

	OldBreak = bedwars.BlockController.isBlockBreakable

	Client.Get = function(self, remoteName)
		local call = OldGet(self, remoteName)

		if remoteName == remotes.AttackEntity then
			return {
				instance = call.instance,
				SendToServer = function(_, attackTable, ...)
					local suc, plr = pcall(function()
						return playersService:GetPlayerFromCharacter(attackTable.entityInstance)
					end)

					local selfpos = attackTable.validate.selfPosition.value
					local targetpos = attackTable.validate.targetPosition.value
					store.attackReach = ((selfpos - targetpos).Magnitude * 100) // 1 / 100
					store.attackReachUpdate = tick() + 1

					if Reach.Enabled or HitBoxes.Enabled then
						attackTable.validate.raycast = attackTable.validate.raycast or {}
						attackTable.validate.selfPosition.value += CFrame.lookAt(selfpos, targetpos).LookVector * math.max((selfpos - targetpos).Magnitude - 14.399, 0)
					end

					if suc and plr then
						if not select(2, whitelist:get(plr)) then return end
					end

					return call:SendToServer(attackTable, ...)
				end
			}
		elseif remoteName == 'StepOnSnapTrap' and TrapDisabler.Enabled then
			return {SendToServer = function() end}
		end

		return call
	end

	bedwars.BlockController.isBlockBreakable = function(self, breakTable, plr)
		local obj = bedwars.BlockController:getStore():getBlockAt(breakTable.blockPosition)

		if obj and obj.Name == 'bed' then
			for _, plr in playersService:GetPlayers() do
				if obj:GetAttribute('Team'..(plr:GetAttribute('Team') or 0)..'NoBreak') and not select(2, whitelist:get(plr)) then
					return false
				end
			end
		end

		return OldBreak(self, breakTable, plr)
	end

	local cache, blockhealthbar = {}, {blockHealth = -1, breakingBlockPosition = Vector3.zero}
	store.blockPlacer = bedwars.BlockPlacer.new(bedwars.BlockEngine, 'wool_white')

	local function getBlockHealth(block, blockpos)
		local blockdata = bedwars.BlockController:getStore():getBlockData(blockpos)
		return (blockdata and (blockdata:GetAttribute('1') or blockdata:GetAttribute('Health')) or block:GetAttribute('Health'))
	end

	local function getBlockHits(block, blockpos)
		if not block then return 0 end
		local breaktype = bedwars.ItemMeta[block.Name].block.breakType
		local tool = store.tools[breaktype]
		tool = tool and bedwars.ItemMeta[tool.itemType].breakBlock[breaktype] or 2
		return getBlockHealth(block, bedwars.BlockController:getBlockPosition(blockpos)) / tool
	end

	local function calculatePath(target, blockpos)
		if cache[blockpos] then
			return unpack(cache[blockpos])
		end
		local visited, unvisited, distances, air, path = {}, {{0, blockpos}}, {[blockpos] = 0}, {}, {}

		for _ = 1, 10000 do
			local _, node = next(unvisited)
			if not node then break end
			table.remove(unvisited, 1)
			visited[node[2]] = true

			for _, side in sides do
				side = node[2] + side
				if visited[side] then continue end

				local block = getPlacedBlock(side)
				if not block or block:GetAttribute('NoBreak') or block == target then
					if not block then
						air[node[2]] = true
					end
					continue
				end

				local curdist = getBlockHits(block, side) + node[1]
				if curdist < (distances[side] or math.huge) then
					table.insert(unvisited, {curdist, side})
					distances[side] = curdist
					path[side] = node[2]
				end
			end
		end

		local pos, cost = nil, math.huge
		for node in air do
			if distances[node] < cost then
				pos, cost = node, distances[node]
			end
		end

		if pos then
			local cacheEntry = {
				pos,
				cost,
				path,
				timestamp = tick()
			}
			cache[blockpos] = cacheEntry
			return pos, cost, path
		end
	end

	bedwars.placeBlock = function(pos, item)
		if getItem(item) then
			store.blockPlacer.blockType = item
			return store.blockPlacer:placeBlock(bedwars.BlockController:getBlockPosition(pos))
		end
	end

	bedwars.breakBlock = function(block, effects, anim, customHealthbar, autotool, wallcheck, nobreak)
		if lplr:GetAttribute('DenyBlockBreak') or not entitylib.isAlive then return end
		local handler = bedwars.BlockController:getHandlerRegistry():getHandler(block.Name)
		local cost, pos, target, path = math.huge
		local mag = 9e9

		local positions = (handler and handler:getContainedPositions(block) or {block.Position / 3})

		for _, v in positions do
			local dpos, dcost, dpath = calculatePath(block, v * 3)
			local dmag = dpos and (entitylib.character.RootPart.Position - dpos).Magnitude
			if dpos and dcost < cost and dmag < mag then
				cost, pos, target, path, mag = dcost, dpos, v * 3, dpath, dmag
			end
		end

		if pos then
			if (entitylib.character.RootPart.Position - pos).Magnitude > 30 then return end
			local dblock, dpos = getPlacedBlock(pos)
			if not dblock then return end

			if not nobreak and (workspace:GetServerTimeNow() - bedwars.SwordController.lastAttack) > 0.2 then
				local breaktype = bedwars.ItemMeta[dblock.Name].block.breakType
				local tool = store.tools[breaktype]
				if tool then
					if autotool then
						for i, v in store.inventory.hotbar do
							if v.item and v.item.tool == tool.tool and i ~= (store.inventory.hotbarSlot + 1) then 
								hotbarSwitch(i - 1)
								break
							end
						end
					else
						switchItem(tool.tool)
					end
				end
			end

			if blockhealthbar.blockHealth == -1 or dpos ~= blockhealthbar.breakingBlockPosition then
				blockhealthbar.blockHealth = getBlockHealth(dblock, dpos)
				blockhealthbar.breakingBlockPosition = dpos
			end

			if not nobreak then
				bedwars.ClientDamageBlock:Get('DamageBlock'):CallServerAsync({
					blockRef = {blockPosition = dpos},
					hitPosition = pos,
					hitNormal = Vector3.FromNormalId(Enum.NormalId.Top)
				}):andThen(function(result)
					if result then
						if result == 'cancelled' then
							store.damageBlockFail = os.clock() + 1
							table.clear(cache)
							return
						end

						if effects then
							local blockdmg = (blockhealthbar.blockHealth - (result == 'destroyed' and 0 or getBlockHealth(dblock, dpos)))
							customHealthbar = customHealthbar or bedwars.BlockBreaker.updateHealthbar
							customHealthbar(bedwars.BlockBreaker, {blockPosition = dpos}, blockhealthbar.blockHealth, dblock:GetAttribute('MaxHealth'), blockdmg, dblock)
							blockhealthbar.blockHealth = math.max(blockhealthbar.blockHealth - blockdmg, 0)

							pcall(function()
								if blockhealthbar.blockHealth <= 0 then
									bedwars.BlockBreaker.breakEffect:playBreak(dblock.Name, dpos, lplr)
									bedwars.BlockBreaker.healthbarMaid:DoCleaning()
									blockhealthbar.breakingBlockPosition = Vector3.zero
								else
									bedwars.BlockBreaker.breakEffect:playHit(dblock.Name, dpos, lplr)
								end
							end)
						end

						if anim then
							local animation = bedwars.AnimationUtil:playAnimation(lplr, bedwars.BlockController:getAnimationController():getAssetId(1))
							bedwars.ViewmodelController:playAnimation(15)
							task.wait(0.3)
							animation:Stop()
							animation:Destroy()
						end
					end
				end)
			end

			if effects then
				return pos, path, target
			end
		end
	end

	for _, v in Enum.NormalId:GetEnumItems() do
		table.insert(sides, Vector3.FromNormalId(v) * 3)
	end

	local function updateStore(new, old)
		if new.Bedwars ~= old.Bedwars then
			store.equippedKit = new.Bedwars.kit ~= 'none' and new.Bedwars.kit or ''
		end

		if new.Game ~= old.Game then
			store.matchState = new.Game.matchState
			store.queueType = new.Game.queueType or 'bedwars_test'
		end

		if new.Inventory ~= old.Inventory then
			local newinv = (new.Inventory and new.Inventory.observedInventory or {inventory = {}})
			local oldinv = (old.Inventory and old.Inventory.observedInventory or {inventory = {}})
			store.inventory = newinv

			if newinv ~= oldinv then
				vapeEvents.InventoryChanged:Fire()
			end

			if newinv.inventory.items ~= oldinv.inventory.items then
				vapeEvents.InventoryAmountChanged:Fire()
				store.tools.sword = getSword()
				for _, v in {'stone', 'wood', 'wool'} do
					store.tools[v] = getTool(v)
				end
			end

			if newinv.inventory.hand ~= oldinv.inventory.hand then
				local currentHand, toolType = new.Inventory.observedInventory.inventory.hand, ''
				if currentHand then
					local handData = bedwars.ItemMeta[currentHand.itemType]
					toolType = handData.sword and 'sword' or handData.block and 'block' or currentHand.itemType:find('bow') and 'bow'
				end

				store.hand = {
					tool = currentHand and currentHand.tool,
					amount = currentHand and currentHand.amount or 0,
					toolType = toolType
				}
			end
		end
	end

	local storeChanged = bedwars.Store.changed:connect(updateStore)
	updateStore(bedwars.Store:getState(), {})

	for _, event in {'MatchEndEvent', 'EntityDeathEvent', 'BedwarsBedBreak', 'BalloonPopped', 'AngelProgress', 'GrapplingHookFunctions'} do
		if not vape.Connections then return end
		bedwars.Client:WaitFor(event):andThen(function(connection)
			vape:Clean(connection:Connect(function(...)
				vapeEvents[event]:Fire(...)
			end))
		end)
	end

	vape:Clean(bedwars.ZapNetworking.EntityDamageEventZap.On(function(...)
		vapeEvents.EntityDamageEvent:Fire({
			entityInstance = ...,
			damage = select(2, ...),
			damageType = select(3, ...),
			fromPosition = select(4, ...),
			fromEntity = select(5, ...),
			knockbackMultiplier = select(6, ...),
			knockbackId = select(7, ...),
			disableDamageHighlight = select(13, ...)
		})
	end))

	for _, event in {'PlaceBlockEvent', 'BreakBlockEvent'} do
		vape:Clean(bedwars.ZapNetworking[event..'Zap'].On(function(...)
			local data = {
				blockRef = {
					blockPosition = ...,
				},
				player = select(5, ...)
			}
			local changedBlockPos = data.blockRef.blockPosition * 3
			for i, v in cache do
				local cachedTargetPos = v[1]
				local cachedPath = v[3]
				local shouldClear = false
				
				if (changedBlockPos - cachedTargetPos).Magnitude <= 30 then
					shouldClear = true
				else
					for pathNode in cachedPath do
						if (changedBlockPos - pathNode).Magnitude <= 3 then
							shouldClear = true
							break
						end
					end
				end
				
				if shouldClear then
					table.clear(v[3])
					table.clear(v)
					cache[i] = nil
				end
			end
			vapeEvents[event]:Fire(data)
		end))
	end

	store.blocks = collection('block', gui)
	store.shop = collection({'BedwarsItemShop', 'TeamUpgradeShopkeeper'}, gui, function(tab, obj)
		table.insert(tab, {
			Id = obj.Name,
			RootPart = obj,
			Shop = obj:HasTag('BedwarsItemShop'),
			Upgrades = obj:HasTag('TeamUpgradeShopkeeper')
		})
	end)
	store.enchant = collection({'enchant-table', 'broken-enchant-table'}, gui, nil, function(tab, obj, tag)
		if obj:HasTag('enchant-table') and tag == 'broken-enchant-table' then return end
		obj = table.find(tab, obj)
		if obj then
			table.remove(tab, obj)
		end
	end)

	local kills = sessioninfo:AddItem('Kills')
	local beds = sessioninfo:AddItem('Beds')
	local wins = sessioninfo:AddItem('Wins')
	local games = sessioninfo:AddItem('Games')

	local mapname = 'Unknown'
	sessioninfo:AddItem('Map', 0, function()
		return mapname
	end, false)

	task.delay(1, function()
		games:Increment()
	end)

	task.spawn(function()
		pcall(function()
			repeat task.wait() until store.matchState ~= 0 or vape.Loaded == nil
			if vape.Loaded == nil then return end
			mapname = workspace:WaitForChild('Map', 5):WaitForChild('Worlds', 5):GetChildren()[1].Name
			mapname = string.gsub(string.split(mapname, '_')[2] or mapname, '-', '') or 'Blank'
		end)
	end)

	vape:Clean(vapeEvents.BedwarsBedBreak.Event:Connect(function(bedTable)
		if bedTable.player and bedTable.player.UserId == lplr.UserId then
			beds:Increment()
		end
	end))

	vape:Clean(vapeEvents.MatchEndEvent.Event:Connect(function(winTable)
		if (bedwars.Store:getState().Game.myTeam or {}).id == winTable.winningTeamId or lplr.Neutral then
			wins:Increment()
		end
	end))

	vape:Clean(vapeEvents.EntityDeathEvent.Event:Connect(function(deathTable)
		local killer = playersService:GetPlayerFromCharacter(deathTable.fromEntity)
		local killed = playersService:GetPlayerFromCharacter(deathTable.entityInstance)
		if not killed or not killer then return end

		if killed ~= lplr and killer == lplr then
			kills:Increment()
		end
	end))

	task.spawn(function()
		repeat
			if entitylib.isAlive then
				entitylib.character.AirTime = entitylib.character.Humanoid.FloorMaterial ~= Enum.Material.Air and tick() or entitylib.character.AirTime
			end

			for _, v in entitylib.List do
				v.LandTick = math.abs(v.RootPart.Velocity.Y) < 0.1 and v.LandTick or tick()
				if (tick() - v.LandTick) > 0.2 and v.Jumps ~= 0 then
					v.Jumps = 0
					v.Jumping = false
				end
			end
			task.wait(0.05)
		until vape.Loaded == nil
	end)

	pcall(function()
		if getthreadidentity and setthreadidentity then
			local old = getthreadidentity()
			setthreadidentity(2)

			bedwars.Shop = require(replicatedStorage.TS.games.bedwars.shop['bedwars-shop']).BedwarsShop
			bedwars.ShopItems = debug.getupvalue(debug.getupvalue(bedwars.Shop.getShopItem, 1), 2)
			bedwars.Shop.getShopItem('iron_sword', lplr)

			setthreadidentity(old)
			store.shopLoaded = true
		else
			task.spawn(function()
				repeat
					task.wait(0.1)
				until vape.Loaded == nil or bedwars.AppController:isAppOpen('BedwarsItemShopApp')

				bedwars.Shop = require(replicatedStorage.TS.games.bedwars.shop['bedwars-shop']).BedwarsShop
				bedwars.ShopItems = debug.getupvalue(debug.getupvalue(bedwars.Shop.getShopItem, 1), 2)
				store.shopLoaded = true
			end)
		end
	end)

	vape:Clean(function()
		Client.Get = OldGet
		bedwars.BlockController.isBlockBreakable = OldBreak
		store.blockPlacer:disable()
		for _, v in vapeEvents do
			v:Destroy()
		end
		for _, v in cache do
			table.clear(v[3])
			table.clear(v)
		end
		table.clear(store.blockPlacer)
		table.clear(vapeEvents)
		table.clear(bedwars)
		table.clear(store)
		table.clear(cache)
		table.clear(sides)
		table.clear(remotes)
		storeChanged:disconnect()
		storeChanged = nil
	end)
end)

for _, v in {'AntiRagdoll', 'TriggerBot', 'SilentAim', 'AutoRejoin', 'Rejoin', 'Disabler', 'Timer', 'ServerHop', 'MouseTP', 'MurderMystery', 'ESP'} do
	vape:Remove(v)
end

local function joinQueue()
	if not bedwars.Store:getState().Game.customMatch and bedwars.Store:getState().Party.leader.userId == lplr.UserId and bedwars.Store:getState().Party.queueState == 0 then
		bedwars.QueueController:joinQueue(store.queueType)
	end
end

local function lobby()
	game.ReplicatedStorage.rbxts_include.node_modules['@rbxts'].net.out._NetManaged.TeleportToLobby:FireServer()
end

run(function()
	local AimAssist
	local Targets
	local Sort
	local AimSpeed
	local ReactionTime
	local Distance
	local AngleSlider
	local StrafeMultiplier
	local KillauraTarget
	local ClickAim
	local ShopCheck
	local FirstPersonCheck
	local VerticalAim
	local VerticalOffset
	local AimPart
	local WorkWithAllItems
	local PriorityMode
	local ThirdPersonAim
	local ShakeToggle
	local ShakeAmount
	local WorkWithProjectiles
	
	local rayCheck = RaycastParams.new()
	rayCheck.FilterType = Enum.RaycastFilterType.Include
	rayCheck.FilterDescendantsInstances = {workspace:FindFirstChild('Map') or workspace}
	
	local lockedTarget = nil
	local rng = Random.new()
	local lastAimCFrame = nil
	local aimingAtTarget = false
	local reactionStartTime = 0
	local hasReacted = false
	local currentTarget = nil
	
	local function isFirstPerson()
		if not (lplr.Character and lplr.Character:FindFirstChild("Head")) then return nil end
		return (lplr.Character.Head.Position - gameCamera.CFrame.Position).Magnitude < 2
	end
	
	local function hasValidWeapon()
		if not store.hand or not store.hand.tool then return false end
		local toolType = store.hand.toolType
		local toolName = store.hand.tool.Name:lower()
		if toolName:find('headhunter') then
			return true
		end
		return toolType == 'sword' or toolType == 'bow' or toolType == 'crossbow'
	end
	
	local function isSword()
		if not store.hand or not store.hand.tool then return false end
		local toolType = store.hand.toolType
		return toolType == 'sword'
	end
	
	local function isTargetValid(ent, currentDistance)
		if not ent or not ent.RootPart or not ent.Character then return false end
		if not entitylib.isAlive then return false end
		local distance = (ent.RootPart.Position - entitylib.character.RootPart.Position).Magnitude
		if distance > currentDistance then return false end
		
		if Targets.Walls.Enabled then
			local ray = workspace:Raycast(
				entitylib.character.RootPart.Position,
				(ent.RootPart.Position - entitylib.character.RootPart.Position),
				rayCheck
			)
			if ray then return false end
		end
		
		local humanoid = ent.Character:FindFirstChild("Humanoid")
		if not humanoid or humanoid.Health <= 0 then return false end
		
		return true
	end
	
	local function getAimSpeed(sliderValue)
		local baseSpeed = 0.008
		local multiplier = 1.35
		local speed = baseSpeed * (multiplier ^ sliderValue)
		return math.min(speed, 0.95)
	end
	
	AimAssist = vape.Categories.Combat:CreateModule({
		Name = 'AimAssist',
		Function = function(callback)
			if callback then
				AimAssist:Clean(runService.RenderStepped:Connect(function(dt)
					if store.ProjectileAimAssist and store.ProjectileAimAssist.Enabled then
						if store.hand and store.hand.tool then
							local toolName = store.hand.tool.Name:lower()
							if toolName:find("bow") or toolName:find("crossbow") or toolName:find("headhunter") then
								lockedTarget = nil
								currentTarget = nil
								hasReacted = false
								return
							end
						end
					end
					
					local validWeaponCheck = false
					if WorkWithAllItems.Enabled then
						validWeaponCheck = true
					elseif WorkWithProjectiles.Enabled then
						validWeaponCheck = hasValidWeapon()
					else
						validWeaponCheck = isSword()
					end
					
					if not (entitylib.isAlive and validWeaponCheck and ((not ClickAim.Enabled) or (workspace:GetServerTimeNow() - bedwars.SwordController.lastAttack) < 0.4)) then
						lockedTarget = nil
						currentTarget = nil
						hasReacted = false
						return
					end
					
					if ShopCheck.Enabled then
						local isShop = lplr:FindFirstChild("PlayerGui") and lplr.PlayerGui:FindFirstChild("ItemShop")
						if isShop then return end
					end
					
					if FirstPersonCheck.Enabled and not isFirstPerson() then return end
					
					local ent = nil
					
					if PriorityMode.Enabled then
						if lockedTarget and isTargetValid(lockedTarget, Distance.Value) then
							local delta = (lockedTarget.RootPart.Position - entitylib.character.RootPart.Position)
							local localfacing = entitylib.character.RootPart.CFrame.LookVector * Vector3.new(1, 0, 1)
							local angle = math.acos(localfacing:Dot((delta * Vector3.new(1, 0, 1)).Unit))
							
							if angle < (math.rad(AngleSlider.Value) / 2) then
								ent = lockedTarget
							else
								lockedTarget = nil
								currentTarget = nil
								hasReacted = false
							end
						else
							lockedTarget = nil
						end
						
						if not ent then
							ent = KillauraTarget.Enabled and store.KillauraTarget or entitylib.EntityPosition({
								Range = Distance.Value,
								Part = 'RootPart',
								Wallcheck = Targets.Walls.Enabled,
								Players = Targets.Players.Enabled,
								NPCs = Targets.NPCs.Enabled,
								Sort = sortmethods[Sort.Value]
							})
							
							if ent then
								lockedTarget = ent
							end
						end
					else
						lockedTarget = nil
						ent = KillauraTarget.Enabled and store.KillauraTarget or entitylib.EntityPosition({
							Range = Distance.Value,
							Part = 'RootPart',
							Wallcheck = Targets.Walls.Enabled,
							Players = Targets.Players.Enabled,
							NPCs = Targets.NPCs.Enabled,
							Sort = sortmethods[Sort.Value]
						})
					end
					
					if ent then
						if currentTarget ~= ent then
							currentTarget = ent
							hasReacted = false
							reactionStartTime = tick()
						end
						
						if not hasReacted then
							local reactionDelay = ReactionTime.Value / 1000
							local randomVariance = (rng:NextNumber() - 0.5) * 0.3 * reactionDelay
							local actualDelay = reactionDelay + randomVariance
							
							if (tick() - reactionStartTime) < actualDelay then
								return
							else
								hasReacted = true
							end
						end
						
						pcall(function()
							local plr = ent
							vapeTargetInfo.Targets.AimAssist = {
								Humanoid = {
									Health = (plr.Character:GetAttribute("Health") or plr.Humanoid.Health) + getShieldAttribute(plr.Character),
									MaxHealth = plr.Character:GetAttribute("MaxHealth") or plr.Humanoid.MaxHealth
								},
								Player = plr.Player
							}
						end)
						
						local delta = (ent.RootPart.Position - entitylib.character.RootPart.Position)
						local localfacing = entitylib.character.RootPart.CFrame.LookVector * Vector3.new(1, 0, 1)
						local angle = math.acos(localfacing:Dot((delta * Vector3.new(1, 0, 1)).Unit))
						if angle >= (math.rad(AngleSlider.Value) / 2) then return end
						
						targetinfo.Targets[ent] = tick() + 1
						
						local aimPosition = ent.RootPart.Position
						
						if AimPart.Value ~= "Root" then
							local targetPart = ent.Character:FindFirstChild(AimPart.Value == "Head" and "Head" or "Torso")
							if not targetPart then
								targetPart = ent.Character:FindFirstChild("UpperTorso")
							end
							if targetPart then
								aimPosition = targetPart.Position
							end
						end
						
						if VerticalAim.Enabled then
							aimPosition = aimPosition + Vector3.new(0, VerticalOffset.Value, 0)
						end
						
						local finalAimSpeed = getAimSpeed(AimSpeed.Value)
						
						if StrafeMultiplier.Enabled and (inputService:IsKeyDown(Enum.KeyCode.A) or inputService:IsKeyDown(Enum.KeyCode.D)) then
							finalAimSpeed = finalAimSpeed * 1.15
						end
						
						if ShakeToggle.Enabled and ShakeAmount.Value > 0 then
							local shakeIntensity = ShakeAmount.Value / 10
							local speedVariation = 1 + ((rng:NextNumber() - 0.5) * shakeIntensity * 0.3)
							finalAimSpeed = finalAimSpeed * speedVariation
							
							local jitterAmount = ShakeAmount.Value * 0.1
							local microJitter = Vector3.new(
								(rng:NextNumber() - 0.5) * jitterAmount,
								(rng:NextNumber() - 0.5) * jitterAmount,
								(rng:NextNumber() - 0.5) * jitterAmount
							)
							aimPosition = aimPosition + microJitter
						end
						
						if ThirdPersonAim.Enabled then
							entitylib.character.RootPart.CFrame = entitylib.character.RootPart.CFrame:Lerp(
								CFrame.lookAt(entitylib.character.RootPart.CFrame.p, 
								Vector3.new(aimPosition.X, entitylib.character.RootPart.Position.Y, aimPosition.Z)), 
								finalAimSpeed * 100 * dt
							)
						else
							local targetCFrame = CFrame.lookAt(gameCamera.CFrame.p, aimPosition)
							gameCamera.CFrame = gameCamera.CFrame:Lerp(targetCFrame, finalAimSpeed)
							lastAimCFrame = targetCFrame
							aimingAtTarget = true
						end
					else
						currentTarget = nil
						hasReacted = false
						
						if aimingAtTarget and lastAimCFrame then
							local retractSpeed = 0.05
							if (gameCamera.CFrame.Position - lastAimCFrame.Position).Magnitude > 0.1 then
								gameCamera.CFrame = gameCamera.CFrame:Lerp(
									CFrame.new(gameCamera.CFrame.Position, gameCamera.CFrame.Position + gameCamera.CFrame.LookVector),
									retractSpeed
								)
							else
								aimingAtTarget = false
								lastAimCFrame = nil
							end
						end
						
						if PriorityMode.Enabled then
							lockedTarget = nil
						end
					end
				end))
			else
				lockedTarget = nil
				aimingAtTarget = false
				lastAimCFrame = nil
				currentTarget = nil
				hasReacted = false
			end
		end,
		Tooltip = 'Aim assist with reaction time'
	})
	
	Targets = AimAssist:CreateTargets({
		Players = true, 
		Walls = true
	})
	
	local methods = {'Damage', 'Distance'}
	for i in sortmethods do
		if not table.find(methods, i) then
			table.insert(methods, i)
		end
	end
	
	Sort = AimAssist:CreateDropdown({
		Name = 'Target Mode',
		List = methods,
		Tooltip = 'How to prioritize targets'
	})
	
	AimSpeed = AimAssist:CreateSlider({
		Name = 'Aim Speed',
		Min = 1,
		Max = 20,
		Default = 6,
		Tooltip = 'How fast the aim assistant tracks targets'
	})
	
	ReactionTime = AimAssist:CreateSlider({
		Name = 'Reaction Time',
		Min = 0,
		Max = 300,
		Default = 80,
		Suffix = 'ms',
		Tooltip = 'Delay before aim assist activates'
	})
	
	Distance = AimAssist:CreateSlider({
		Name = 'Distance',
		Min = 1,
		Max = 30,
		Default = 25,
		Suffix = function(val) 
			return val == 1 and 'stud' or 'studs' 
		end
	})
	
	AngleSlider = AimAssist:CreateSlider({
		Name = 'Max Angle',
		Min = 1,
		Max = 360,
		Default = 60,
		Tooltip = 'FOV angle for target acquisition'
	})
	
	AimPart = AimAssist:CreateDropdown({
		Name = 'Aim Part',
		List = {'Root', 'Torso', 'Head'},
		Default = 'Root'
	})
	
	PriorityMode = AimAssist:CreateToggle({
		Name = 'Priority Mode',
		Default = false,
		Tooltip = 'Lock onto one target until they leave range'
	})
	
	ClickAim = AimAssist:CreateToggle({
		Name = 'Click Aim',
		Default = true,
		Tooltip = 'Only aim when attacking'
	})
	
	KillauraTarget = AimAssist:CreateToggle({
		Name = 'Use Killaura Target',
		Tooltip = 'Use the same target as Killaura'
	})
	
	VerticalAim = AimAssist:CreateToggle({
		Name = 'Vertical Offset',
		Default = false,
		Function = function(callback)
			VerticalOffset.Object.Visible = callback
		end
	})
	
	VerticalOffset = AimAssist:CreateSlider({
		Name = 'Offset',
		Min = -3,
		Max = 3,
		Default = 0,
		Decimal = 10,
		Visible = false
	})
	
	ShakeToggle = AimAssist:CreateToggle({
		Name = 'Shake',
		Default = false,
		Function = function(callback)
			ShakeAmount.Object.Visible = callback
		end,
		Tooltip = 'Add slight jitter to aim'
	})
	
	ShakeAmount = AimAssist:CreateSlider({
		Name = 'Shake Amount',
		Min = 1,
		Max = 10,
		Default = 3,
		Visible = false
	})
	
	ShopCheck = AimAssist:CreateToggle({
		Name = "Shop Check",
		Default = false,
		Tooltip = 'Disable when shop is open'
	})
	
	FirstPersonCheck = AimAssist:CreateToggle({
		Name = "First Person Only",
		Default = false,
		Tooltip = 'Only work in first person view'
	})
	
	ThirdPersonAim = AimAssist:CreateToggle({
		Name = 'Third Person Aim',
		Default = false,
		Tooltip = 'Rotate character instead of camera'
	})
	
	StrafeMultiplier = AimAssist:CreateToggle({
		Name = 'Strafe Boost',
		Tooltip = 'Increase aim speed when strafing'
	})
	
	WorkWithProjectiles = AimAssist:CreateToggle({
		Name = 'Work With Projectiles',
		Default = false,
		Tooltip = 'Also work when holding bows/crossbows'
	})
	
	WorkWithAllItems = AimAssist:CreateToggle({
		Name = 'Work With All Items',
		Default = false,
		Tooltip = 'Work with any item equipped'
	})
end)

run(function()
	local ProjectileAimAssist
	local Targets
	local PAMode
	local AimSpeed
	local ReactionTime
	local Distance
	local AngleSlider
	local AimPart
	local PriorityMode
	local ClickAim
	local VerticalAim
	local VerticalOffset
	local ShakeToggle
	local ShakeAmount
	local ShopCheck
	local FirstPersonCheck
	local StrafeMultiplier
	
	local rayCheck = RaycastParams.new()
	rayCheck.FilterType = Enum.RaycastFilterType.Include
	rayCheck.FilterDescendantsInstances = {workspace:FindFirstChild('Map') or workspace}
	
	local lockedTarget = nil
	local rng = Random.new()
	local lastAimCFrame = nil
	local aimingAtTarget = false
	local reactionStartTime = 0
	local hasReacted = false
	local currentTarget = nil
	
	local aerov4bad = {
		predictStrafingMovement = function(targetPlayer, targetPart, projSpeed, gravity, origin)
			if not targetPlayer or not targetPlayer.Character or not targetPart then 
				return targetPart and targetPart.Position or Vector3.zero
			end
			
			local currentPos = targetPart.Position
			local currentVel = targetPart.Velocity
			local distance = (currentPos - origin).Magnitude
			local timeToTarget = distance / projSpeed
			
			local horizontalVel = Vector3.new(currentVel.X, 0, currentVel.Z)
			local horizontalSpeed = horizontalVel.Magnitude
			local horizontalStrength = 1.0

			if projSpeed >= 450 then
				if distance > 80 then
					horizontalStrength = 0.92
				elseif distance > 50 then
					horizontalStrength = 0.95
				else
					horizontalStrength = 0.98
				end
			elseif projSpeed >= 350 then
				if distance > 80 then
					horizontalStrength = 0.88
				elseif distance > 50 then
					horizontalStrength = 0.92
				else
					horizontalStrength = 0.95
				end
			else
				if distance > 80 then
					horizontalStrength = 1.15
				elseif distance > 50 then
					horizontalStrength = 1.10
				else
					horizontalStrength = 1.05
				end
			end
			
			local predictedHorizontal = horizontalVel * timeToTarget * horizontalStrength
			
			local verticalVel = currentVel.Y
			local isFreeFalling = verticalVel < -50
			local isFalling = verticalVel < -15 and verticalVel >= -50
			local isJumping = verticalVel > 10
			local isPeaking = verticalVel >= -3 and verticalVel <= 3
			
			local verticalStrength = 0.5
			if isFreeFalling then
				verticalStrength = 0.80
			elseif isFalling then
				verticalStrength = 0.75
			elseif isJumping then
				verticalStrength = 0.60
			elseif isPeaking then
				verticalStrength = 0.40	
			else
				verticalStrength = 0.50
			end
			
			local verticalPrediction = verticalVel * timeToTarget * verticalStrength
			
			local dropCompensation = 0
			if gravity > 0 then
				dropCompensation = 0.5 * gravity * (timeToTarget * timeToTarget)
				
				if projSpeed >= 450 then
					dropCompensation = dropCompensation * 0.6
				elseif projSpeed >= 350 then
					dropCompensation = dropCompensation * 0.75
				end
			end
			
			local finalPosX = currentPos.X + predictedHorizontal.X
			local finalPosY = currentPos.Y + verticalPrediction + dropCompensation
			local finalPosZ = currentPos.Z + predictedHorizontal.Z
			local finalPosition = Vector3.new(finalPosX, finalPosY, finalPosZ)
			
			if distance > 100 then
				local maxPredictTime = 1.5
				if timeToTarget > maxPredictTime then
					local cappedHorizontal = horizontalVel * maxPredictTime * horizontalStrength
					local cappedVertical = verticalVel * maxPredictTime * verticalStrength
					local cappedDrop = 0.5 * gravity * (maxPredictTime * maxPredictTime)
					
					if projSpeed >= 450 then
						cappedDrop = cappedDrop * 0.6
					elseif projSpeed >= 350 then
						cappedDrop = cappedDrop * 0.75
					end
					
					finalPosition = Vector3.new(
						currentPos.X + cappedHorizontal.X,
						currentPos.Y + cappedVertical + cappedDrop,
						currentPos.Z + cappedHorizontal.Z
					)
				end
			end
			
			return finalPosition
		end
	}
	
	local function isHoldingProjectile()
		if not store.hand or not store.hand.tool then return false end
		local toolName = store.hand.tool.Name
		if toolName == "headhunter" or toolName:lower():find("headhunter") then
			return true
		end
		if toolName:lower():find("bow") or toolName:lower():find("crossbow") then
			return true
		end
		local toolMeta = bedwars.ItemMeta[toolName]
		if toolMeta and toolMeta.projectileSource then
			return true
		end
		return false
	end
	
	local function isFirstPerson()
		if not (lplr.Character and lplr.Character:FindFirstChild("Head")) then return nil end
		return (lplr.Character.Head.Position - gameCamera.CFrame.Position).Magnitude < 2
	end
	
	local function isTargetValid(ent, currentDistance)
		if not ent or not ent.RootPart or not ent.Character then return false end
		if not entitylib.isAlive then return false end
		local distance = (ent.RootPart.Position - entitylib.character.RootPart.Position).Magnitude
		if distance > currentDistance then return false end
		
		if Targets.Walls.Enabled then
			local ray = workspace:Raycast(
				entitylib.character.RootPart.Position,
				(ent.RootPart.Position - entitylib.character.RootPart.Position),
				rayCheck
			)
			if ray then return false end
		end
		
		local humanoid = ent.Character:FindFirstChild("Humanoid")
		if not humanoid or humanoid.Health <= 0 then return false end
		
		return true
	end
	
	local function getAimSpeed(sliderValue)
		local baseSpeed = 0.008
		local multiplier = 1.35
		local speed = baseSpeed * (multiplier ^ sliderValue)
		return math.min(speed, 0.95)
	end
	
	local function getTargetPart(ent)
		if not ent or not ent.Character then return nil end
		
		if AimPart.Value == "Head" then
			return ent.Character:FindFirstChild("Head") or ent.Head or ent.RootPart
		elseif AimPart.Value == "Torso" then
			return ent.Character:FindFirstChild("Torso") or ent.Character:FindFirstChild("UpperTorso") or ent.RootPart
		else
			return ent.RootPart
		end
	end
	
	local function getPredictedPosition(ent, origin)
		if not ent or not ent.RootPart then return nil end
		
		local targetBodyPart = getTargetPart(ent)
		if not targetBodyPart then return nil end
		
		if PAMode.Value == 'Aero' then
			local projSpeed = 100
			local gravity = 196.2
			
			if store.hand and store.hand.tool then
				local toolName = store.hand.tool.Name
				local itemMeta = bedwars.ItemMeta[toolName]
				if itemMeta and itemMeta.projectileSource then
					local projectileSource = itemMeta.projectileSource
					local projectileType = projectileSource.projectileType
					
					if type(projectileType) == "function" then
						local success, result = pcall(projectileType, nil)
						if success then
							projectileType = result
						end
					end
					
					if projectileType then
						local projectileMeta = bedwars.ProjectileMeta[projectileType]
						if projectileMeta then
							projSpeed = projectileMeta.launchVelocity or 100
							gravity = (projectileMeta.gravitationalAcceleration or 196.2)
						end
					end
				end
			end
			
			local predictedPos = aerov4bad.predictStrafingMovement(
				ent.Player,
				targetBodyPart,
				projSpeed,
				gravity,
				origin
			)
			
			return predictedPos
		else
			local playerGravity = workspace.Gravity
			local balloons = ent.Character:GetAttribute('InflatedBalloons')
			
			if balloons and balloons > 0 then
				playerGravity = workspace.Gravity * (1 - (balloons >= 4 and 1.2 or balloons >= 3 and 1 or 0.975))
			end
			
			if ent.Character.PrimaryPart:FindFirstChild('rbxassetid://8200754399') then
				playerGravity = 6
			end
			
			if ent.Player and ent.Player:GetAttribute('IsOwlTarget') then
				for _, owl in collectionService:GetTagged('Owl') do
					if owl:GetAttribute('Target') == ent.Player.UserId and owl:GetAttribute('Status') == 2 then
						playerGravity = 0
						break
					end
				end
			end
			
			local projSpeed = 100
			local gravity = 196.2
			
			if store.hand and store.hand.tool then
				local toolName = store.hand.tool.Name
				local itemMeta = bedwars.ItemMeta[toolName]
				if itemMeta and itemMeta.projectileSource then
					local projectileSource = itemMeta.projectileSource
					local projectileType = projectileSource.projectileType
					
					if type(projectileType) == "function" then
						local success, result = pcall(projectileType, nil)
						if success then
							projectileType = result
						end
					end
					
					if projectileType then
						local projectileMeta = bedwars.ProjectileMeta[projectileType]
						if projectileMeta then
							projSpeed = projectileMeta.launchVelocity or 100
							gravity = (projectileMeta.gravitationalAcceleration or 196.2)
						end
					end
				end
			end
			
			local calc = prediction.SolveTrajectory(
				origin,
				projSpeed,
				gravity,
				targetBodyPart.Position,
				targetBodyPart.Velocity,
				playerGravity,
				ent.HipHeight,
				ent.Jumping and 42.6 or nil,
				rayCheck
			)
			
			return calc
		end
	end
	
	ProjectileAimAssist = vape.Categories.Combat:CreateModule({
		Name = 'ProjectileAimAssist',
		Function = function(callback)
			if callback then
				ProjectileAimAssist:Clean(runService.RenderStepped:Connect(function(dt)
					if not (entitylib.isAlive and isHoldingProjectile() and ((not ClickAim.Enabled) or (workspace:GetServerTimeNow() - bedwars.SwordController.lastAttack) < 0.4)) then
						lockedTarget = nil
						currentTarget = nil
						hasReacted = false
						return
					end
					
					if ShopCheck.Enabled then
						local isShop = lplr:FindFirstChild("PlayerGui") and lplr.PlayerGui:FindFirstChild("ItemShop")
						if isShop then return end
					end
					
					if FirstPersonCheck.Enabled and not isFirstPerson() then return end
					
					local ent = nil
					
					if PriorityMode.Enabled then
						if lockedTarget and isTargetValid(lockedTarget, Distance.Value) then
							local delta = (lockedTarget.RootPart.Position - entitylib.character.RootPart.Position)
							local localfacing = entitylib.character.RootPart.CFrame.LookVector * Vector3.new(1, 0, 1)
							local angle = math.acos(localfacing:Dot((delta * Vector3.new(1, 0, 1)).Unit))
							
							if angle < (math.rad(AngleSlider.Value) / 2) then
								ent = lockedTarget
							else
								lockedTarget = nil
								currentTarget = nil
								hasReacted = false
							end
						else
							lockedTarget = nil
						end
						
						if not ent then
							ent = entitylib.EntityPosition({
								Range = Distance.Value,
								Part = 'RootPart',
								Wallcheck = Targets.Walls.Enabled,
								Players = Targets.Players.Enabled,
								NPCs = Targets.NPCs.Enabled,
								Sort = sortmethods.Distance
							})
							
							if ent then
								lockedTarget = ent
							end
						end
					else
						lockedTarget = nil
						ent = entitylib.EntityPosition({
							Range = Distance.Value,
							Part = 'RootPart',
							Wallcheck = Targets.Walls.Enabled,
							Players = Targets.Players.Enabled,
							NPCs = Targets.NPCs.Enabled,
							Sort = sortmethods.Distance
						})
					end
					
					if ent then
						if currentTarget ~= ent then
							currentTarget = ent
							hasReacted = false
							reactionStartTime = tick()
						end
						
						if not hasReacted then
							local reactionDelay = ReactionTime.Value / 1000
							local randomVariance = (rng:NextNumber() - 0.5) * 0.3 * reactionDelay
							local actualDelay = reactionDelay + randomVariance
							
							if (tick() - reactionStartTime) < actualDelay then
								return
							else
								hasReacted = true
							end
						end
						
						pcall(function()
							local plr = ent
							vapeTargetInfo.Targets.ProjectileAimAssist = {
								Humanoid = {
									Health = (plr.Character:GetAttribute("Health") or plr.Humanoid.Health) + getShieldAttribute(plr.Character),
									MaxHealth = plr.Character:GetAttribute("MaxHealth") or plr.Humanoid.MaxHealth
								},
								Player = plr.Player
							}
						end)
						
						local delta = (ent.RootPart.Position - entitylib.character.RootPart.Position)
						local localfacing = entitylib.character.RootPart.CFrame.LookVector * Vector3.new(1, 0, 1)
						local angle = math.acos(localfacing:Dot((delta * Vector3.new(1, 0, 1)).Unit))
						if angle >= (math.rad(AngleSlider.Value) / 2) then return end
						
						targetinfo.Targets[ent] = tick() + 1
						
						local origin = entitylib.character.RootPart.Position
						local predictedPosition = getPredictedPosition(ent, origin)
						
						if not predictedPosition then return end
						
						local aimPosition = predictedPosition
						
						if VerticalAim.Enabled then
							aimPosition = aimPosition + Vector3.new(0, VerticalOffset.Value, 0)
						end
						
						local finalAimSpeed = getAimSpeed(AimSpeed.Value)
						
						if StrafeMultiplier.Enabled and (inputService:IsKeyDown(Enum.KeyCode.A) or inputService:IsKeyDown(Enum.KeyCode.D)) then
							finalAimSpeed = finalAimSpeed * 1.15
						end
						
						if ShakeToggle.Enabled and ShakeAmount.Value > 0 then
							local shakeIntensity = ShakeAmount.Value / 10
							local speedVariation = 1 + ((rng:NextNumber() - 0.5) * shakeIntensity * 0.3)
							finalAimSpeed = finalAimSpeed * speedVariation
							
							local jitterAmount = ShakeAmount.Value * 0.1
							local microJitter = Vector3.new(
								(rng:NextNumber() - 0.5) * jitterAmount,
								(rng:NextNumber() - 0.5) * jitterAmount,
								(rng:NextNumber() - 0.5) * jitterAmount
							)
							aimPosition = aimPosition + microJitter
						end
						
						local targetCFrame = CFrame.lookAt(gameCamera.CFrame.p, aimPosition)
						gameCamera.CFrame = gameCamera.CFrame:Lerp(targetCFrame, finalAimSpeed)
						lastAimCFrame = targetCFrame
						aimingAtTarget = true
					else
						currentTarget = nil
						hasReacted = false
						
						if aimingAtTarget and lastAimCFrame then
							local retractSpeed = 0.05
							if (gameCamera.CFrame.Position - lastAimCFrame.Position).Magnitude > 0.1 then
								gameCamera.CFrame = gameCamera.CFrame:Lerp(
									CFrame.new(gameCamera.CFrame.Position, gameCamera.CFrame.Position + gameCamera.CFrame.LookVector),
									retractSpeed
								)
							else
								aimingAtTarget = false
								lastAimCFrame = nil
							end
						end
						
						if PriorityMode.Enabled then
							lockedTarget = nil
						end
					end
				end))
			else
				lockedTarget = nil
				aimingAtTarget = false
				lastAimCFrame = nil
				currentTarget = nil
				hasReacted = false
			end
		end,
		Tooltip = 'Projectile aim assist with prediction'
	})
	
	Targets = ProjectileAimAssist:CreateTargets({
		Players = true,
		Walls = true
	})
	
	PAMode = ProjectileAimAssist:CreateDropdown({
		Name = 'Prediction Mode',
		List = {'Vape', 'Aero'},
		Default = 'Aero',
		Tooltip = 'Vape = Built-in | Aero = Custom'
	})
	
	AimSpeed = ProjectileAimAssist:CreateSlider({
		Name = 'Aim Speed',
		Min = 1,
		Max = 20,
		Default = 6,
		Tooltip = 'How fast the aim assistant tracks'
	})
	
	ReactionTime = ProjectileAimAssist:CreateSlider({
		Name = 'Reaction Time',
		Min = 0,
		Max = 300,
		Default = 80,
		Suffix = 'ms',
		Tooltip = 'Delay before aim assist activates'
	})
	
	Distance = ProjectileAimAssist:CreateSlider({
		Name = 'Distance',
		Min = 1,
		Max = 30,
		Default = 25,
		Suffix = function(val)
			return val == 1 and 'stud' or 'studs'
		end
	})
	
	AngleSlider = ProjectileAimAssist:CreateSlider({
		Name = 'Max Angle',
		Min = 1,
		Max = 360,
		Default = 60,
		Tooltip = 'FOV angle for target acquisition'
	})
	
	AimPart = ProjectileAimAssist:CreateDropdown({
		Name = 'Aim Part',
		List = {'Root', 'Torso', 'Head'},
		Default = 'Root'
	})
	
	PriorityMode = ProjectileAimAssist:CreateToggle({
		Name = 'Priority Mode',
		Default = false,
		Tooltip = 'Lock onto one target'
	})
	
	ClickAim = ProjectileAimAssist:CreateToggle({
		Name = 'Click Aim',
		Default = true,
		Tooltip = 'Only aim when attacking'
	})
	
	VerticalAim = ProjectileAimAssist:CreateToggle({
		Name = 'Vertical Offset',
		Default = false,
		Function = function(callback)
			VerticalOffset.Object.Visible = callback
		end
	})
	
	VerticalOffset = ProjectileAimAssist:CreateSlider({
		Name = 'Offset',
		Min = -3,
		Max = 3,
		Default = 0,
		Decimal = 10,
		Visible = false
	})
	
	ShakeToggle = ProjectileAimAssist:CreateToggle({
		Name = 'Shake',
		Default = false,
		Function = function(callback)
			ShakeAmount.Object.Visible = callback
		end,
		Tooltip = 'Add jitter to aim'
	})
	
	ShakeAmount = ProjectileAimAssist:CreateSlider({
		Name = 'Shake Amount',
		Min = 1,
		Max = 10,
		Default = 3,
		Visible = false
	})
	
	ShopCheck = ProjectileAimAssist:CreateToggle({
		Name = "Shop Check",
		Default = false,
		Tooltip = 'Disable when shop is open'
	})
	
	FirstPersonCheck = ProjectileAimAssist:CreateToggle({
		Name = "First Person Only",
		Default = false,
		Tooltip = 'Only work in first person'
	})
	
	StrafeMultiplier = ProjectileAimAssist:CreateToggle({
		Name = 'Strafe Boost',
		Tooltip = 'Faster aim when strafing'
	})
end)
	
run(function()
    local isMobileDevice = inputService.TouchEnabled and not inputService.KeyboardEnabled and not inputService.MouseEnabled

    if isMobileDevice then
        local AutoClicker
        local CPS
        local BlockCPS = {}
        local Thread

        local function getSafeCPS()
            if store.hand and store.hand.toolType == 'block' and BlockCPS and BlockCPS.GetRandomValue then
                return BlockCPS
            end
            if CPS and CPS.GetRandomValue then
                return CPS
            end
            return nil
        end

        local function AutoClick()
            if Thread then
                task.cancel(Thread)
                Thread = nil
            end

            local initialCPS = getSafeCPS()
            if not initialCPS then return end

            Thread = task.delay(1 / initialCPS.GetRandomValue(), function()
                repeat
                    if not bedwars.AppController:isLayerOpen(bedwars.UILayers.MAIN) then
                        local blockPlacer = bedwars.BlockPlacementController and bedwars.BlockPlacementController.blockPlacer
                        local toolType = store.hand and store.hand.toolType

                        if toolType == 'block' and blockPlacer then
                            task.spawn(function()
                                blockPlacer:autoBridge(workspace:GetServerTimeNow() - bedwars.KnockbackController:getLastKnockbackTime() >= 0.2)
                            end)
                        elseif toolType == 'sword' then
                            bedwars.SwordController:swingSwordAtMouse(0.39)
                        end
                    end

                    local currentCPS = getSafeCPS()
                    if not currentCPS then
                        task.wait(0.1)
                    else
                        task.wait(1 / currentCPS.GetRandomValue())
                    end
                until not AutoClicker.Enabled
            end)
        end

        local function StopClick()
            if Thread then
                task.cancel(Thread)
                Thread = nil
            end
        end

        AutoClicker = vape.Categories.Combat:CreateModule({
            Name = 'AutoClicker',
            Function = function(callback)
                if callback then
                    AutoClicker:Clean(inputService.InputBegan:Connect(function(input)
                        if input.UserInputType == Enum.UserInputType.MouseButton1 then
                            AutoClick()
                        end
                    end))

                    AutoClicker:Clean(inputService.InputEnded:Connect(function(input)
                        if input.UserInputType == Enum.UserInputType.MouseButton1 then
                            StopClick()
                        end
                    end))

                    for _, v in {'2', '5'} do
                        pcall(function()
                            AutoClicker:Clean(lplr.PlayerGui.MobileUI[v].MouseButton1Down:Connect(AutoClick))
                            AutoClicker:Clean(lplr.PlayerGui.MobileUI[v].MouseButton1Up:Connect(StopClick))
                        end)
                    end
                else
                    StopClick()
                end
            end,
            Tooltip = 'Hold attack button to automatically click'
        })

        CPS = AutoClicker:CreateTwoSlider({
            Name = 'CPS',
            Min = 1,
            Max = 9,
            DefaultMin = 7,
            DefaultMax = 7
        })

        AutoClicker:CreateToggle({
            Name = 'Place Blocks',
            Default = true,
            Function = function(callback)
                if BlockCPS.Object then
                    BlockCPS.Object.Visible = callback
                end
            end
        })

        BlockCPS = AutoClicker:CreateTwoSlider({
            Name = 'Block CPS',
            Min = 1,
            Max = 20,
            DefaultMin = 12,
            DefaultMax = 12,
            Darker = true
        })

    else
        local AutoClicker
        local ACMode
        local CPS
        local BlockCPS = {}
        local SwordCPS = {}
        local ProjectileCPS = {}
        local PlaceBlocksToggle
        local SwingSwordToggle
        local ShootProjectilesToggle
        local Thread
        local KeybindToggle
        local KeybindList
        local MouseBindToggle
        local MouseBindList
        local KeybindMode
        local CurrentKeybind = Enum.KeyCode.LeftAlt
        local CurrentMouseBind = Enum.UserInputType.MouseButton2
        local UseMouseBind = false
        local KeybindEnabled = false
        local KeybindHeld = false
        local KeybindActive = false
        local ActivationScheduled = nil
        local MIN_HOLD_TIME = 0.12

        local task_wait = task.wait
        local task_spawn = task.spawn
        local tick = tick
        local workspace_GetServerTimeNow = function() return workspace:GetServerTimeNow() end
        local projectileRemote = {InvokeServer = function() end}
        local FireDelays = {}

        task.spawn(function()
            projectileRemote = bedwars.Client:Get(remotes.FireProjectile).instance
        end)

        local ammoCache = {}
        local lastAmmoCheck = 0
        local function getAmmo(check)
            local now = tick()
            if now - lastAmmoCheck < 0.5 then
                local cached = ammoCache[check]
                if cached then return cached end
            end
            for _, item in store.inventory.inventory.items do
                if check.ammoItemTypes and table.find(check.ammoItemTypes, item.itemType) then
                    ammoCache[check] = item.itemType
                    lastAmmoCheck = now
                    return item.itemType
                end
            end
            return nil
        end

        local lastToolName = nil
        local lastProjectileResult = false
        local function isHoldingProjectile()
            if not store.hand or not store.hand.tool then
                lastProjectileResult = false
                return false
            end
            local tool = store.hand.tool
            if tool.Name == lastToolName then return lastProjectileResult end
            lastToolName = tool.Name
            local toolName = tool.Name:lower()
            lastProjectileResult = toolName:find('bow') ~= nil or toolName:find('crossbow') ~= nil
            return lastProjectileResult
        end

        local function shootProjectile()
            if not store.hand or not store.hand.tool then return end
            if not isHoldingProjectile() then return end
            local tool = store.hand.tool
            local itemMeta = bedwars.ItemMeta[tool.Name]
            if not itemMeta or not itemMeta.projectileSource then return end
            local projectileSource = itemMeta.projectileSource
            local ammo = getAmmo(projectileSource)
            if not ammo then return end
            local projectileType = projectileSource.projectileType
            if type(projectileType) == 'function' then
                local success, result = pcall(projectileType, ammo)
                if success then projectileType = result end
            end
            if not projectileType then return end
            local projectileMeta = bedwars.ProjectileMeta[projectileType]
            if not projectileMeta then return end
            local now = tick()
            if (FireDelays[tool.Name] or 0) > now then return end
            local pos = entitylib.character.RootPart.Position
            local lookVector = gameCamera.CFrame.LookVector
            local shootPosition = (gameCamera.CFrame * CFrame.new(Vector3.new(-bedwars.BowConstantsTable.RelX, -bedwars.BowConstantsTable.RelY, -bedwars.BowConstantsTable.RelZ))).Position
            task_spawn(function()
                local id = httpService:GenerateGUID(true)
                local projSpeed = projectileMeta.launchVelocity or 100
                local toolName = tool.Name
                local isCrossbow = toolName:find('crossbow') ~= nil
                if isCrossbow then
                    bedwars.ViewmodelController:playAnimation(bedwars.AnimationType.FP_CROSSBOW_FIRE)
                    bedwars.GameAnimationUtil:playAnimation(lplr, bedwars.AnimationType.CROSSBOW_FIRE)
                elseif toolName:find('bow') then
                    bedwars.ViewmodelController:playAnimation(bedwars.AnimationType.FP_CROSSBOW_FIRE)
                    bedwars.GameAnimationUtil:playAnimation(lplr, bedwars.AnimationType.BOW_FIRE)
                end
                bedwars.ProjectileController:createLocalProjectile(projectileMeta, ammo, projectileType, shootPosition, id, lookVector * projSpeed, {drawDurationSeconds = 1})
                local res = projectileRemote:InvokeServer(tool, ammo, projectileType, shootPosition, pos, lookVector * projSpeed, id, {drawDurationSeconds = 1, shotId = httpService:GenerateGUID(false)}, workspace_GetServerTimeNow() - 0.045)
                if res then
                    local shoot = projectileSource.launchSound
                    shoot = shoot and shoot[math.random(1, #shoot)] or nil
                    if shoot then bedwars.SoundManager:playSound(shoot) end
                end
            end)
            FireDelays[tool.Name] = now + (projectileSource.fireDelaySec or 0.5)
        end

        local function getSafeCPS()
            local toolType = store.hand and store.hand.toolType or nil
            if toolType == 'block' and PlaceBlocksToggle and PlaceBlocksToggle.Enabled and BlockCPS and BlockCPS.GetRandomValue then
                return BlockCPS
            elseif toolType == 'sword' and SwingSwordToggle and SwingSwordToggle.Enabled and SwordCPS and SwordCPS.GetRandomValue then
                return SwordCPS
            elseif ShootProjectilesToggle and ShootProjectilesToggle.Enabled and isHoldingProjectile() and ProjectileCPS and ProjectileCPS.GetRandomValue then
                return ProjectileCPS
            elseif CPS and CPS.GetRandomValue then
                return CPS
            end
            return nil
        end

        local function UpdateKeybindState()
            if not KeybindEnabled then
                KeybindActive = true
                return
            end
            if KeybindMode.Value == 'Toggle' then
                return
            elseif KeybindMode.Value == 'Hold' then
                if UseMouseBind then
                    KeybindActive = inputService:IsMouseButtonPressed(CurrentMouseBind)
                else
                    KeybindActive = inputService:IsKeyDown(CurrentKeybind)
                end
            end
        end

        local function AutoClickVape()
            if Thread then task.cancel(Thread) end
            local initialCPS = getSafeCPS()
            if not initialCPS then return end
            Thread = task.delay(1 / initialCPS.GetRandomValue(), function()
                repeat
                    if not bedwars.AppController:isLayerOpen(bedwars.UILayers.MAIN) then
                        local blockPlacer = bedwars.BlockPlacementController and bedwars.BlockPlacementController.blockPlacer
                        local toolType = store.hand and store.hand.toolType
                        if toolType == 'block' and blockPlacer then
                            if (workspace_GetServerTimeNow() - bedwars.BlockCpsController.lastPlaceTimestamp) >= ((1 / 12) * 0.5) then
                                local mouseinfo = blockPlacer.clientManager:getBlockSelector():getMouseInfo(0)
                                if mouseinfo and mouseinfo.placementPosition == mouseinfo.placementPosition then
                                    task.spawn(blockPlacer.placeBlock, blockPlacer, mouseinfo.placementPosition)
                                end
                            end
                        elseif toolType == 'sword' then
                            bedwars.SwordController:swingSwordAtMouse(0.39)
                        end
                    end
                    local currentCPS = getSafeCPS()
                    task_wait(1 / (currentCPS and currentCPS.GetRandomValue() or 7))
                until not AutoClicker.Enabled
            end)
        end

        local function AutoClickAero()
            if Thread then task.cancel(Thread) end
            Thread = task_spawn(function()
                local toolCheckCounter = 0
                repeat
                    if KeybindEnabled and KeybindMode.Value == 'Hold' then
                        if toolCheckCounter % 3 == 0 then
                            UpdateKeybindState()
                        end
                        if not KeybindActive then
                            task_wait(0.1)
                            toolCheckCounter += 1
                            continue
                        end
                    end

                    toolCheckCounter += 1

                    if not bedwars.AppController:isLayerOpen(bedwars.UILayers.MAIN) and not _G.autoShootLock then
                        local toolType = store.hand and store.hand.toolType
                        if PlaceBlocksToggle.Enabled and toolType == 'block' then
                            local blockPlacer = bedwars.BlockPlacementController and bedwars.BlockPlacementController.blockPlacer
                            if blockPlacer then
                                if (workspace_GetServerTimeNow() - bedwars.BlockCpsController.lastPlaceTimestamp) >= ((1 / 12) * 0.5) then
                                    local mouseinfo = blockPlacer.clientManager:getBlockSelector():getMouseInfo(0)
                                    if mouseinfo and mouseinfo.placementPosition == mouseinfo.placementPosition then
                                        task_spawn(blockPlacer.placeBlock, blockPlacer, mouseinfo.placementPosition)
                                    end
                                end
                            end
                        elseif SwingSwordToggle.Enabled and toolType == 'sword' then
                            bedwars.SwordController:swingSwordAtMouse(0.39)
                        elseif ShootProjectilesToggle.Enabled and isHoldingProjectile() then
                            shootProjectile()
                        end
                    end

                    local currentCPS = getSafeCPS()
                    task_wait(1 / (currentCPS and currentCPS.GetRandomValue() or 7))
                until not AutoClicker.Enabled
            end)
        end

        local function AutoClick()
            if ACMode.Value == 'Vape' then
                AutoClickVape()
            else
                AutoClickAero()
            end
        end

        local function StartAutoClick()
            if not Thread then AutoClick() end
        end

        local function StopAutoClick()
            if Thread then
                task.cancel(Thread)
                Thread = nil
            end
            if ActivationScheduled then
                task.cancel(ActivationScheduled)
                ActivationScheduled = nil
            end
        end

        local function ToggleKeybind()
            if KeybindMode.Value == 'Toggle' then
                KeybindHeld = not KeybindHeld
                KeybindActive = KeybindHeld
                if KeybindActive then StartAutoClick() else StopAutoClick() end
            end
        end

        local lastToggleRestart = 0
        local function SafeToggleRestart()
            local now = tick()
            if now - lastToggleRestart < 0.2 then return end
            lastToggleRestart = now
            if AutoClicker.Enabled then
                AutoClicker:Toggle()
                task_wait(0.05)
                AutoClicker:Toggle()
            end
        end

        local function updateModeVisibility()
            local isAero = ACMode.Value == 'Aero'
            if SwingSwordToggle and SwingSwordToggle.Object then SwingSwordToggle.Object.Visible = isAero end
            if SwordCPS and SwordCPS.Object then SwordCPS.Object.Visible = isAero end
            if ShootProjectilesToggle and ShootProjectilesToggle.Object then ShootProjectilesToggle.Object.Visible = isAero end
            if ProjectileCPS and ProjectileCPS.Object then ProjectileCPS.Object.Visible = isAero end
            if KeybindToggle and KeybindToggle.Object then KeybindToggle.Object.Visible = isAero end
            if KeybindMode and KeybindMode.Object then KeybindMode.Object.Visible = isAero and KeybindEnabled end
            if KeybindList and KeybindList.Object then KeybindList.Object.Visible = isAero and KeybindEnabled and not UseMouseBind end
            if MouseBindToggle and MouseBindToggle.Object then MouseBindToggle.Object.Visible = isAero and KeybindEnabled end
            if MouseBindList and MouseBindList.Object then MouseBindList.Object.Visible = isAero and KeybindEnabled and UseMouseBind end
        end

        AutoClicker = vape.Categories.Combat:CreateModule({
            Name = 'AutoClicker',
            Function = function(callback)
                if callback then
                    if KeybindEnabled and ACMode.Value == 'Aero' then
                        AutoClicker:Clean(inputService.InputBegan:Connect(function(input)
                            if UseMouseBind then
                                if input.UserInputType == CurrentMouseBind then
                                    if KeybindMode.Value == 'Hold' then StartAutoClick()
                                    elseif KeybindMode.Value == 'Toggle' then ToggleKeybind() end
                                end
                            else
                                if input.UserInputType == Enum.UserInputType.Keyboard then
                                    if input.KeyCode == CurrentKeybind then
                                        if KeybindMode.Value == 'Hold' then StartAutoClick()
                                        elseif KeybindMode.Value == 'Toggle' then ToggleKeybind() end
                                    end
                                end
                            end
                        end))
                        AutoClicker:Clean(inputService.InputEnded:Connect(function(input)
                            if KeybindMode.Value == 'Hold' then
                                if UseMouseBind then
                                    if input.UserInputType == CurrentMouseBind then StopAutoClick() end
                                else
                                    if input.UserInputType == Enum.UserInputType.Keyboard then
                                        if input.KeyCode == CurrentKeybind then StopAutoClick() end
                                    end
                                end
                            end
                        end))
                    else
                        AutoClicker:Clean(inputService.InputBegan:Connect(function(input)
                            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                                if not _G.autoShootLock then
                                    ActivationScheduled = task.delay(MIN_HOLD_TIME, function()
                                        ActivationScheduled = nil
                                        if inputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
                                            AutoClick()
                                        end
                                    end)
                                end
                            end
                        end))
                        AutoClicker:Clean(inputService.InputEnded:Connect(function(input)
                            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                                if ActivationScheduled then
                                    task.cancel(ActivationScheduled)
                                    ActivationScheduled = nil
                                end
                                if Thread then
                                    task.cancel(Thread)
                                    Thread = nil
                                end
                            end
                        end))
                    end
                else
                    StopAutoClick()
                    ammoCache = {}
                    lastToolName = nil
                end
            end,
            Tooltip = 'Clicks for you'
        })

        ACMode = AutoClicker:CreateDropdown({
            Name = 'AC Mode',
            List = {'Vape', 'Aero'},
            Default = 'Vape',
            Function = function(val)
                StopAutoClick()
                KeybindHeld = false
                KeybindActive = false
                updateModeVisibility()
                SafeToggleRestart()
            end
        })

        CPS = AutoClicker:CreateTwoSlider({
            Name = 'CPS',
            Min = 1,
            Max = 9,
            DefaultMin = 7,
            DefaultMax = 7
        })

        PlaceBlocksToggle = AutoClicker:CreateToggle({
            Name = 'Place Blocks',
            Default = true,
            Function = function(callback)
                if BlockCPS.Object then BlockCPS.Object.Visible = callback end
            end
        })

        BlockCPS = AutoClicker:CreateTwoSlider({
            Name = 'Block CPS',
            Min = 1,
            Max = 20,
            DefaultMin = 12,
            DefaultMax = 12,
            Darker = true
        })

        SwingSwordToggle = AutoClicker:CreateToggle({
            Name = 'Swing Sword',
            Default = true,
            Function = function(callback)
                if SwordCPS.Object then SwordCPS.Object.Visible = callback end
            end
        })

        SwordCPS = AutoClicker:CreateTwoSlider({
            Name = 'Sword CPS',
            Min = 1,
            Max = 9,
            DefaultMin = 7,
            DefaultMax = 7,
            Darker = true
        })

        ShootProjectilesToggle = AutoClicker:CreateToggle({
            Name = 'Shoot Projectiles',
            Default = true,
            Function = function(callback)
                if ProjectileCPS.Object then ProjectileCPS.Object.Visible = callback end
            end
        })

        ProjectileCPS = AutoClicker:CreateTwoSlider({
            Name = 'Projectile CPS',
            Min = 1,
            Max = 5,
            DefaultMin = 3,
            DefaultMax = 3,
            Darker = true
        })

        KeybindToggle = AutoClicker:CreateToggle({
            Name = 'Use Keybind',
            Default = false,
            Function = function(callback)
                KeybindEnabled = callback
                if KeybindList.Object then KeybindList.Object.Visible = callback and not UseMouseBind end
                if MouseBindToggle.Object then MouseBindToggle.Object.Visible = callback end
                if MouseBindList.Object then MouseBindList.Object.Visible = callback and UseMouseBind end
                if KeybindMode.Object then KeybindMode.Object.Visible = callback end
                SafeToggleRestart()
            end
        })

        KeybindMode = AutoClicker:CreateDropdown({
            Name = 'Keybind Mode',
            List = {'Hold', 'Toggle'},
            Default = 'Hold',
            Darker = true,
            Visible = false,
            Function = function(value)
                KeybindHeld = false
                KeybindActive = false
                SafeToggleRestart()
            end
        })

        KeybindList = AutoClicker:CreateDropdown({
            Name = 'Keybind',
            List = {'LeftAlt','LeftControl','LeftShift','RightAlt','RightControl','RightShift','Space','CapsLock','Tab','E','Q','R','F','G','X','Z','V','B'},
            Default = 'LeftAlt',
            Darker = true,
            Visible = false,
            Function = function(value)
                CurrentKeybind = Enum.KeyCode[value]
                KeybindHeld = false
                KeybindActive = false
                SafeToggleRestart()
            end
        })

        MouseBindToggle = AutoClicker:CreateToggle({
            Name = 'Use Mouse Button',
            Default = false,
            Visible = false,
            Function = function(callback)
                UseMouseBind = callback
                if KeybindList.Object then KeybindList.Object.Visible = KeybindEnabled and not callback end
                if MouseBindList.Object then MouseBindList.Object.Visible = KeybindEnabled and callback end
                KeybindHeld = false
                KeybindActive = false
                SafeToggleRestart()
            end
        })

        MouseBindList = AutoClicker:CreateDropdown({
            Name = 'Mouse Button',
            List = {'Right Click', 'Middle Click'},
            Default = 'Right Click',
            Darker = true,
            Visible = false,
            Function = function(value)
                local map = {['Right Click'] = Enum.UserInputType.MouseButton2, ['Middle Click'] = Enum.UserInputType.MouseButton3}
                CurrentMouseBind = map[value]
                KeybindHeld = false
                KeybindActive = false
                SafeToggleRestart()
            end
        })

        updateModeVisibility()
    end
end)

run(function()
    local KitRender
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer
    local PlayerGui = player:WaitForChild("PlayerGui")

    local ids = {
        ['none'] = "rbxassetid://16493320215",
        ["random"] = "rbxassetid://79773209697352",
        ["cowgirl"] = "rbxassetid://9155462968",
        ["davey"] = "rbxassetid://9155464612",
        ["warlock"] = "rbxassetid://15186338366",
        ["ember"] = "rbxassetid://9630017904",
        ["black_market_trader"] = "rbxassetid://9630017904",
        ["yeti"] = "rbxassetid://9166205917",
        ["scarab"] = "rbxassetid://137137517627492",
        ["defender"] = "rbxassetid://131690429591874",
        ["cactus"] = "rbxassetid://104436517801089",
        ["oasis"] = "rbxassetid://120283205213823",
        ["berserker"] = "rbxassetid://90258047545241",
        ["sword_shield"] = "rbxassetid://131690429591874",
        ["airbender"] = "rbxassetid://74712750354593",
        ["gun_blade"] = "rbxassetid://138231219644853",
        ["frost_hammer_kit"] = "rbxassetid://11838567073",
        ["spider_queen"] = "rbxassetid://95237509752482",
        ["archer"] = "rbxassetid://9224796984",
        ["axolotl"] = "rbxassetid://9155466713",
        ["baker"] = "rbxassetid://9155463919",
        ["barbarian"] = "rbxassetid://9166207628",
        ["builder"] = "rbxassetid://9155463708",
        ["necromancer"] = "rbxassetid://11343458097",
        ["cyber"] = "rbxassetid://9507126891",
        ["sorcerer"] = "rbxassetid://97940108361528",
        ["bigman"] = "rbxassetid://9155467211",
        ["spirit_assassin"] = "rbxassetid://10406002412",
        ["farmer_cletus"] = "rbxassetid://9155466936",
        ["ice_queen"] = "rbxassetid://9155466204",
        ["grim_reaper"] = "rbxassetid://9155467410",
        ["spirit_gardener"] = "rbxassetid://132108376114488",
        ["hannah"] = "rbxassetid://10726577232",
        ["shielder"] = "rbxassetid://9155464114",
        ["summoner"] = "rbxassetid://18922378956",
        ["glacial_skater"] = "rbxassetid://84628060516931",
        ["dragon_sword"] = "rbxassetid://16215630104",
        ["lumen"] = "rbxassetid://9630018371",
        ["flower_bee"] = "rbxassetid://101569742252812",
        ["jellyfish"] = "rbxassetid://18129974852",
        ["melody"] = "rbxassetid://9155464915",
        ["mimic"] = "rbxassetid://14783283296",
        ["miner"] = "rbxassetid://9166208461",
        ["nazar"] = "rbxassetid://18926951849",
        ["seahorse"] = "rbxassetid://11902552560",
        ["elk_master"] = "rbxassetid://15714972287",
        ["rebellion_leader"] = "rbxassetid://18926409564",
        ["void_hunter"] = "rbxassetid://122370766273698",
        ["taliyah"] = "rbxassetid://13989437601",
        ["angel"] = "rbxassetid://9166208240",
        ["harpoon"] = "rbxassetid://18250634847",
        ["void_walker"] = "rbxassetid://78915127961078",
        ["spirit_summoner"] = "rbxassetid://95760990786863",
        ["triple_shot"] = "rbxassetid://9166208149",
        ["void_knight"] = "rbxassetid://73636326782144",
        ["regent"] = "rbxassetid://9166208904",
        ["vulcan"] = "rbxassetid://9155465543",
        ["owl"] = "rbxassetid://12509401147",
        ["dasher"] = "rbxassetid://9155467645",
        ["disruptor"] = "rbxassetid://11596993583",
        ["wizard"] = "rbxassetid://13353923546",
        ["aery"] = "rbxassetid://9155463221",
        ["agni"] = "rbxassetid://17024640133",
        ["alchemist"] = "rbxassetid://9155462512",
        ["spearman"] = "rbxassetid://9166207341",
        ["beekeeper"] = "rbxassetid://9312831285",
        ["falconer"] = "rbxassetid://17022941869",
        ["bounty_hunter"] = "rbxassetid://9166208649",
        ["blood_assassin"] = "rbxassetid://12520290159",
        ["battery"] = "rbxassetid://10159166528",
        ["steam_engineer"] = "rbxassetid://15380413567",
        ["vesta"] = "rbxassetid://9568930198",
        ["beast"] = "rbxassetid://9155465124",
        ["dino_tamer"] = "rbxassetid://9872357009",
        ["drill"] = "rbxassetid://12955100280",
        ["elektra"] = "rbxassetid://13841413050",
        ["fisherman"] = "rbxassetid://9166208359",
        ["queen_bee"] = "rbxassetid://12671498918",
        ["card"] = "rbxassetid://13841410580",
        ["frosty"] = "rbxassetid://9166208762",
        ["gingerbread_man"] = "rbxassetid://9155464364",
        ["ghost_catcher"] = "rbxassetid://9224802656",
        ["tinker"] = "rbxassetid://17025762404",
        ["ignis"] = "rbxassetid://13835258938",
        ["oil_man"] = "rbxassetid://9166206259",
        ["jade"] = "rbxassetid://9166306816",
        ["dragon_slayer"] = "rbxassetid://10982192175",
        ["paladin"] = "rbxassetid://11202785737",
        ["pinata"] = "rbxassetid://10011261147",
        ["merchant"] = "rbxassetid://9872356790",
        ["metal_detector"] = "rbxassetid://9378298061",
        ["slime_tamer"] = "rbxassetid://15379766168",
        ["nyoka"] = "rbxassetid://17022941410",
        ["midnight"] = "rbxassetid://9155462763",
        ["pyro"] = "rbxassetid://9155464770",
        ["raven"] = "rbxassetid://9166206554",
        ["santa"] = "rbxassetid://9166206101",
        ["sheep_herder"] = "rbxassetid://9155465730",
        ["smoke"] = "rbxassetid://9155462247",
        ["spirit_catcher"] = "rbxassetid://9166207943",
        ["star_collector"] = "rbxassetid://9872356516",
        ["styx"] = "rbxassetid://17014536631",
        ["block_kicker"] = "rbxassetid://15382536098",
        ["trapper"] = "rbxassetid://9166206875",
        ["hatter"] = "rbxassetid://12509388633",
        ["ninja"] = "rbxassetid://15517037848",
        ["jailor"] = "rbxassetid://11664116980",
        ["warrior"] = "rbxassetid://9166207008",
        ["mage"] = "rbxassetid://10982191792",
        ["void_dragon"] = "rbxassetid://10982192753",
        ["cat"] = "rbxassetid://15350740470",
        ["wind_walker"] = "rbxassetid://9872355499",
        ['skeleton'] = "rbxassetid://120123419412119",
        ['winter_lady'] = "rbxassetid://83274578564074",
    }

    local activeLoops = {}
    local updateDebounce = {}
    local retryThread = nil

    local function createkitrender(plr)
        local icon = Instance.new("ImageLabel")
        icon.Name = "AeroV4KitRender" 
        icon.AnchorPoint = Vector2.new(1, 0.5)
        icon.BackgroundTransparency = 1
        icon.Position = UDim2.new(1.05, 0, 0.5, 0)
        icon.Size = UDim2.new(1.5, 0, 1.5, 0)
        icon.SizeConstraint = Enum.SizeConstraint.RelativeYY
        icon.ImageTransparency = 0.4
        icon.ScaleType = Enum.ScaleType.Crop
        local uar = Instance.new("UIAspectRatioConstraint")
        uar.AspectRatio = 1
        uar.AspectType = Enum.AspectType.FitWithinMaxSize
        uar.DominantAxis = Enum.DominantAxis.Width
        uar.Parent = icon
        icon.Image = ids[plr:GetAttribute("PlayingAsKit")] or ids["none"]
        return icon
    end

    local function removeallkitrenders()
        for key, _ in pairs(activeLoops) do
            activeLoops[key] = nil
        end
        table.clear(updateDebounce)
        
        if retryThread then
            task.cancel(retryThread)
            retryThread = nil
        end
        
        for _, v in ipairs(PlayerGui:GetDescendants()) do
            if v:IsA("ImageLabel") and v.Name == "AeroV4KitRender" then  
                v:Destroy()
            end
        end
    end

    local function refreshicon(icon, plr)
        if not icon or not icon.Parent then return end
        local kit = plr:GetAttribute("PlayingAsKit")
        local newImage = ids[kit] or ids["none"]
        if icon.Image ~= newImage then
            icon.Image = newImage
        end
    end

    local function findPlayer(label, container)
        local render = container:FindFirstChild("PlayerRender", true)
        if render and render:IsA("ImageLabel") and render.Image then
            local userId = string.match(render.Image, "id=(%d+)")
            if userId then
                local plr = Players:GetPlayerByUserId(tonumber(userId))
                if plr then return plr end
            end
        end
        local text = label.Text
        for _, plr in ipairs(Players:GetPlayers()) do
            if plr.Name == text or plr.DisplayName == text or plr:GetAttribute("DisguiseDisplayName") == text then
                return plr
            end
        end
    end

    local function handleLabel(label)
        if not (label:IsA("TextLabel") and label.Name == "PlayerName") then return end
        task.spawn(function()
            local container = label.Parent
            for _ = 1, 3 do
                if container and container.Parent then
                    container = container.Parent
                end
            end
            if not container or not container:IsA("Frame") then return end
            
            local playerFound = findPlayer(label, container)
            if not playerFound then
                task.wait(0.5)
                playerFound = findPlayer(label, container)
            end
            if not playerFound then return end
            
            container.Name = playerFound.Name
            local card = container:FindFirstChild("1") and container["1"]:FindFirstChild("MatchDraftPlayerCard")
            if not card then return end
            
            local icon = card:FindFirstChild("AeroV4KitRender")  
            if not icon then
                icon = createkitrender(playerFound)
                icon.Parent = card
            end
            
            local loopKey = playerFound.UserId
            if activeLoops[loopKey] then
                activeLoops[loopKey] = nil
            end
            activeLoops[loopKey] = true
            task.spawn(function()
                while activeLoops[loopKey] and container and container.Parent and KitRender.Enabled do
                    local currentTick = tick()
                    
                    if not updateDebounce[loopKey] or (currentTick - updateDebounce[loopKey]) >= 0.3 then
                        updateDebounce[loopKey] = currentTick
                        
                        local updatedPlayer = findPlayer(label, container)
                        if updatedPlayer and updatedPlayer ~= playerFound then
                            playerFound = updatedPlayer
                        end
                        
                        if playerFound and icon and icon.Parent then
                            refreshicon(icon, playerFound)
                        end
                    end
                    
                    task.wait(0.3)  
                end
                
                activeLoops[loopKey] = nil
                updateDebounce[loopKey] = nil
            end)
        end)
    end

    local function setupKitRender()
        local success, team2 = pcall(function()
            return PlayerGui:FindFirstChild("MatchDraftApp") and
                   PlayerGui.MatchDraftApp:FindFirstChild("DraftAppBackground") and
                   PlayerGui.MatchDraftApp.DraftAppBackground:FindFirstChild("BodyContainer") and
                   PlayerGui.MatchDraftApp.DraftAppBackground.BodyContainer:FindFirstChild("Team2Column")
        end)
        
        if not success or not team2 then 
            return false 
        end
        
        for _, child in ipairs(team2:GetDescendants()) do
            if KitRender.Enabled then handleLabel(child) end
        end
        
        KitRender:Clean(team2.DescendantAdded:Connect(function(child)
            if KitRender.Enabled then handleLabel(child) end
        end))
        
        return true
    end

    KitRender = vape.Categories.Utility:CreateModule({
        Name = "KitRender (5v5)",
        Tooltip = "Allows you to see everyone's kit during kit phase (5v5, Ranked)",
        Function = function(callback)    
            if callback then
                local success = setupKitRender()
                
                if not success then
                    retryThread = task.spawn(function()
                        while KitRender.Enabled do
                            task.wait(1)
                            if setupKitRender() then
                                break
                            end
                        end
                    end)
                end
            else
                removeallkitrenders()
            end
        end
    })
end)

run(function()
    local activeConnections = {}
    local kitLabels = {}
    local updateDebounce = {}
    local retryThread = nil
    local playerMonitorThread = nil
    local processedPlayers = {}
    
    KitRender = vape.Categories.Utility:CreateModule({
        Name = "KitRender (squads)",
        Function = function(callback)   
            if callback then
                local function createKitLabel(parent, kitImage)
                    if kitLabels[parent] then
                        kitLabels[parent]:Destroy()
                    end
                    
                    local kitLabel = Instance.new("ImageLabel")
                    kitLabel.Name = "AeroV4KitIcon"
                    kitLabel.Size = UDim2.new(1, 0, 1, 0)
                    kitLabel.Position = UDim2.new(1.1, 0, 0, 0)
                    kitLabel.BackgroundTransparency = 1
                    kitLabel.Image = kitImage
                    kitLabel.Parent = parent
                    
                    kitLabels[parent] = kitLabel
                    return kitLabel
                end
                
                local function setupKitRender(obj)
                    if obj.Name == "PlayerRender" and obj.Parent and obj.Parent.Parent and obj.Parent.Parent.Parent and obj.Parent.Parent.Parent.Parent and obj.Parent.Parent.Parent.Parent.Parent and obj.Parent.Parent.Parent.Parent.Parent.Name == "MatchDraftTeamCardRow" then
                        local Rank = obj.Parent:FindFirstChild('3')
                        if not Rank then return end
                        
                        local userId = string.match(obj.Image, "id=(%d+)")
                        if not userId then return end
                        
                        local id = tonumber(userId)
                        if not id then return end
                        
                        local plr = playersService:GetPlayerByUserId(id)
                        if not plr then return end
                        
                        local loopKey = plr.UserId
                        
                        processedPlayers[loopKey] = true
                        
                        if activeConnections[loopKey] then
                            activeConnections[loopKey]:Disconnect()
                            activeConnections[loopKey] = nil
                        end
                        
                        local function updateKit()
                            if not KitRender.Enabled then return end
                            if not Rank or not Rank.Parent then
                                if activeConnections[loopKey] then
                                    activeConnections[loopKey]:Disconnect()
                                    activeConnections[loopKey] = nil
                                end
                                if kitLabels[Rank] then
                                    kitLabels[Rank]:Destroy()
                                    kitLabels[Rank] = nil
                                end
                                return
                            end
                            
                            local kitName = plr:GetAttribute("PlayingAsKits")
                            if not kitName then
                                kitName = "none"
                            end
                            
                            local render = bedwars.BedwarsKitMeta[kitName] or bedwars.BedwarsKitMeta.none
                            
                            if kitLabels[Rank] then
                                kitLabels[Rank].Image = render.renderImage
                            else
                                createKitLabel(Rank, render.renderImage)
                            end
                        end
                        
                        updateKit()
                        
                        local connection = plr:GetAttributeChangedSignal("PlayingAsKits"):Connect(function()
                            local currentTick = tick()
                            
                            if not updateDebounce[loopKey] or (currentTick - updateDebounce[loopKey]) >= 0.1 then
                                updateDebounce[loopKey] = currentTick
                                updateKit()
                            end
                        end)
                        
                        activeConnections[loopKey] = connection
                        KitRender:Clean(connection)
                    end
                end
                
                local function setupSquadsRender()
                    local teams = lplr.PlayerGui:FindFirstChild("MatchDraftApp")
                    if not teams then
                        return false
                    end
                    
                    task.wait(0.5)
                    
                    for _, obj in teams:GetDescendants() do
                        if KitRender.Enabled then
                            task.spawn(function()
                                setupKitRender(obj)
                            end)
                        end
                    end
                    
                    KitRender:Clean(teams.DescendantAdded:Connect(function(obj)
                        if KitRender.Enabled then
                            task.wait(0.1)
                            setupKitRender(obj)
                        end
                    end))
                    
                    return true
                end
                
                playerMonitorThread = task.spawn(function()
                    while KitRender.Enabled do
                        task.wait(0.5)
                        
                        local teams = lplr.PlayerGui:FindFirstChild("MatchDraftApp")
                        if teams then
                            for _, obj in teams:GetDescendants() do
                                if obj.Name == "PlayerRender" and KitRender.Enabled then
                                    local userId = string.match(obj.Image, "id=(%d+)")
                                    if userId then
                                        local id = tonumber(userId)
                                        if id and not processedPlayers[id] then
                                            task.spawn(function()
                                                setupKitRender(obj)
                                            end)
                                        end
                                    end
                                end
                            end
                        end
                    end
                end)
                
                task.spawn(function()
                    local success = setupSquadsRender()
                    
                    if not success then
                        retryThread = task.spawn(function()
                            while KitRender.Enabled do
                                task.wait(1)
                                if setupSquadsRender() then
                                    break
                                end
                            end
                        end)
                    end
                end)
            else
                if retryThread then
                    task.cancel(retryThread)
                    retryThread = nil
                end
                
                if playerMonitorThread then
                    task.cancel(playerMonitorThread)
                    playerMonitorThread = nil
                end
                
                for key, connection in pairs(activeConnections) do
                    if connection then
                        connection:Disconnect()
                    end
                    activeConnections[key] = nil
                end
                
                for parent, label in pairs(kitLabels) do
                    if label then
                        label:Destroy()
                    end
                    kitLabels[parent] = nil
                end
                
                table.clear(updateDebounce)
                table.clear(processedPlayers)
            end
        end,
        Tooltip = "Shows everyone's kit next to their rank during kit phase (squads ranked!)"
    })
end)

run(function()
    local AntiStuck
    local UIS = game:GetService("UserInputService")
    local runService = game:GetService("RunService")
    local camera = workspace.CurrentCamera
    
    local function absoluteReset()
        UIS.MouseBehavior = Enum.MouseBehavior.Default
        camera.CameraType = Enum.CameraType.Fixed
        task.wait()
        camera.CameraType = Enum.CameraType.Custom
        camera.CameraOffset = Vector3.new(0, 0, 0)
    end
    
    AntiStuck = vape.Categories.Legit:CreateModule({
        Name = 'Desire AntiStuck',
        Function = function(callback)
            if callback then
                AntiStuck:Clean(UIS.InputBegan:Connect(function(input)
                    if input.KeyCode == Enum.KeyCode.LeftControl then
                        absoluteReset()
                    end
                end))
                
                AntiStuck:Clean(runService.Heartbeat:Connect(function()
                    if not UIS:IsKeyDown(Enum.KeyCode.LeftShift) and not UIS:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
                        if UIS.MouseBehavior ~= Enum.MouseBehavior.Default and not UIS:GetFocusedTextBox() then
                            UIS.MouseBehavior = Enum.MouseBehavior.Default 
                        end
                    end
                end))
            end
        end,
        Tooltip = 'Fixes camera/mouse freeze. Press Left Control to force reset'
    })
end)
	
run(function()
	local Attack
	local Mine
	local Place
	local oldAttackReach, oldMineReach
	local oldIsAllowedPlacement

	Reach = vape.Categories.Combat:CreateModule({
		Name = 'Reach',
		Function = function(callback)
			if callback then
				oldAttackReach = bedwars.CombatConstant.RAYCAST_SWORD_CHARACTER_DISTANCE
				
				bedwars.CombatConstant.RAYCAST_SWORD_CHARACTER_DISTANCE = Attack.Value + 2
				
				task.spawn(function()
					repeat task.wait(0.1) until bedwars.BlockBreakController or not Reach.Enabled
					if not Reach.Enabled then return end
					
					pcall(function()
						local blockBreaker = bedwars.BlockBreakController:getBlockBreaker()
						if blockBreaker then
							oldMineReach = oldMineReach or blockBreaker:getRange()
							blockBreaker:setRange(Mine.Value)
						end
					end)
				end)
				
				task.spawn(function()
					repeat task.wait(0.1) until bedwars.BlockEngine or not Reach.Enabled
					if not Reach.Enabled then return end
					
					pcall(function()
						if not oldIsAllowedPlacement then
							oldIsAllowedPlacement = bedwars.BlockEngine.isAllowedPlacement
							bedwars.BlockEngine.isAllowedPlacement = function(self, player, blockType, position, rotation, mouseBlockInfo)
								local result = oldIsAllowedPlacement(self, player, blockType, position, rotation, mouseBlockInfo)
								
								if not result and player == game.Players.LocalPlayer then
									local blockExists = self:getStore():getBlockAt(position)
									if not blockExists then
										return true 
									end
								end
								
								return result
							end
						end
					end)
				end)
				
				task.spawn(function()
					repeat task.wait(0.1) until bedwars.BlockPlacementController or not Reach.Enabled
					if not Reach.Enabled then return end
					
					pcall(function()
						local blockPlacer = bedwars.BlockPlacementController:getBlockPlacer()
						if blockPlacer and blockPlacer.blockHighlighter then
							blockPlacer.blockHighlighter:setRange(Place.Value)
							blockPlacer.blockHighlighter.range = Place.Value
						end
					end)
				end)
				
				task.spawn(function()
					while Reach.Enabled do
						if bedwars.CombatConstant.RAYCAST_SWORD_CHARACTER_DISTANCE ~= Attack.Value + 2 then
							bedwars.CombatConstant.RAYCAST_SWORD_CHARACTER_DISTANCE = Attack.Value + 2
						end
						
						pcall(function()
							local blockBreaker = bedwars.BlockBreakController:getBlockBreaker()
							if blockBreaker and blockBreaker:getRange() ~= Mine.Value then
								blockBreaker:setRange(Mine.Value)
							end
						end)
						
						pcall(function()
							local blockPlacer = bedwars.BlockPlacementController:getBlockPlacer()
							if blockPlacer and blockPlacer.blockHighlighter then
								if blockPlacer.blockHighlighter.range ~= Place.Value then
									blockPlacer.blockHighlighter:setRange(Place.Value)
									blockPlacer.blockHighlighter.range = Place.Value
								end
							end
						end)
						
						task.wait(0.5)
					end
				end)
			else
				bedwars.CombatConstant.RAYCAST_SWORD_CHARACTER_DISTANCE = oldAttackReach or 14.4
				
				pcall(function()
					local blockBreaker = bedwars.BlockBreakController:getBlockBreaker()
					if blockBreaker then
						blockBreaker:setRange(oldMineReach or 18)
					end
				end)
				
				pcall(function()
					local blockPlacer = bedwars.BlockPlacementController:getBlockPlacer()
					if blockPlacer and blockPlacer.blockHighlighter then
						blockPlacer.blockHighlighter:setRange(18)
						blockPlacer.blockHighlighter.range = 18
					end
				end)
				
				if oldIsAllowedPlacement then
					pcall(function()
						bedwars.BlockEngine.isAllowedPlacement = oldIsAllowedPlacement
					end)
				end
				
				oldAttackReach, oldMineReach, oldIsAllowedPlacement = nil, nil, nil
			end
		end,
		Tooltip = 'Extends reach for attacking, mining, and placing blocks'
	})
	
	Attack = Reach:CreateSlider({
		Name = 'Attack Range',
		Min = 0,
		Max = 20,
		Default = 18,
		Function = function(val)
			if Reach.Enabled then
				bedwars.CombatConstant.RAYCAST_SWORD_CHARACTER_DISTANCE = val + 2
			end
		end,
		Suffix = function(val)
			return val == 1 and 'stud' or 'studs'
		end
	})
	
	Mine = Reach:CreateSlider({
		Name = 'Mine Range',
		Min = 0,
		Max = 30,
		Default = 18,
		Function = function(val)
			if Reach.Enabled then
				pcall(function()
					local blockBreaker = bedwars.BlockBreakController:getBlockBreaker()
					if blockBreaker then
						blockBreaker:setRange(val)
					end
				end)
			end
		end,
		Suffix = function(val)
			return val == 1 and 'stud' or 'studs'
		end
	})
	
	Place = Reach:CreateSlider({
		Name = 'Place Range',
		Min = 0,
		Max = 30,
		Default = 18,
		Function = function(val)
			if Reach.Enabled then
				pcall(function()
					local blockPlacer = bedwars.BlockPlacementController:getBlockPlacer()
					if blockPlacer and blockPlacer.blockHighlighter then
						blockPlacer.blockHighlighter:setRange(val)
						blockPlacer.blockHighlighter.range = val
					end
				end)
			end
		end,
		Suffix = function(val)
			return val == 1 and 'stud' or 'studs'
		end
	})
end)
	
run(function()
	local Sprint
	local old
	
	Sprint = vape.Categories.Combat:CreateModule({
		Name = 'Sprint',
		Function = function(callback)
			if callback then
				if inputService.TouchEnabled then 
					pcall(function() 
						lplr.PlayerGui.MobileUI['4'].Visible = false 
					end) 
				end
				old = bedwars.SprintController.stopSprinting
				bedwars.SprintController.stopSprinting = function(...)
					local call = old(...)
					bedwars.SprintController:startSprinting()
					return call
				end
				Sprint:Clean(entitylib.Events.LocalAdded:Connect(function() 
					task.delay(0.1, function() 
						bedwars.SprintController:stopSprinting() 
					end) 
				end))
				bedwars.SprintController:stopSprinting()
			else
				if inputService.TouchEnabled then 
					pcall(function() 
						lplr.PlayerGui.MobileUI['4'].Visible = true 
					end) 
				end
				bedwars.SprintController.stopSprinting = old
				bedwars.SprintController:stopSprinting()
			end
		end,
		Tooltip = 'Sets your sprinting to true.'
	})
end)
	
run(function()
	local TriggerBot
	local CPS
	local ProjectileMode
	local ProjectileFireRate
	local ProjectileWaitDelay
	local ProjectileFirstPerson
	local rayParams = RaycastParams.new()
	local lastProjectileShot = 0
	local wasHoldingProjectile = false
	local VirtualInputManager = game:GetService("VirtualInputManager")
	local tick = tick
	local task_wait = task.wait
	local pcall = pcall
	local lastClickTime = 0
	local clickCooldown = 0.015
	
	local function leftClick()
		local now = tick()
		if now - lastClickTime < clickCooldown then
			return false
		end
		
		local success = pcall(function()
			VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
			task_wait(0.02)
			VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
		end)
		
		if success then
			lastClickTime = now
		end
		return success
	end
	
	local lastFPCheck = 0
	local cachedFPResult = false
	local function isFirstPerson()
		local now = tick()
		if now - lastFPCheck < 0.1 then
			return cachedFPResult
		end
		lastFPCheck = now
		cachedFPResult = gameCamera.CFrame.Position.Magnitude - (gameCamera.Focus.Position).Magnitude < 1
		return cachedFPResult
	end
	
	local lastProjectileCheck = 0
	local cachedProjectileResult = false
	local lastHotbarSlot = -1
	local function isHoldingProjectile()
		if not entitylib.isAlive then 
			cachedProjectileResult = false
			return false 
		end

		local currentSlot = store.inventory.hotbarSlot

		if currentSlot == lastHotbarSlot and (tick() - lastProjectileCheck) < 0.2 then
			return cachedProjectileResult
		end
		
		lastHotbarSlot = currentSlot
		lastProjectileCheck = tick()
		
		local slotItem = store.inventory.hotbar[currentSlot + 1]
		
		if slotItem and slotItem.item and slotItem.item.itemType then
			local itemMeta = bedwars.ItemMeta[slotItem.item.itemType]
			if itemMeta and itemMeta.projectileSource then
				local projectileSource = itemMeta.projectileSource
				if projectileSource.ammoItemTypes and table.find(projectileSource.ammoItemTypes, 'arrow') then
					cachedProjectileResult = true
					return true
				end
			end
		end
		
		cachedProjectileResult = false
		return false
	end
	
	local cachedSwordRange = nil
	local lastSwordTool = nil
	
	TriggerBot = vape.Categories.Combat:CreateModule({
		Name = 'TriggerBot',
		Function = function(callback)
			if callback then
				local frameCounter = 0
				local lastToolType = nil
				
				repeat
					frameCounter = frameCounter + 1
					local doAttack = false
					local holdingProjectile = isHoldingProjectile()
					
					if not bedwars.AppController:isLayerOpen(bedwars.UILayers.MAIN) and entitylib.isAlive then
						if ProjectileMode.Enabled and holdingProjectile then
							if ProjectileFirstPerson.Enabled and not isFirstPerson() then
								wasHoldingProjectile = false
							else
								if holdingProjectile and not wasHoldingProjectile then
									task_wait(ProjectileWaitDelay.Value)
									leftClick()
									lastProjectileShot = tick()
									wasHoldingProjectile = true
								elseif holdingProjectile then
									local currentTime = tick()
									if (currentTime - lastProjectileShot) >= ProjectileFireRate.Value then
										leftClick()
										lastProjectileShot = currentTime
									end
								else
									wasHoldingProjectile = false
								end
							end
						elseif store.hand.toolType == 'sword' and bedwars.DaoController.chargingMaid == nil then
							local currentTool = store.hand.tool
							if currentTool ~= lastSwordTool then
								lastSwordTool = currentTool
								local itemMeta = bedwars.ItemMeta[currentTool.Name]
								cachedSwordRange = itemMeta and itemMeta.sword and itemMeta.sword.attackRange or 14.4
							end
							
							local attackRange = cachedSwordRange or 14.4
							
							if frameCounter % 2 == 0 then
								rayParams.FilterDescendantsInstances = {lplr.Character}
								
								local unit = lplr:GetMouse().UnitRay
								local localPos = entitylib.character.RootPart.Position
								local rayRange = attackRange
								local ray = bedwars.QueryUtil:raycast(unit.Origin, unit.Direction * 200, rayParams)
								
								if ray and (localPos - ray.Instance.Position).Magnitude <= rayRange then
									local entityList = entitylib.List
									for i = 1, #entityList do
										local ent = entityList[i]
										doAttack = ent.Targetable and ray.Instance:IsDescendantOf(ent.Character) and (localPos - ent.RootPart.Position).Magnitude <= rayRange
										if doAttack then
											break
										end
									end
								end
							end
							
							if not doAttack then
								doAttack = bedwars.SwordController:getTargetInRegion(attackRange or 3.8 * 3, 0)
							end
							
							if doAttack then
								bedwars.SwordController:swingSwordAtMouse()
							end
						else
							wasHoldingProjectile = false
						end
					end
					
					if doAttack and not holdingProjectile then
						task_wait(1 / CPS.GetRandomValue())
					else
						task_wait(holdingProjectile and 0.033 or 0.05)
					end
				until not TriggerBot.Enabled
			else
				cachedSwordRange = nil
				lastSwordTool = nil
				lastHotbarSlot = -1
				wasHoldingProjectile = false
			end
		end,
		Tooltip = 'Automatically swings when hovering over a entity'
	})
	
	CPS = TriggerBot:CreateTwoSlider({
		Name = 'CPS',
		Min = 1,
		Max = 9,
		DefaultMin = 7,
		DefaultMax = 7
	})
	
	ProjectileMode = TriggerBot:CreateToggle({
		Name = 'Projectile Mode',
		Tooltip = 'Auto-shoots crossbow/bow when holding projectile weapon'
	})
	
	ProjectileFireRate = TriggerBot:CreateSlider({
		Name = 'Projectile Fire Rate',
		Min = 0.1,
		Max = 3,
		Default = 1.2,
		Decimal = 10,
		Suffix = function(val)
			return val == 1 and 'second' or 'seconds'
		end,
		Tooltip = 'How fast to auto-fire (1.2 = every 1.2 seconds)',
		Visible = function()
			return ProjectileMode.Enabled
		end
	})
	
	ProjectileWaitDelay = TriggerBot:CreateSlider({
		Name = 'Projectile Wait Delay',
		Min = 0,
		Max = 1,
		Default = 0,
		Decimal = 100,
		Suffix = 's',
		Tooltip = 'Delay before shooting (helps prevent ghosting)',
		Visible = function()
			return ProjectileMode.Enabled
		end
	})
	
	ProjectileFirstPerson = TriggerBot:CreateToggle({
		Name = 'Projectile First Person Only',
		Default = false,
		Tooltip = 'Only works in first person mode',
		Visible = function()
			return ProjectileMode.Enabled
		end
	})
end)
	
run(function()
	local Velocity
	local Horizontal
	local Vertical
	local HorizontalChance
	local VerticalChance
	local TargetCheck
	local rand, old = Random.new()
	local lastTargetCheck = 0
	local cachedTargetResult = false
	local targetCheckCooldown = 0.5
	local shouldCheckHorizontal = true
	local shouldCheckVertical = true
	local tick = tick
	
	Velocity = vape.Categories.Combat:CreateModule({
		Name = 'Velocity',
		Function = function(callback)
			if callback then
				old = bedwars.KnockbackUtil.applyKnockback
				bedwars.KnockbackUtil.applyKnockback = function(root, mass, dir, knockback, ...)
					local horizValue = Horizontal.Value
					local vertValue = Vertical.Value
					
					if horizValue == 100 and vertValue == 100 then
						return old(root, mass, dir, knockback, ...)
					end
					local horizChance = HorizontalChance.Value
					local vertChance = VerticalChance.Value
					local reduceHorizontal = (horizChance >= 100) or (horizChance > 0 and rand:NextNumber(0, 100) <= horizChance)
					local reduceVertical = (vertChance >= 100) or (vertChance > 0 and rand:NextNumber(0, 100) <= vertChance)
					
					local targetCheckPassed = true
					if TargetCheck.Enabled then
						local now = tick()
						if now - lastTargetCheck > targetCheckCooldown then
							lastTargetCheck = now
							local nearbyTargets = entitylib.EntityPosition({
								Range = 50,
								Part = 'RootPart',
								Players = true
							})
							cachedTargetResult = nearbyTargets ~= nil
						end
						targetCheckPassed = cachedTargetResult
					end
					
					if not targetCheckPassed then
						return old(root, mass, dir, knockback, ...)
					end
					
					if not reduceHorizontal and not reduceVertical then
						return old(root, mass, dir, knockback, ...)
					end
					
					if knockback then
						local newKnockback = knockback
						
						if reduceHorizontal and horizValue ~= 100 then
							newKnockback = {
								horizontal = (knockback.horizontal or 1) * (horizValue / 100),
								vertical = knockback.vertical or 1
							}
							knockback = newKnockback
						end
						
						if reduceVertical and vertValue ~= 100 then
							if newKnockback == knockback then
								newKnockback = {
									horizontal = knockback.horizontal or 1,
									vertical = (knockback.vertical or 1) * (vertValue / 100)
								}
							else
								newKnockback.vertical = (knockback.vertical or 1) * (vertValue / 100)
							end
							knockback = newKnockback
						end
					else
						local horizMult = (reduceHorizontal and horizValue ~= 100) and (horizValue / 100) or 1
						local vertMult = (reduceVertical and vertValue ~= 100) and (vertValue / 100) or 1
						
						knockback = {
							horizontal = horizMult,
							vertical = vertMult
						}
					end
					
					return old(root, mass, dir, knockback, ...)
				end
			else
				bedwars.KnockbackUtil.applyKnockback = old
				lastTargetCheck = 0
				cachedTargetResult = false
			end
		end,
		Tooltip = 'Reduces knockback taken'
	})
	
	Horizontal = Velocity:CreateSlider({
		Name = 'Horizontal',
		Min = 0,
		Max = 100,
		Default = 100,
		Suffix = '%',
		Function = function(value)
			shouldCheckHorizontal = value ~= 100
		end
	})
	
	HorizontalChance = Velocity:CreateSlider({
		Name = 'Horizontal Chance',
		Min = 0,
		Max = 100,
		Default = 100,
		Suffix = '%'
	})
	
	Vertical = Velocity:CreateSlider({
		Name = 'Vertical',
		Min = 0,
		Max = 100,
		Default = 100,
		Suffix = '%',
		Function = function(value)
			shouldCheckVertical = value ~= 100
		end
	})
	
	VerticalChance = Velocity:CreateSlider({
		Name = 'Vertical Chance',
		Min = 0,
		Max = 100,
		Default = 100,
		Suffix = '%'
	})
	
	TargetCheck = Velocity:CreateToggle({
		Name = 'Only when targeting',
		Function = function(callback)
			if not callback then
				cachedTargetResult = false
				lastTargetCheck = 0
			end
		end
	})
end)
	
local AntiFallDirection
run(function()
    local AntiFall
    local Mode
    local Material
    local Color
    local rayCheck = RaycastParams.new()
    rayCheck.RespectCanCollide = true

    local math_huge = math.huge
    local tick = tick
    local task_wait = task.wait
    local vector3new = Vector3.new
    local vector3zero = Vector3.zero
    
    local cachedLowGround = math_huge
    local lastGroundScan = 0
    local groundScanInterval = 2 
    
    local function getLowGround()
        local now = tick()
        if now - lastGroundScan < groundScanInterval and cachedLowGround ~= math_huge then
            return cachedLowGround
        end
        
        lastGroundScan = now
        local mag = math_huge
        local blockStore = bedwars.BlockController:getStore()
        local allPositions = blockStore:getAllBlockPositions()
        
        for i = 1, #allPositions do
            local pos = allPositions[i] * 3
            if pos.Y < mag and not getPlacedBlock(pos + vector3new(0, 3, 0)) then
                mag = pos.Y
            end
        end
        
        cachedLowGround = mag
        return mag
    end

    AntiFall = vape.Categories.Blatant:CreateModule({
        Name = 'AntiFall',
        Function = function(callback)
            if callback then
                repeat task_wait() until store.matchState ~= 0 or (not AntiFall.Enabled)
                if not AntiFall.Enabled then return end

                local pos, debounce = getLowGround(), tick()
                if pos ~= math_huge then
                    AntiFallPart = Instance.new('Part')
                    AntiFallPart.Size = vector3new(10000, 1, 10000)
                    AntiFallPart.Transparency = 1 - Color.Opacity
                    AntiFallPart.Material = Enum.Material[Material.Value]
                    AntiFallPart.Color = Color3.fromHSV(Color.Hue, Color.Sat, Color.Value)
                    AntiFallPart.Position = vector3new(0, pos - 2, 0)
                    AntiFallPart.CanCollide = Mode.Value == 'Collide'
                    AntiFallPart.Anchored = true
                    AntiFallPart.CanQuery = false
                    AntiFallPart.Parent = workspace
                    AntiFall:Clean(AntiFallPart)
                    
                    AntiFall:Clean(AntiFallPart.Touched:Connect(function(touched)
                        if touched.Parent == lplr.Character and entitylib.isAlive and debounce < tick() then
                            debounce = tick() + 0.1
                            
                            if Mode.Value == 'Normal' then
                                local top = getNearGround()
                                if top then
                                    local lastTeleport = lplr:GetAttribute('LastTeleported')
                                    local connection
                                    local frameCounter = 0
                                    
                                    local vapeModules = vape.Modules
                                    local flyEnabled = vapeModules.Fly
                                    local infFlyEnabled = vapeModules.InfiniteFly
                                    local longJumpEnabled = vapeModules.LongJump
                                    
                                    local yMask = vector3new(1, 0, 1)
                                    local yOnly = vector3new(0, 1, 0)
                                    
                                    connection = runService.PreSimulation:Connect(function()
                                        frameCounter = frameCounter + 1
                                        
                                        if frameCounter % 5 == 0 then
                                            if flyEnabled.Enabled or infFlyEnabled.Enabled or longJumpEnabled.Enabled then
                                                connection:Disconnect()
                                                AntiFallDirection = nil
                                                return
                                            end
                                        end

                                        if entitylib.isAlive and lplr:GetAttribute('LastTeleported') == lastTeleport then
                                            local root = entitylib.character.RootPart
                                            local rootPos = root.Position
                                            local delta = (top - rootPos) * yMask
                                            
                                            AntiFallDirection = delta.Unit == delta.Unit and delta.Unit or vector3zero
                                            root.Velocity *= yMask
                                            
                                            if frameCounter % 3 == 0 then
                                                rayCheck.FilterDescendantsInstances = {gameCamera, lplr.Character}
                                                rayCheck.CollisionGroup = root.CollisionGroup

                                                local ray = workspace:Raycast(rootPos, AntiFallDirection, rayCheck)
                                                if ray then
                                                    for i = 1, 5 do
                                                        local dpos = roundPos(ray.Position + ray.Normal * 1.5) + vector3new(0, 3, 0)
                                                        if not getPlacedBlock(dpos) then
                                                            top = vector3new(top.X, pos.Y, top.Z)
                                                            break
                                                        end
                                                    end
                                                end
                                            end

                                            local yDiff = top.Y - rootPos.Y
                                            root.CFrame += vector3new(0, yDiff, 0)
                                            
                                            if not frictionTable.Speed then
                                                local speed = getSpeed()
                                                local newVelocity = (AntiFallDirection * speed) + vector3new(0, root.AssemblyLinearVelocity.Y, 0)
                                                root.AssemblyLinearVelocity = newVelocity
                                            end

                                            if delta.Magnitude < 1 then
                                                connection:Disconnect()
                                                AntiFallDirection = nil
                                            end
                                        else
                                            connection:Disconnect()
                                            AntiFallDirection = nil
                                        end
                                    end)
                                    AntiFall:Clean(connection)
                                end
                            elseif Mode.Value == 'Velocity' then
                                local rootVel = entitylib.character.RootPart.Velocity
                                entitylib.character.RootPart.Velocity = vector3new(rootVel.X, 100, rootVel.Z)
                            end
                        end
                    end))
                end
            else
                AntiFallDirection = nil
                cachedLowGround = math_huge
                lastGroundScan = 0
            end
        end,
        Tooltip = 'Help\'s you with your Parkinson\'s\nPrevents you from falling into the void.'
    })
    
    Mode = AntiFall:CreateDropdown({
        Name = 'Move Mode',
        List = {'Normal', 'Collide', 'Velocity'},
        Function = function(val)
            if AntiFallPart then
                AntiFallPart.CanCollide = val == 'Collide'
            end
        end,
        Tooltip = 'Normal - Smoothly moves you towards the nearest safe point\nVelocity - Launches you upward after touching\nCollide - Allows you to walk on the part'
    })
    
    local materials = {'ForceField'}
    for _, v in Enum.Material:GetEnumItems() do
        if v.Name ~= 'ForceField' then
            table.insert(materials, v.Name)
        end
    end
    
    Material = AntiFall:CreateDropdown({
        Name = 'Material',
        List = materials,
        Function = function(val)
            if AntiFallPart then
                AntiFallPart.Material = Enum.Material[val]
            end
        end
    })
    
    Color = AntiFall:CreateColorSlider({
        Name = 'Color',
        DefaultOpacity = 0.5,
        Function = function(h, s, v, o)
            if AntiFallPart then
                AntiFallPart.Color = Color3.fromHSV(h, s, v)
                AntiFallPart.Transparency = 1 - o
            end
        end
    })
end)
	
run(function()
    local FastBreak
    local Time
    local BedCheck
    local Blacklist
    local blocks
    local string_lower = string.lower
    local string_find = string.find
    local task_wait = task.wait
    local collectionService = game:GetService("CollectionService")
    local currentBlock = nil
    local oldHitBlock = nil
    local bedCache = {}
    local blacklistCache = {}
    local lastCacheClean = 0
    local cacheCleanInterval = 5 
    
    local function isBed(block)
        if not block then return false end
        local cached = bedCache[block]
        if cached ~= nil then return cached end
        
        local result = false
        pcall(function()
            if collectionService:HasTag(block, 'bed') or (block.Parent and collectionService:HasTag(block.Parent, 'bed')) then
                result = true
            elseif string_find(string_lower(block.Name), 'bed', 1, true) then
                result = true
            end
        end)
        
        bedCache[block] = result
        return result
    end
    
    local cachedBlacklistLower = {}
    local function updateBlacklistCache()
        if not blocks or not blocks.ListEnabled then return end
        
        cachedBlacklistLower = {}
        for _, v in pairs(blocks.ListEnabled) do
            table.insert(cachedBlacklistLower, string_lower(v))
        end
    end
    
    local function isBlacklisted(block)
        if not block or #cachedBlacklistLower == 0 then return false end
        local cached = blacklistCache[block]
        if cached ~= nil then return cached end
        
        local name = string_lower(block.Name)
        local result = false
        for i = 1, #cachedBlacklistLower do
            if string_find(name, cachedBlacklistLower[i], 1, true) then
                result = true
                break
            end
        end
        
        blacklistCache[block] = result
        return result
    end
    
    local function shouldSkip(block)
        if not block then return false end
        if BedCheck and BedCheck.Enabled and isBed(block) then return true end
        if Blacklist and Blacklist.Enabled and isBlacklisted(block) then return true end
        return false
    end
    
    local lastBreakUpdate = 0
    local breakUpdateCooldown = 0.05
    local pendingUpdate = false
    
    local function updateBreakSpeed()
        if not FastBreak or not FastBreak.Enabled then return end
        local now = tick()
        if now - lastBreakUpdate < breakUpdateCooldown then
            pendingUpdate = true
            return
        end
        lastBreakUpdate = now
        pendingUpdate = false
        
        pcall(function()
            local cooldown = (shouldSkip(currentBlock)) and 0.3 or Time.Value
            bedwars.BlockBreakController.blockBreaker:setCooldown(cooldown)
        end)
    end
    
    FastBreak = vape.Categories.Blatant:CreateModule({
        Name = 'FastBreak',
        Function = function(callback)
            if callback then
                oldHitBlock = bedwars.BlockBreaker.hitBlock
				local lastHotbarSlot = nil

				bedwars.BlockBreaker.hitBlock = function(self, maid, raycastparams, ...)
					local block = nil
					pcall(function()
						local blockInfo = self.clientManager:getBlockSelector():getMouseInfo(1, {ray = raycastparams})
						if blockInfo and blockInfo.target and blockInfo.target.blockInstance then
							block = blockInfo.target.blockInstance
						end
					end)
					
					local currentSlot = store.inventory and store.inventory.hotbarSlot
					local slotChanged = currentSlot ~= lastHotbarSlot
					if slotChanged then
						lastHotbarSlot = currentSlot
					end

					if block ~= currentBlock or slotChanged then
						currentBlock = block
						updateBreakSpeed()
					end
					return oldHitBlock and oldHitBlock(self, maid, raycastparams, ...)
				end
                
                updateBlacklistCache()
                
                task.spawn(function()
                    while FastBreak.Enabled do
                        if tick() - lastCacheClean > cacheCleanInterval then
                            lastCacheClean = tick()
                            bedCache = {}
                            blacklistCache = {}
                        end
                        if pendingUpdate then updateBreakSpeed() end
                        task_wait(0.5) 
                    end
                end)
			else
				pcall(function() bedwars.BlockBreakController.blockBreaker:setCooldown(0.3) end)
				if oldHitBlock then
					bedwars.BlockBreaker.hitBlock = oldHitBlock
					oldHitBlock = nil
				end
				currentBlock = nil
				lastHotbarSlot = nil
				bedCache, blacklistCache, cachedBlacklistLower = {}, {}, {}
			end
        end,
        Tooltip = 'Decreases block hit cooldown'
    })
    
    Time = FastBreak:CreateSlider({
        Name = 'Break speed',
        Min = 0, Max = 0.3, Default = 0.25, Decimal = 100, Suffix = 'seconds',
        Function = function() updateBreakSpeed() end
    })
    
    BedCheck = FastBreak:CreateToggle({
        Name = 'Bed Check',
        Default = false,
        Tooltip = 'Use normal break speed when breaking beds',
        Function = function() bedCache = {}; updateBreakSpeed() end
    })
    
    Blacklist = FastBreak:CreateToggle({
        Name = 'Blacklist Blocks',
        Default = false,
        Tooltip = 'Use normal break speed on blacklisted blocks',
        Function = function(v)
            if blocks then blocks.Object.Visible = v end
            blacklistCache = {}
            if v then updateBlacklistCache() end
            updateBreakSpeed()
        end
    })
    
    blocks = FastBreak:CreateTextList({
        Name = 'Blacklisted Blocks',
        Placeholder = 'bed',
        Visible = false,
        Function = function()
            updateBlacklistCache()
            blacklistCache = {}
            updateBreakSpeed()
        end
    })
end)
	
local Fly
local LongJump
run(function()
    local Value
    local VerticalValue
    local WallCheck
    local PopBalloons
    local TP
    local lastonground = false
    local MobileButtons
    local FlyAnywayProgressBar = {Enabled = false}
    local FlyAnywayProgressBarFrame
    local rayCheck = RaycastParams.new()
    rayCheck.RespectCanCollide = true
    local up, down, old = 0, 0
    local mobileControls = {}
    local groundtime = nil
    local onground = false
    local flyCooldownActive = false
    local lastGroundTouchTime = 0
    local MAX_FLY_TIME = 2.5

    local tick = tick
    local task_wait = task.wait
    local math_max = math.max
    local math_floor = math.floor
    local string_format = string.format
    local vector3new = Vector3.new
    local vector3zero = Vector3.zero
    local udim2new = UDim2.new
    local cframeLookAlong = CFrame.lookAlong
    
    local cachedBalloonCount = 0
    local lastBalloonCheck = 0
    local balloonCheckInterval = 0.2 
    
    local cachedMatchState = 0
    local lastMatchStateCheck = 0
    
    local function createMobileButton(name, position, icon)
        local button = Instance.new("TextButton")
        button.Name = name
        button.Size = udim2new(0, 60, 0, 60)
        button.Position = position
        button.BackgroundTransparency = 0.2
        button.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        button.BorderSizePixel = 0
        button.Text = icon
        button.TextScaled = true
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
        button.Font = Enum.Font.SourceSansBold
        local corner = Instance.new("UICorner")
        corner.CornerRadius = UDim.new(0, 8)
        corner.Parent = button
        return button
    end

    local function cleanupMobileControls()
        for _, control in pairs(mobileControls) do
            if control then
                control:Destroy()
            end
        end
        mobileControls = {}
    end

    local progressBarFrameCounter = 0
    local function updateProgressBar()
        if not FlyAnywayProgressBarFrame then return end
        
        if not entitylib.isAlive then
            FlyAnywayProgressBarFrame.Visible = false
            return
        end
        
        local now = tick()
        if now - lastBalloonCheck > balloonCheckInterval then
            lastBalloonCheck = now
            cachedBalloonCount = lplr.Character:GetAttribute('InflatedBalloons') or 0
            cachedMatchState = store.matchState
        end
        
        local flyAllowed = cachedBalloonCount > 0 or cachedMatchState == 2
        
        if flyAllowed then
            FlyAnywayProgressBarFrame.Frame.Size = udim2new(1, 0, 0, 20)
            FlyAnywayProgressBarFrame.TextLabel.Text = ""
            FlyAnywayProgressBarFrame.Visible = FlyAnywayProgressBar.Enabled
            return
        end
        
        progressBarFrameCounter = progressBarFrameCounter + 1
        if progressBarFrameCounter % 3 == 0 then
            local hipHeight = entitylib.character.Humanoid.HipHeight
            local checkPos = entitylib.character.HumanoidRootPart.Position + vector3new(0, (hipHeight * -2) - 1, 0)
            local newray = getPlacedBlock(checkPos)
            onground = newray ~= nil
        end
        
        if onground then
            groundtime = nil
            flyCooldownActive = false
            lastGroundTouchTime = now
            
            FlyAnywayProgressBarFrame.Frame.Size = udim2new(1, 0, 0, 20)
            FlyAnywayProgressBarFrame.TextLabel.Text = string_format("%.1fs", MAX_FLY_TIME)
            FlyAnywayProgressBarFrame.Visible = FlyAnywayProgressBar.Enabled and Fly.Enabled
            
            local tween = FlyAnywayProgressBarFrame.Frame:FindFirstChild("Tween")
            if tween then
                tween:Destroy()
            end
        else
            if not groundtime then
                groundtime = now + MAX_FLY_TIME
                flyCooldownActive = false
            end
            
            local timeLeft = math_max(0, groundtime - now)
            local progress = timeLeft / MAX_FLY_TIME
            
            FlyAnywayProgressBarFrame.Frame.Size = udim2new(progress, 0, 0, 20)
            FlyAnywayProgressBarFrame.TextLabel.Text = string_format("%.1fs", timeLeft)
            FlyAnywayProgressBarFrame.Visible = FlyAnywayProgressBar.Enabled and Fly.Enabled
            
            if timeLeft <= 0 and not flyCooldownActive then
                flyCooldownActive = true
            end
        end
        
        lastonground = onground
    end

    Fly = vape.Categories.Blatant:CreateModule({
        Name = 'Fly',
        Function = function(callback)
            frictionTable.Fly = callback or nil
            updateVelocity()
            if callback then
                up, down, old = 0, 0, bedwars.BalloonController.deflateBalloon
                bedwars.BalloonController.deflateBalloon = function() end
                local tpTick, tpToggle, oldy = tick(), true

                if lplr.Character and (lplr.Character:GetAttribute('InflatedBalloons') or 0) == 0 and getItem('balloon') then
                    bedwars.BalloonController:inflateBalloon()
                end

                Fly:Clean(vapeEvents.AttributeChanged.Event:Connect(function(changed)
                    if changed == 'InflatedBalloons' then
                        cachedBalloonCount = lplr.Character:GetAttribute('InflatedBalloons') or 0
                        if cachedBalloonCount == 0 and getItem('balloon') then
                            bedwars.BalloonController:inflateBalloon()
                        end
                    end
                end))

                task.spawn(function()
                    repeat
                        task_wait()
                        if entitylib.isAlive then
                            entitylib.groundTick = entitylib.character.Humanoid.FloorMaterial ~= Enum.Material.Air and tick() or entitylib.groundTick
                        end
                    until not Fly.Enabled
                end)

                local renderFrameCounter = 0
                Fly:Clean(runService.RenderStepped:Connect(function(delta)
                    if FlyAnywayProgressBar.Enabled and Fly.Enabled then
                        renderFrameCounter = renderFrameCounter + 1
                        if renderFrameCounter % 2 == 0 then
                            updateProgressBar()
                        end
                    end
                end))

                local preSimFrameCounter = 0
                local lastWallRaycast = 0
                local wallRaycastInterval = 0.05
                
                Fly:Clean(runService.PreSimulation:Connect(function(dt)
                    if entitylib.isAlive and not InfiniteFly.Enabled and isnetworkowner(entitylib.character.RootPart) then
                        preSimFrameCounter = preSimFrameCounter + 1
                        local now = tick()
                        
                        if preSimFrameCounter % 12 == 0 then
                            cachedBalloonCount = lplr.Character:GetAttribute('InflatedBalloons') or 0
                            cachedMatchState = store.matchState
                        end
                        
                        local flyAllowed = cachedBalloonCount > 0 or cachedMatchState == 2
                        
                        local oscillation = (now % 0.4 < 0.2) and -1 or 1
                        local mass = (1.95 + (flyAllowed and 6 or 0) * oscillation) + ((up + down) * VerticalValue.Value)
                        
                        local root = entitylib.character.RootPart
                        local moveDirection = entitylib.character.Humanoid.MoveDirection
                        local velo = getSpeed()
                        local destination = (moveDirection * math_max(Value.Value - velo, 0) * dt)
                        
                        if WallCheck.Enabled and (now - lastWallRaycast) > wallRaycastInterval then
                            lastWallRaycast = now
                            rayCheck.FilterDescendantsInstances = {lplr.Character, gameCamera, AntiVoidPart}
                            rayCheck.CollisionGroup = root.CollisionGroup
                            
                            local ray = workspace:Raycast(root.Position, destination, rayCheck)
                            if ray then
                                destination = ((ray.Position + ray.Normal) - root.Position)
                            end
                        end

                        if not flyAllowed then
                            if tpToggle then
                                local airleft = (now - entitylib.character.AirTime)
                                if airleft > 2 then
                                    if not oldy then
                                        rayCheck.FilterDescendantsInstances = {lplr.Character, gameCamera, AntiVoidPart}
                                        rayCheck.CollisionGroup = root.CollisionGroup
                                        local ray = workspace:Raycast(root.Position, vector3new(0, -1000, 0), rayCheck)
                                        if ray and TP.Enabled then
                                            tpToggle = false
                                            oldy = root.Position.Y
                                            tpTick = now + 0.11
                                            root.CFrame = cframeLookAlong(vector3new(root.Position.X, ray.Position.Y + entitylib.character.HipHeight, root.Position.Z), root.CFrame.LookVector)
                                        end
                                    end
                                end
                            else
                                if oldy then
                                    if tpTick < now then
                                        local newpos = vector3new(root.Position.X, oldy, root.Position.Z)
                                        root.CFrame = cframeLookAlong(newpos, root.CFrame.LookVector)
                                        tpToggle = true
                                        oldy = nil
                                    else
                                        mass = 0
                                    end
                                end
                            end
                        end

                        root.CFrame += destination
                        root.AssemblyLinearVelocity = (moveDirection * velo) + vector3new(0, mass, 0)
                    end
                end))

                local isMobile = inputService.TouchEnabled and not inputService.KeyboardEnabled and not inputService.MouseEnabled
                local MobileEnabled = MobileButtons.Enabled or isMobile
                if MobileEnabled then
                    local gui = Instance.new("ScreenGui")
                    gui.Name = "FlyControls"
                    gui.ResetOnSpawn = false
                    gui.Parent = lplr.PlayerGui

                    local upButton = createMobileButton("UpButton", udim2new(0.9, -70, 0.7, -140), "")
                    local downButton = createMobileButton("DownButton", udim2new(0.9, -70, 0.7, -70), "")

                    mobileControls.UpButton = upButton
                    mobileControls.DownButton = downButton
                    mobileControls.ScreenGui = gui

                    upButton.Parent = gui
                    downButton.Parent = gui

                    Fly:Clean(upButton.MouseButton1Down:Connect(function()
                        up = 1
                    end))
                    Fly:Clean(upButton.MouseButton1Up:Connect(function()
                        up = 0
                    end))
                    Fly:Clean(downButton.MouseButton1Down:Connect(function()
                        down = -1
                    end))
                    Fly:Clean(downButton.MouseButton1Up:Connect(function()
                        down = 0
                    end))
                end

                Fly:Clean(inputService.InputBegan:Connect(function(input)
                    if not inputService:GetFocusedTextBox() then
                        if input.KeyCode == Enum.KeyCode.Space or input.KeyCode == Enum.KeyCode.ButtonA then
                            up = 1
                        elseif input.KeyCode == Enum.KeyCode.LeftShift or input.KeyCode == Enum.KeyCode.ButtonL2 then
                            down = -1
                        end
                    end
                end))
                Fly:Clean(inputService.InputEnded:Connect(function(input)
                    if input.KeyCode == Enum.KeyCode.Space or input.KeyCode == Enum.KeyCode.ButtonA then
                        up = 0
                    elseif input.KeyCode == Enum.KeyCode.LeftShift or input.KeyCode == Enum.KeyCode.ButtonL2 then
                        down = 0
                    end
                end))
                if inputService.TouchEnabled then
                    pcall(function()
                        local jumpButton = lplr.PlayerGui.TouchGui.TouchControlFrame.JumpButton
                        Fly:Clean(jumpButton:GetPropertyChangedSignal('ImageRectOffset'):Connect(function()
                            if not mobileControls.UpButton then
                                up = jumpButton.ImageRectOffset.X == 146 and 1 or 0
                            end
                        end))
                    end)
                end
            else
                if FlyAnywayProgressBarFrame then
                    FlyAnywayProgressBarFrame.Visible = false
                end
                lastonground = nil
                groundtime = nil
                flyCooldownActive = false
                bedwars.BalloonController.deflateBalloon = old
                if PopBalloons.Enabled and entitylib.isAlive and (lplr.Character:GetAttribute('InflatedBalloons') or 0) > 0 then
                    for _ = 1, 3 do
                        bedwars.BalloonController:deflateBalloon()
                    end
                end
                cleanupMobileControls()
                cachedBalloonCount = 0
                lastBalloonCheck = 0
                cachedMatchState = 0
            end
        end,
        ExtraText = function()
            return 'Heatseeker'
        end,
        Tooltip = 'Makes you go zoom.'
    })
    Value = Fly:CreateSlider({
        Name = 'Speed',
        Min = 1,
        Max = 23,
        Default = 23,
        Suffix = function(val)
            return val == 1 and 'stud' or 'studs'
        end
    })
    VerticalValue = Fly:CreateSlider({
        Name = 'Vertical Speed',
        Min = 1,
        Max = 150,
        Default = 50,
        Suffix = function(val)
            return val == 1 and 'stud' or 'studs'
        end
    })
    WallCheck = Fly:CreateToggle({
        Name = 'Wall Check',
        Default = true
    })
    PopBalloons = Fly:CreateToggle({
        Name = 'Pop Balloons',
        Default = true
    })
    FlyAnywayProgressBar = Fly:CreateToggle({
        Name = "Progress Bar",
        Function = function(callback)
            if callback then
                FlyAnywayProgressBarFrame = Instance.new("Frame")
                FlyAnywayProgressBarFrame.AnchorPoint = Vector2.new(0.5, 0)
                FlyAnywayProgressBarFrame.Position = udim2new(0.5, 0, 1, -200)
                FlyAnywayProgressBarFrame.Size = udim2new(0.2, 0, 0, 20)
                FlyAnywayProgressBarFrame.BackgroundTransparency = 0.5
                FlyAnywayProgressBarFrame.BorderSizePixel = 0
                FlyAnywayProgressBarFrame.BackgroundColor3 = Color3.new(0, 0, 0)
                FlyAnywayProgressBarFrame.Visible = false
                FlyAnywayProgressBarFrame.Parent = vape.gui
                
                local FlyAnywayProgressBarFrame2 = Instance.new("Frame")
                FlyAnywayProgressBarFrame2.Name = "Frame"
                FlyAnywayProgressBarFrame2.AnchorPoint = Vector2.new(0, 0)
                FlyAnywayProgressBarFrame2.Position = udim2new(0, 0, 0, 0)
                FlyAnywayProgressBarFrame2.Size = udim2new(1, 0, 0, 20)
                FlyAnywayProgressBarFrame2.BackgroundTransparency = 0
                FlyAnywayProgressBarFrame2.BorderSizePixel = 0
                FlyAnywayProgressBarFrame2.BackgroundColor3 = Color3.fromHSV(vape.GUIColor.Hue, vape.GUIColor.Sat, vape.GUIColor.Value)
                FlyAnywayProgressBarFrame2.Visible = true
                FlyAnywayProgressBarFrame2.Parent = FlyAnywayProgressBarFrame
                
                local FlyAnywayProgressBartext = Instance.new("TextLabel")
                FlyAnywayProgressBartext.Name = "TextLabel"
                FlyAnywayProgressBartext.Text = "2.5s"
                FlyAnywayProgressBartext.Font = Enum.Font.Gotham
                FlyAnywayProgressBartext.TextStrokeTransparency = 0
                FlyAnywayProgressBartext.TextColor3 = Color3.new(0.9, 0.9, 0.9)
                FlyAnywayProgressBartext.TextSize = 20
                FlyAnywayProgressBartext.Size = udim2new(1, 0, 1, 0)
                FlyAnywayProgressBartext.BackgroundTransparency = 1
                FlyAnywayProgressBartext.Position = udim2new(0, 0, 0, 0)
                FlyAnywayProgressBartext.Parent = FlyAnywayProgressBarFrame
            else
                if FlyAnywayProgressBarFrame then 
                    FlyAnywayProgressBarFrame:Destroy() 
                    FlyAnywayProgressBarFrame = nil 
                end
            end
        end,
        Tooltip = "show amount of Fly time",
        Default = true
    })
    TP = Fly:CreateToggle({
        Name = 'TP Down',
        Default = true
    })
    MobileButtons = Fly:CreateToggle({
        Name = "Mobile Buttons",
        Function = function() 
            if Fly.Enabled then
                Fly:Toggle()
                Fly:Toggle()
            end
        end
    })
end)
	
run(function()
    local Mode
    local Expand
    local AutoToggle
    local Visible
    local VisibleColor
    local NPCs
    local objects, set = {}, {}
    local lastHoldingSword = false
    local autoToggleConnection = nil
    local manuallyDisabled = false
    
    local tick = tick
    local task_wait = task.wait
    local vector3new = Vector3.new
    local vector3one = Vector3.one
    
    local colorList = {
        Red = Color3.fromRGB(255, 0, 0),
        Blue = Color3.fromRGB(0, 100, 255),
        Green = Color3.fromRGB(0, 255, 0),
        Yellow = Color3.fromRGB(255, 255, 0),
        Orange = Color3.fromRGB(255, 140, 0),
        Purple = Color3.fromRGB(180, 0, 255),
        White = Color3.fromRGB(255, 255, 255),
        Cyan = Color3.fromRGB(0, 255, 255),
        Pink = Color3.fromRGB(255, 50, 150),
        Black = Color3.fromRGB(0, 0, 0)
    }
    
    local function shouldCreateHitbox(ent)
        if not ent.Targetable then return false end
        if ent.Player then return true end
        if NPCs and NPCs.Enabled and not ent.Player then return true end
        return false
    end
    
    local cachedExpandSize = vector3new(3, 6, 3)
    local lastExpandValue = 0
    local function updateExpandSize(val)
        if val ~= lastExpandValue then
            lastExpandValue = val
            cachedExpandSize = vector3new(3, 6, 3) + vector3one * (val / 5)
        end
    end
    
    local function createHitbox(ent)
        if shouldCreateHitbox(ent) then
            local hitbox = Instance.new('Part')
            hitbox.Size = cachedExpandSize
            hitbox.Position = ent.RootPart.Position
            hitbox.CanCollide = false
            hitbox.Massless = true
            hitbox.Transparency = Visible and Visible.Enabled and 0.5 or 1
            if Visible and Visible.Enabled and VisibleColor then
                hitbox.Color = colorList[VisibleColor.Value] or colorList.Red
            end
            hitbox.Parent = ent.Character
            local weld = Instance.new('Motor6D')
            weld.Part0 = hitbox
            weld.Part1 = ent.RootPart
            weld.Parent = hitbox
            objects[ent] = hitbox
        end
    end
    
    local lastToolCheck = 0
    local cachedIsSword = false
    local lastToolName = nil
    local function isSword()
        if not store.hand or not store.hand.tool then 
            cachedIsSword = false
            lastToolName = nil
            return false 
        end
        
        local currentTool = store.hand.tool
        if currentTool.Name == lastToolName then
            return cachedIsSword
        end
        
        lastToolName = currentTool.Name
        cachedIsSword = store.hand.toolType == 'sword'
        return cachedIsSword
    end
    
    local lastAutoToggleTime = 0
    local autoToggleCooldown = 0.1
    local function handleAutoToggle()
        if not AutoToggle.Enabled or Mode.Value ~= 'Player' then return end
        
        local now = tick()
        if now - lastAutoToggleTime < autoToggleCooldown then
            return
        end
        
        local holdingSword = isSword()
        
        if holdingSword ~= lastHoldingSword then
            lastHoldingSword = holdingSword
            lastAutoToggleTime = now
            
            if holdingSword then
                if not HitBoxes.Enabled and not manuallyDisabled then
                    HitBoxes:Toggle()
                end
            else
                if HitBoxes.Enabled then
                    manuallyDisabled = false
                    HitBoxes:Toggle()
                end
            end
        end
    end
    
    local function refreshAllHitboxes()
        for ent, part in pairs(objects) do
            part:Destroy()
        end
        table.clear(objects)
        
        local entityList = entitylib.List
        for i = 1, #entityList do
            createHitbox(entityList[i])
        end
    end
    
    HitBoxes = vape.Categories.Blatant:CreateModule({
        Name = 'HitBoxes',
        Function = function(callback)
            if callback then
                manuallyDisabled = false
                updateExpandSize(Expand.Value)
                
                if Mode.Value == 'Sword' then
                    debug.setconstant(bedwars.SwordController.swingSwordInRegion, 6, (Expand.Value / 3))
                    set = true
                else
                    HitBoxes:Clean(entitylib.Events.EntityAdded:Connect(createHitbox))
                    HitBoxes:Clean(entitylib.Events.EntityRemoving:Connect(function(ent)
                        local obj = objects[ent]
                        if obj then
                            obj:Destroy()
                            objects[ent] = nil
                        end
                    end))
                    
                    local entityList = entitylib.List
                    for i = 1, #entityList do
                        createHitbox(entityList[i])
                    end
                end
            else
                if AutoToggle.Enabled and isSword() then
                    manuallyDisabled = true
                end
                
                if set then
                    debug.setconstant(bedwars.SwordController.swingSwordInRegion, 6, 3.8)
                    set = nil
                end
                
                for _, part in pairs(objects) do
                    part:Destroy()
                end
                table.clear(objects)
                
                if not AutoToggle.Enabled then
                    lastHoldingSword = false
                    lastToolName = nil
                end
            end
        end,
        Tooltip = 'Expands attack hitbox'
    })
    
    Mode = HitBoxes:CreateDropdown({
        Name = 'Mode',
        List = {'Sword', 'Player'},
        Function = function(val)
            local isPlayer = val == 'Player'
            if AutoToggle then
                AutoToggle.Object.Visible = isPlayer
            end
            if Visible then
                Visible.Object.Visible = isPlayer
            end
            if VisibleColor then
                VisibleColor.Object.Visible = isPlayer and Visible.Enabled
            end
            if NPCs then
                NPCs.Object.Visible = isPlayer
            end
            if HitBoxes.Enabled then
                HitBoxes:Toggle()
                HitBoxes:Toggle()
            end
        end,
        Tooltip = 'Sword - Increases the range around you to hit entities\nPlayer - Increases the players hitbox'
    })
    
    Expand = HitBoxes:CreateSlider({
        Name = 'Expand amount',
        Min = 0,
        Max = 14.4,
        Default = 14.4,
        Decimal = 10,
        Function = function(val)
            updateExpandSize(val)
            
            if HitBoxes.Enabled then
                if Mode.Value == 'Sword' then
                    debug.setconstant(bedwars.SwordController.swingSwordInRegion, 6, (val / 3))
                else
                    for _, part in pairs(objects) do
                        part.Size = cachedExpandSize
                    end
                end
            end
        end,
        Suffix = function(val)
            return val == 1 and 'stud' or 'studs'
        end
    })
    
    local autoToggleFrameCounter = 0
    AutoToggle = HitBoxes:CreateToggle({
        Name = 'Auto Toggle',
        Default = false,
        Visible = false,
        Tooltip = 'Automatically enables hitbox when holding a sword',
        Function = function(callback)
            if callback then
                if autoToggleConnection then
                    autoToggleConnection:Disconnect()
                end
                lastHoldingSword = false
                autoToggleFrameCounter = 0
                
                autoToggleConnection = runService.Heartbeat:Connect(function()
                    autoToggleFrameCounter = autoToggleFrameCounter + 1
                    if autoToggleFrameCounter % 5 == 0 then
                        handleAutoToggle()
                    end
                end)
                handleAutoToggle()
            else
                if autoToggleConnection then
                    autoToggleConnection:Disconnect()
                    autoToggleConnection = nil
                end
                lastHoldingSword = false
                lastToolName = nil
            end
        end
    })
    
    Visible = HitBoxes:CreateToggle({
        Name = 'Visible',
        Default = false,
        Visible = false,
        Tooltip = 'Makes the hitbox visible on screen',
        Function = function(callback)
            if VisibleColor then
                VisibleColor.Object.Visible = callback
            end
            if HitBoxes.Enabled and Mode.Value == 'Player' then
                local transparency = callback and 0.5 or 1
                local color = callback and VisibleColor and (colorList[VisibleColor.Value] or colorList.Red) or nil
                
                for _, part in pairs(objects) do
                    part.Transparency = transparency
                    if color then
                        part.Color = color
                    end
                end
            end
        end
    })
    
    VisibleColor = HitBoxes:CreateDropdown({
        Name = 'Hitbox Color',
        List = {'Red', 'Blue', 'Green', 'Yellow', 'Orange', 'Purple', 'White', 'Cyan', 'Pink', 'Black'},
        Default = 'Red',
        Visible = false,
        Tooltip = 'Color of the visible hitbox',
        Function = function(val)
            if HitBoxes.Enabled and Mode.Value == 'Player' and Visible.Enabled then
                local color = colorList[val] or colorList.Red
                for _, part in pairs(objects) do
                    part.Color = color
                end
            end
        end
    })
    
    NPCs = HitBoxes:CreateToggle({
        Name = 'NPCs',
        Default = false,
        Visible = false,
        Tooltip = 'Also applies hitbox to NPCs',
        Function = function(callback)
            if HitBoxes.Enabled and Mode.Value == 'Player' then
                refreshAllHitboxes()
            end
        end
    })
    
    task.spawn(function()
        repeat task_wait() until Mode.Value
        local isPlayer = Mode.Value == 'Player'
        AutoToggle.Object.Visible = isPlayer
        Visible.Object.Visible = isPlayer
        NPCs.Object.Visible = isPlayer
    end)
end)
	
run(function()
	vape.Categories.Blatant:CreateModule({
		Name = 'KeepSprint',
		Function = function(callback)
			debug.setconstant(bedwars.SprintController.startSprinting, 5, callback and 'blockSprinting' or 'blockSprint')
			bedwars.SprintController:stopSprinting()
		end,
		Tooltip = 'Lets you sprint with a speed potion.'
	})
end)

-- aero killaura 
local Attacking
run(function()
    local Killaura
    local Targets
    local Sort
    local SwingRange
    local AttackRange
    local RangeCircle
    local RangeCirclePart
    local UpdateRate
    local AngleSlider
    local MaxTargets
    local Mouse
    local Swing
    local GUI
    local BoxSwingColor
    local BoxAttackColor
    local ParticleTexture
    local ParticleColor1
    local ParticleColor2
    local ParticleSize
    local Face
    local Animation
    local AnimationMode
    local AnimationSpeed
    local AnimationTween
    local Limit
    local LegitAura
    local SyncHits
    local lastAttackTime = 0
    local lastManualSwing = 0
    local lastSwingServerTime = 0
    local lastSwingServerTimeDelta = 0
    local SophiaCheck
    local FROZEN_THRESHOLD = 10
    local SwingTime
    local SwingTimeSlider
    local swingCooldown = 0
    local ContinueSwinging
    local ContinueSwingTime
    local lastTargetTime = 0
    local continueSwingCount = 0
    local Particles, Boxes = {}, {}
    local anims, AnimDelay, AnimTween, armC0 = vape.Libraries.auraanims, tick()
    local AttackRemote
    local TargetPriority
    local CustomHitReg
    local CustomHitRegSlider
    local lastCustomHitTime = 0
    local AirHit
    local AirHitsChance
    local CanHit = true
    
    task.spawn(function()
        AttackRemote = bedwars.Client:Get(remotes.AttackEntity)
    end)

    local function isFrozen()
        if not entitylib.isAlive then return false end
        local char = entitylib.character.Character
        if char:GetAttribute("StatusEffect_frozen") then
            return true
        end
        local hasIceBlock = char:FindFirstChild("IceBlock") or 
                        char:FindFirstChild("FrozenBlock") or 
                        char:FindFirstChild("IceShell")
        
        if hasIceBlock then
            return true
        end
        return false
    end

    local function optimizeHitData(selfpos, targetpos, delta)
        local direction = (targetpos - selfpos).Unit
        local distance = (selfpos - targetpos).Magnitude
        local optimizedSelfPos = selfpos
        local optimizedTargetPos = targetpos
        if distance > 18 then
            optimizedSelfPos = selfpos + (direction * 2.2)
            optimizedTargetPos = targetpos - (direction * 0.5)
        elseif distance > 14.4 then
            optimizedSelfPos = selfpos + (direction * 1.8)
            optimizedTargetPos = targetpos - (direction * 0.3)
        elseif distance > 10 then
            optimizedSelfPos = selfpos + (direction * 1.2)
        else
            optimizedSelfPos = selfpos + (direction * 0.6)
        end
        optimizedSelfPos = optimizedSelfPos + Vector3.new(0, 0.8, 0)
        optimizedTargetPos = optimizedTargetPos + Vector3.new(0, 1.2, 0)
        return optimizedSelfPos, optimizedTargetPos, direction
    end

    local function getOptimizedAttackTiming()
        local currentTime = tick()
        local baseDelay = 0.11 
        
        if currentTime - lastAttackTime < baseDelay then
            return false
        end
        
        return true
    end

	local function canHitWithCustomReg()
		if not CustomHitReg.Enabled then return true end
		
		local currentTime = tick()
		local targetHitsIn10Sec = CustomHitRegSlider.Value
		
		if targetHitsIn10Sec >= 35 and targetHitsIn10Sec <= 36 then
			return true
		end
		
		local delayBetweenHits = (10 / targetHitsIn10Sec) * 0.98
		
		if currentTime - lastCustomHitTime >= delayBetweenHits then
			lastCustomHitTime = currentTime
			return true
		end
		
		return false
	end

    local function FireAttackRemote(attackTable, ...)
        if not AttackRemote then return end
        if not canHitWithCustomReg() then return end

        local suc, plr = pcall(function()
            return playersService:GetPlayerFromCharacter(attackTable.entityInstance)
        end)

        local selfpos = attackTable.validate.selfPosition.value
        local targetpos = attackTable.validate.targetPosition.value
        local actualDistance = (selfpos - targetpos).Magnitude

        store.attackReach = (actualDistance * 100) // 1 / 100
        store.attackReachUpdate = tick() + 1

        if actualDistance > 14.4 and actualDistance <= 30 then
            local direction = (targetpos - selfpos).Unit
            
            local moveDistance = math.min(actualDistance - 14.3, 8) 
            attackTable.validate.selfPosition.value = selfpos + (direction * moveDistance)
            
            local pullDistance = math.min(actualDistance - 14.3, 4)
            attackTable.validate.targetPosition.value = targetpos - (direction * pullDistance)
            
            attackTable.validate.raycast = attackTable.validate.raycast or {}
            attackTable.validate.raycast.cameraPosition = attackTable.validate.raycast.cameraPosition or {}
            attackTable.validate.raycast.cursorDirection = attackTable.validate.raycast.cursorDirection or {}
            
            local extendedOrigin = selfpos + (direction * math.min(actualDistance - 12, 15))
            attackTable.validate.raycast.cameraPosition.value = extendedOrigin
            attackTable.validate.raycast.cursorDirection.value = direction
            
            attackTable.validate.targetPosition = attackTable.validate.targetPosition or {value = targetpos}
            attackTable.validate.selfPosition = attackTable.validate.selfPosition or {value = selfpos}
        end

        if suc and plr then
            if not select(2, whitelist:get(plr)) then return end
        end

        return AttackRemote:SendToServer(attackTable, ...)
    end

    local lastSwingServerTime = 0
    local lastSwingServerTimeDelta = 0

    local function createRangeCircle()
        local suc, err = pcall(function()
            if (not shared.CheatEngineMode) then
                RangeCirclePart = Instance.new("MeshPart")
                RangeCirclePart.MeshId = "rbxassetid://3726303797"
                if shared.RiseMode and GuiLibrary.GUICoreColor and GuiLibrary.GUICoreColorChanged then
                    RangeCirclePart.Color = GuiLibrary.GUICoreColor
                    GuiLibrary.GUICoreColorChanged.Event:Connect(function()
                        RangeCirclePart.Color = GuiLibrary.GUICoreColor
                    end)
                else
                    RangeCirclePart.Color = Color3.fromHSV(BoxSwingColor["Hue"], BoxSwingColor["Sat"], BoxSwingColor.Value)
                end
                RangeCirclePart.CanCollide = false
                RangeCirclePart.Anchored = true
                RangeCirclePart.Material = Enum.Material.Neon
                RangeCirclePart.Size = Vector3.new(SwingRange.Value * 0.7, 0.01, SwingRange.Value * 0.7)
                if Killaura.Enabled then
                    RangeCirclePart.Parent = gameCamera
                end
                RangeCirclePart:SetAttribute("gamecore_GameQueryIgnore", true)
            end
        end)
        if (not suc) then
            pcall(function()
                if RangeCirclePart then
                    RangeCirclePart:Destroy()
                    RangeCirclePart = nil
                end
                notif("Killaura - Range Visualiser Circle", "There was an error creating the circle. Disabling...", 2)
            end)
        end
    end

    local function getAttackData()
        if SophiaCheck and SophiaCheck.Enabled then
            if isFrozen() then
                return false
            end
        end

        if Mouse.Enabled then
            local mousePressed = inputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
            if not mousePressed then 
                return false 
            end
        end

        if GUI.Enabled then
            if bedwars.AppController:isLayerOpen(bedwars.UILayers.MAIN) then return false end
        end

        local sword = Limit.Enabled and store.hand or store.tools.sword
        if not sword or not sword.tool then return false end

        local meta = bedwars.ItemMeta[sword.tool.Name]
        if Limit.Enabled then
            if store.hand.toolType ~= 'sword' or bedwars.DaoController.chargingMaid then return false end
        end

        if LegitAura.Enabled then
            if (tick() - bedwars.SwordController.lastSwing) > 0.2 then return false end
        end

        if SwingTime.Enabled then
            local swingSpeed = SwingTimeSlider.Value
            return sword, meta, (tick() - lastAttackTime) >= swingSpeed
        else
            return sword, meta, true
        end
    end
    
    local function resetSwordCooldown()
        if bedwars.SwordController then
            bedwars.SwordController.lastAttack = 0
            bedwars.SwordController.lastSwing = 0
            
            if bedwars.SwordController.lastChargedAttackTimeMap then
                for weaponName, _ in pairs(bedwars.SwordController.lastChargedAttackTimeMap) do
                    bedwars.SwordController.lastChargedAttackTimeMap[weaponName] = 0
                end
            end
        end
    end

    local function shouldContinueSwinging()
        if not ContinueSwinging.Enabled then return false end
        
        if lastTargetTime == 0 then
            return false
        end
        
        local timeSinceLastTarget = tick() - lastTargetTime
        local swingDuration = ContinueSwingTime.Value
        
        if timeSinceLastTarget <= swingDuration then
            return true
        end
        
        return false
    end

    local preserveSwordIcon = false
    local sigridcheck = false

    Killaura = vape.Categories.Blatant:CreateModule({
        Name = 'Killaura',
        Function = function(callback)
            
            if callback then
                
                lastSwingServerTime = Workspace:GetServerTimeNow()
                lastSwingServerTimeDelta = 0
                lastAttackTime = 0
                swingCooldown = 0
                resetSwordCooldown() 
                lastTargetTime = 0 
                continueSwingCount = 0

                if RangeCircle.Enabled then
                    createRangeCircle()
                end
                if inputService.TouchEnabled and not preserveSwordIcon then
                    pcall(function()
                        lplr.PlayerGui.MobileUI['2'].Visible = Limit.Enabled
                    end)
                end

                if Animation.Enabled and not (identifyexecutor and table.find({'Argon', 'Delta'}, ({identifyexecutor()})[1])) then
                    local fake = {
                        Controllers = {
                            ViewmodelController = {
                                isVisible = function()
                                    return not Attacking
                                end,
                                playAnimation = function(...)
                                    local args = {...}
                                    if not Attacking then
                                        pcall(function()
                                            bedwars.ViewmodelController:playAnimation(select(2, unpack(args)))
                                        end)
                                    end
                                end
                            }
                        }
                    }

                    task.spawn(function()
                        local started = false
                        repeat
                            if Attacking then
                                if not armC0 then
                                    armC0 = gameCamera.Viewmodel.RightHand.RightWrist.C0
                                end
                                local first = not started
                                started = true

                                if AnimationMode.Value == 'Random' then
                                    anims.Random = {{CFrame = CFrame.Angles(math.rad(math.random(1, 360)), math.rad(math.random(1, 360)), math.rad(math.random(1, 360))), Time = 0.12}}
                                end

                                for _, v in anims[AnimationMode.Value] do
                                    AnimTween = tweenService:Create(gameCamera.Viewmodel.RightHand.RightWrist, TweenInfo.new(first and (AnimationTween.Enabled and 0.001 or 0.1) or v.Time / AnimationSpeed.Value, Enum.EasingStyle.Linear), {
                                        C0 = armC0 * v.CFrame
                                    })
                                    AnimTween:Play()
                                    AnimTween.Completed:Wait()
                                    first = false
                                    if (not Killaura.Enabled) or (not Attacking) then break end
                                end
                            elseif started then
                                started = false
                                AnimTween = tweenService:Create(gameCamera.Viewmodel.RightHand.RightWrist, TweenInfo.new(AnimationTween.Enabled and 0.001 or 0.3, Enum.EasingStyle.Exponential), {
                                    C0 = armC0
                                })
                                AnimTween:Play()
                            end

                            if not started then
                                task.wait(1 / UpdateRate.Value)
                            end
                        until (not Killaura.Enabled) or (not Animation.Enabled)
                    end)
                end

                repeat
                    if SophiaCheck and SophiaCheck.Enabled then
                        if isFrozen() then
                            Attacking = false
                            store.KillauraTarget = nil
                            task.wait(0.3)
                            continue
                        end
                    end
                    
                    pcall(function()
                        if entitylib.isAlive and entitylib.character.HumanoidRootPart then
                            TweenService:Create(RangeCirclePart, TweenInfo.new(0.2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Position = entitylib.character.HumanoidRootPart.Position - Vector3.new(0, entitylib.character.Humanoid.HipHeight, 0)}):Play()
                        end
                    end)

                    local attacked, sword, meta, canAttack = {}, getAttackData()
                    Attacking = false
                    store.KillauraTarget = nil
                    pcall(function() vapeTargetInfo.Targets.Killaura = nil end)

                    if sword and canAttack then
                        if sigridcheck and entitylib.isAlive and lplr.Character:FindFirstChild("elk") then return end
                        local isClaw = string.find(string.lower(tostring(sword and sword.itemType or "")), "summoner_claw")
                        
                        local selfpos = entitylib.character.RootPart.Position
                        local localfacing = entitylib.character.RootPart.CFrame.LookVector * Vector3.new(1, 0, 1)
                        local maxAngle = math.rad(AngleSlider.Value) / 2
                        local allSwingTargets = {}
                        local allAttackTargets = {}

                        if Targets.Players.Enabled then
                            local playerTargets = entitylib.AllPosition({
                                Range = SwingRange.Value,
                                Wallcheck = false,
                                Part = 'RootPart',
                                Players = true,
                                NPCs = false,
                                Limit = MaxTargets.Value,
                                Sort = sortmethods[Sort.Value]
                            })
                            for _, v in playerTargets do
                                table.insert(allSwingTargets, {entity = v, isPlayer = true})
                            end
                        end

                        if Targets.NPCs.Enabled then
                            local npcTargets = entitylib.AllPosition({
                                Range = SwingRange.Value,
                                Wallcheck = false,
                                Part = 'RootPart',
                                Players = false,
                                NPCs = true,
                                Limit = MaxTargets.Value,
                                Sort = sortmethods[Sort.Value]
                            })
                            for _, v in npcTargets do
                                table.insert(allSwingTargets, {entity = v, isPlayer = false})
                            end
                        end

                        if TargetPriority.Value == 'Players First' then
                            table.sort(allSwingTargets, function(a, b)
                                if a.isPlayer ~= b.isPlayer then
                                    return a.isPlayer
                                end
                                return (a.entity.RootPart.Position - selfpos).Magnitude < (b.entity.RootPart.Position - selfpos).Magnitude
                            end)
                        elseif TargetPriority.Value == 'NPCs First' then
                            table.sort(allSwingTargets, function(a, b)
                                if a.isPlayer ~= b.isPlayer then
                                    return not a.isPlayer
                                end
                                return (a.entity.RootPart.Position - selfpos).Magnitude < (b.entity.RootPart.Position - selfpos).Magnitude
                            end)
                        else
                            table.sort(allSwingTargets, function(a, b)
                                return (a.entity.RootPart.Position - selfpos).Magnitude < (b.entity.RootPart.Position - selfpos).Magnitude
                            end)
                        end

                        local swingPlrs = {}
                        for i = 1, math.min(#allSwingTargets, MaxTargets.Value) do
                            table.insert(swingPlrs, allSwingTargets[i].entity)
                        end

                        if Targets.Players.Enabled then
                            local playerTargets = entitylib.AllPosition({
                                Range = SwingRange.Value,
                                Wallcheck = Targets.Walls.Enabled or nil,
                                Part = 'RootPart',
                                Players = true,
                                NPCs = false,
                                Limit = MaxTargets.Value,
                                Sort = sortmethods[Sort.Value]
                            })
                            for _, v in playerTargets do
                                table.insert(allAttackTargets, {entity = v, isPlayer = true})
                            end
                        end

                        if Targets.NPCs.Enabled then
                            local npcTargets = entitylib.AllPosition({
                                Range = SwingRange.Value,
                                Wallcheck = Targets.Walls.Enabled or nil,
                                Part = 'RootPart',
                                Players = false,
                                NPCs = true,
                                Limit = MaxTargets.Value,
                                Sort = sortmethods[Sort.Value]
                            })
                            for _, v in npcTargets do
                                table.insert(allAttackTargets, {entity = v, isPlayer = false})
                            end
                        end

                        if TargetPriority.Value == 'Players First' then
                            table.sort(allAttackTargets, function(a, b)
                                if a.isPlayer ~= b.isPlayer then
                                    return a.isPlayer
                                end
                                return (a.entity.RootPart.Position - selfpos).Magnitude < (b.entity.RootPart.Position - selfpos).Magnitude
                            end)
                        elseif TargetPriority.Value == 'NPCs First' then
                            table.sort(allAttackTargets, function(a, b)
                                if a.isPlayer ~= b.isPlayer then
                                    return not a.isPlayer
                                end
                                return (a.entity.RootPart.Position - selfpos).Magnitude < (b.entity.RootPart.Position - selfpos).Magnitude
                            end)
                        else
                            table.sort(allAttackTargets, function(a, b)
                                return (a.entity.RootPart.Position - selfpos).Magnitude < (b.entity.RootPart.Position - selfpos).Magnitude
                            end)
                        end

                        local attackPlrs = {}
                        for i = 1, math.min(#allAttackTargets, MaxTargets.Value) do
                            table.insert(attackPlrs, allAttackTargets[i].entity)
                        end
                        
                        local hasValidSwingTargets = false
                        local hasValidAttackTargets = false
                        
                        for _, v in swingPlrs do
                            local delta = (v.RootPart.Position - selfpos)
                            local angle = math.acos(localfacing:Dot((delta * Vector3.new(1, 0, 1)).Unit))
                            if angle <= maxAngle then
                                hasValidSwingTargets = true
                                break
                            end
                        end
                        
                        for _, v in attackPlrs do
                            local delta = (v.RootPart.Position - selfpos)
                            local angle = math.acos(localfacing:Dot((delta * Vector3.new(1, 0, 1)).Unit))
                            if angle <= maxAngle then  
                                hasValidAttackTargets = true
                                break
                            end
                        end
                        
                        if hasValidSwingTargets or hasValidAttackTargets then
                            lastTargetTime = tick()
                        end
                        
                        local shouldSwing = hasValidSwingTargets or hasValidAttackTargets or shouldContinueSwinging()
                        
                        if shouldSwing then
                            switchItem(sword.tool, 0)
                            
                            if hasValidAttackTargets then
                                for _, v in attackPlrs do
                                    local delta = (v.RootPart.Position - selfpos)
                                    local angle = math.acos(localfacing:Dot((delta * Vector3.new(1, 0, 1)).Unit))
                                    local swingAngle = math.rad(AngleSlider.Value)
                                    if angle > (swingAngle / 2) then continue end

                                    table.insert(attacked, {
                                        Entity = v,
                                        Check = delta.Magnitude > AttackRange.Value and BoxSwingColor or BoxAttackColor
                                    })
                                    targetinfo.Targets[v] = tick() + 1
                                    pcall(function()
                                        local plr = v
                                        vapeTargetInfo.Targets.Killaura = {
                                            Humanoid = {
                                                Health = (plr.Character:GetAttribute("Health") or plr.Humanoid.Health) + getShieldAttribute(plr.Character),
                                                MaxHealth = plr.Character:GetAttribute("MaxHealth") or plr.Humanoid.MaxHealth
                                            },
                                            Player = plr.Player
                                        }
                                    end)
                                    if not Attacking then
                                        Attacking = true
                                        store.KillauraTarget = v
                                        if not isClaw then
                                            if not Swing.Enabled and AnimDelay <= tick() and not LegitAura.Enabled then
                                                local swingSpeed = 0.25
                                                if SwingTime.Enabled then
                                                    swingSpeed = math.max(SwingTimeSlider.Value, 0.11)
                                                elseif meta.sword.respectAttackSpeedForEffects then
                                                    swingSpeed = meta.sword.attackSpeed
                                                end
                                                AnimDelay = tick() + swingSpeed
                                                bedwars.SwordController:playSwordEffect(meta, false)
                                                if meta.displayName:find(' Scythe') then
                                                    bedwars.ScytheController:playLocalAnimation()
                                                end

												if vape.ThreadFix then
													setthreadidentity(8)
													task.defer(function()
														setthreadidentity(2)
													end)
												end
                                            end
                                        end
                                    end

									local canHit = delta.Magnitude <= AttackRange.Value
									local extendedRangeCheck = delta.Magnitude <= (AttackRange.Value + 2) 

									if not canHit and not extendedRangeCheck then continue end

                                    if AirHit.Enabled then
                                        local chance = math.random(0, 100)
                                        local state = v.Character.Humanoid:GetState()
                                        if state == Enum.HumanoidStateType.Jumping then
                                            if chance > AirHitsChance.Value then 
                                                CanHit = false
                                                continue
                                            else
                                                CanHit = true
                                            end
                                        elseif state == Enum.HumanoidStateType.Freefall then
                                            if chance > AirHitsChance.Value then
                                                CanHit = false 
                                                continue 
                                            else
                                                CanHit = true
                                            end
                                        else
                                            CanHit = true
                                        end
                                    else
                                        CanHit = true
                                    end

                                    if not CanHit then continue end

                                    if SyncHits.Enabled then
                                        local swingSpeed = SwingTime.Enabled and SwingTimeSlider.Value or (meta.sword.respectAttackSpeedForEffects and meta.sword.attackSpeed or 0.42)
                                        if (tick() - swingCooldown) < (swingSpeed * 0.7) then 
                                            continue 
                                        end
                                     local timeSinceLastSwing = tick() - swingCooldown
                                        local requiredDelay = math.max(swingSpeed * 0.8, 0.1) 
                                        
                                        if timeSinceLastSwing < requiredDelay then 
                                            continue 
                                        end
                                    end

                                    local actualRoot = v.Character.PrimaryPart
                                    if actualRoot then
                                        local dir = CFrame.lookAt(selfpos, actualRoot.Position).LookVector

                                        local pos = selfpos
                                        local targetPos = actualRoot.Position

                                        if not SyncHits.Enabled or (tick() - swingCooldown) >= 0.1 then
                                            swingCooldown = tick()
                                        end
                                        lastSwingServerTimeDelta = workspace:GetServerTimeNow() - lastSwingServerTime
                                        lastSwingServerTime = workspace:GetServerTimeNow()

                                        store.attackReach = (delta.Magnitude * 100) // 1 / 100
                                        store.attackReachUpdate = tick() + 1

                                        if SwingTime.Enabled then
                                            lastAttackTime = tick()

                                            if delta.Magnitude < 14.4 and SwingTimeSlider.Value > 0.11 then
                                                AnimDelay = tick()
                                            end
                                        end

                                        if isClaw then
                                            KaidaController:request(v.Character)
                                        else
                                            local attackData = {
                                                weapon = sword.tool,
                                                entityInstance = v.Character,
                                                chargedAttack = {chargeRatio = 0},
                                                validate = {
                                                    raycast = {
                                                        cameraPosition = {value = pos + Vector3.new(0, 2, 0)},
                                                        cursorDirection = {value = dir}
                                                    },
                                                    targetPosition = {value = targetPos},
                                                    selfPosition = {value = pos + Vector3.new(0, 1, 0)}
                                                }
                                            }
                                            
                                            attackData.validate = attackData.validate or {}
                                            attackData.validate.raycast = attackData.validate.raycast or {}
                                            attackData.validate.targetPosition = attackData.validate.targetPosition or {value = targetPos}
                                            attackData.validate.selfPosition = attackData.validate.selfPosition or {value = pos}
                                            
                                            attackData.validate.raycast.cameraPosition = attackData.validate.raycast.cameraPosition or {value = pos}
                                            attackData.validate.raycast.cursorDirection = attackData.validate.raycast.cursorDirection or {value = dir}
                                            
                                            FireAttackRemote(attackData)
                                        end
                                    end
                                end
                            else
                                Attacking = true
                                if not isClaw then
                                    if not Swing.Enabled and AnimDelay <= tick() and not LegitAura.Enabled then
                                        local swingSpeed = 0.25
                                        if SwingTime.Enabled then
                                            swingSpeed = math.max(SwingTimeSlider.Value, 0.11)
                                        elseif meta.sword.respectAttackSpeedForEffects then
                                            swingSpeed = meta.sword.attackSpeed
                                        end
                                        AnimDelay = tick() + swingSpeed
                                        bedwars.SwordController:playSwordEffect(meta, false)
                                        if meta.displayName:find(' Scythe') then
                                            bedwars.ScytheController:playLocalAnimation()
                                        end

										if vape.ThreadFix then
											setthreadidentity(8)
											task.defer(function()
												setthreadidentity(2)
											end)
										end
                                    end
                                end

                                local currentSwingSpeed = SwingTime.Enabled and SwingTimeSlider.Value or (meta.sword.respectAttackSpeedForEffects and meta.sword.attackSpeed or 0.42)
                                local minSwingDelay = math.max(currentSwingSpeed, 0.05)
                                
                                if not SyncHits.Enabled or (tick() - swingCooldown) >= minSwingDelay then
                                    swingCooldown = tick()
                                end
                            end
                        end
                    end

                    pcall(function()
                        for i, v in Boxes do
                            v.Adornee = attacked[i] and attacked[i].Entity.RootPart or nil
                            if v.Adornee then
                                v.Color3 = Color3.fromHSV(attacked[i].Check.Hue, attacked[i].Check.Sat, attacked[i].Check.Value)
                                v.Transparency = 1 - attacked[i].Check.Opacity
                            end
                        end

                        for i, v in Particles do
                            v.Position = attacked[i] and attacked[i].Entity.RootPart.Position or Vector3.new(9e9, 9e9, 9e9)
                            v.Parent = attacked[i] and gameCamera or nil
                        end
                    end)

                    if Face.Enabled and attacked[1] then
                        local vec = attacked[1].Entity.RootPart.Position * Vector3.new(1, 0, 1)
                        entitylib.character.RootPart.CFrame = CFrame.lookAt(entitylib.character.RootPart.Position, Vector3.new(vec.X, entitylib.character.RootPart.Position.Y + 0.001, vec.Z))
                    end
                    pcall(function() if RangeCirclePart ~= nil then RangeCirclePart.Parent = gameCamera end end)

                    task.wait(1 / UpdateRate.Value)
                until not Killaura.Enabled
            else
                
                lastTargetTime = 0
                continueSwingCount = 0
                
                store.KillauraTarget = nil
                for _, v in Boxes do
                    v.Adornee = nil
                end
                for _, v in Particles do
                    v.Parent = nil
                end
                if inputService.TouchEnabled then
                    pcall(function()
                        lplr.PlayerGui.MobileUI['2'].Visible = true
                    end)
                end
                Attacking = false
				pcall(function()
					setthreadidentity(2)
				end)
                if armC0 then
                    AnimTween = tweenService:Create(gameCamera.Viewmodel.RightHand.RightWrist, TweenInfo.new(AnimationTween.Enabled and 0.001 or 0.3, Enum.EasingStyle.Exponential), {
                        C0 = armC0
                    })
                    AnimTween:Play()
                end
                if RangeCirclePart ~= nil then RangeCirclePart:Destroy() end
            end
        end,
        Tooltip = 'Attack players around you\nwithout aiming at them.'
    })

    pcall(function()
        local PSI = Killaura:CreateToggle({
            Name = 'Preserve Sword Icon',
            Function = function(callback)
                preserveSwordIcon = callback
            end,
            Default = true
        })
        PSI.Object.Visible = inputService.TouchEnabled
    end)

    Targets = Killaura:CreateTargets({
        Players = true,
        NPCs = true
    })
    
    TargetPriority = Killaura:CreateDropdown({
        Name = 'Target Priority',
        List = {'Players First', 'NPCs First', 'Distance'},
        Default = 'Players First',
        Tooltip = 'Choose which targets to prioritize'
    })
    
    local methods = {'Damage', 'Distance'}
    for i in sortmethods do
        if not table.find(methods, i) then
            table.insert(methods, i)
        end
    end
    SwingRange = Killaura:CreateSlider({
        Name = 'Swing range',
        Min = 1,
        Max = 40, 
        Default = 22, 
        Suffix = function(val)
            return val == 1 and 'stud' or 'studs'
        end
    })
    AttackRange = Killaura:CreateSlider({
        Name = 'Attack range',
        Min = 1,
        Max = 20,
        Default = 14, 
        Suffix = function(val)
            return val == 1 and 'stud' or 'studs'
        end
    })
    RangeCircle = Killaura:CreateToggle({
        Name = "Range Visualiser",
        Function = function(call)
            if call then
                createRangeCircle()
            else
                if RangeCirclePart then
                    RangeCirclePart:Destroy()
                    RangeCirclePart = nil
                end
            end
        end
    })
    AngleSlider = Killaura:CreateSlider({
        Name = 'Max angle',
        Min = 1,
        Max = 360,
        Default = 360
    })
    UpdateRate = Killaura:CreateSlider({
        Name = 'Update rate',
        Min = 1,
        Max = 360,
        Default = 60,
        Suffix = 'hz'
    })
    MaxTargets = Killaura:CreateSlider({
        Name = 'Max targets',
        Min = 1,
        Max = 8,
        Default = 5
    })
    Sort = Killaura:CreateDropdown({
        Name = 'Target Mode',
        List = methods
    })
    Mouse = Killaura:CreateToggle({Name = 'Require mouse down'})
    Swing = Killaura:CreateToggle({Name = 'No Swing'})
    GUI = Killaura:CreateToggle({Name = 'GUI check'})
    SwingTime = Killaura:CreateToggle({
        Name = 'Custom Swing Time',
        Function = function(callback)
            SwingTimeSlider.Object.Visible = callback
        end
    })
    SwingTimeSlider = Killaura:CreateSlider({
        Name = 'Swing Time',
        Min = 0,
        Max = 1,
        Default = 0.42,
        Decimal = 100,
        Visible = false
    })
    ContinueSwinging = Killaura:CreateToggle({
        Name = 'Continue Swinging',
        Tooltip = 'Swing X times after losing target (based on swing speed)',
        Function = function(callback)
            if ContinueSwingTime then
                ContinueSwingTime.Object.Visible = callback
            end
        end
    })
    ContinueSwingTime = Killaura:CreateSlider({
        Name = 'Swing Duration',
        Min = 0,  
        Max = 5,  
        Default = 1,
        Decimal = 10,
        Suffix = 's',
        Visible = false
    })
    CustomHitReg = Killaura:CreateToggle({
        Name = 'Custom Hit Reg',
        Tooltip = 'Limit how many hits per second',
        Function = function(callback)
            if CustomHitRegSlider then
                CustomHitRegSlider.Object.Visible = callback
            end
            if callback then
                lastCustomHitTime = 0
            end
        end
    })
    
    CustomHitRegSlider = Killaura:CreateSlider({
        Name = 'Hits Per Second',
        Min = 1,
        Max = 36,
        Default = 30,
        Tooltip = 'Maximum hits per second',
        Visible = false
    })
    
    AirHit = Killaura:CreateToggle({
        Name = "Air Hits",
        Default = true,
        Tooltip = 'enables the air hits feature',
        Function = function(v)
            if AirHitsChance then
                AirHitsChance.Object.Visible = v
            end
        end
    })
    
    AirHitsChance = Killaura:CreateSlider({
        Name = 'Air Hits Chance',
        Min = 0,
        Max = 100,
        Default = 100,
        Suffix = "%",
        Decimal = 5,
        Tooltip = 'checks if it can hit someone when they are in the air',
        Darker = true,
        Visible = false
    })
    SyncHits = Killaura:CreateToggle({
        Name = 'Sync Hits',
        Tooltip = 'Waits for sword animation before attacking'
    })
    Killaura:CreateToggle({
        Name = 'Show target',
        Function = function(callback)
            BoxSwingColor.Object.Visible = callback
            BoxAttackColor.Object.Visible = callback
            if callback then
                for i = 1, 10 do
                    local box = Instance.new('BoxHandleAdornment')
                    box.Adornee = nil
                    box.AlwaysOnTop = true
                    box.Size = Vector3.new(3, 5, 3)
                    box.CFrame = CFrame.new(0, -0.5, 0)
                    box.ZIndex = 0
                    box.Parent = vape.gui
                    Boxes[i] = box
                end
            else
                for _, v in Boxes do
                    v:Destroy()
                end
                table.clear(Boxes)
            end
        end
    })
    BoxSwingColor = Killaura:CreateColorSlider({
        Name = 'Target Color',
        Darker = true,
        DefaultHue = 0.6,
        DefaultOpacity = 0.5,
        Visible = false,
        Function = function(hue, sat, val)
            if Killaura.Enabled and RangeCirclePart ~= nil then
                RangeCirclePart.Color = Color3.fromHSV(hue, sat, val)
            end
        end
    })
    BoxAttackColor = Killaura:CreateColorSlider({
        Name = 'Attack Color',
        Darker = true,
        DefaultOpacity = 0.5,
        Visible = false
    })
    Killaura:CreateToggle({
        Name = 'Target particles',
        Function = function(callback)
            ParticleTexture.Object.Visible = callback
            ParticleColor1.Object.Visible = callback
            ParticleColor2.Object.Visible = callback
            ParticleSize.Object.Visible = callback
            if callback then
                for i = 1, 10 do
                    local part = Instance.new('Part')
                    part.Size = Vector3.new(2, 4, 2)
                    part.Anchored = true
                    part.CanCollide = false
                    part.Transparency = 1
                    part.CanQuery = false
                    part.Parent = Killaura.Enabled and gameCamera or nil
                    local particles = Instance.new('ParticleEmitter')
                    particles.Brightness = 1.5
                    particles.Size = NumberSequence.new(ParticleSize.Value)
                    particles.Shape = Enum.ParticleEmitterShape.Sphere
                    particles.Texture = ParticleTexture.Value
                    particles.Transparency = NumberSequence.new(0)
                    particles.Lifetime = NumberRange.new(0.4)
                    particles.Speed = NumberRange.new(16)
                    particles.Rate = 128
                    particles.Drag = 16
                    particles.ShapePartial = 1
                    particles.Color = ColorSequence.new({
                        ColorSequenceKeypoint.new(0, Color3.fromHSV(ParticleColor1.Hue, ParticleColor1.Sat, ParticleColor1.Value)),
                        ColorSequenceKeypoint.new(1, Color3.fromHSV(ParticleColor2.Hue, ParticleColor2.Sat, ParticleColor2.Value))
                    })
                    particles.Parent = part
                    Particles[i] = part
                end
            else
                for _, v in Particles do
                    v:Destroy()
                end
                table.clear(Particles)
            end
        end
    })
    ParticleTexture = Killaura:CreateTextBox({
        Name = 'Texture',
        Default = 'rbxassetid://14736249347',
        Function = function()
            for _, v in Particles do
                v.ParticleEmitter.Texture = ParticleTexture.Value
            end
        end,
        Darker = true,
        Visible = false
    })
    ParticleColor1 = Killaura:CreateColorSlider({
        Name = 'Color Begin',
        Function = function(hue, sat, val)
            for _, v in Particles do
                v.ParticleEmitter.Color = ColorSequence.new({
                    ColorSequenceKeypoint.new(0, Color3.fromHSV(hue, sat, val)),
                    ColorSequenceKeypoint.new(1, Color3.fromHSV(ParticleColor2.Hue, ParticleColor2.Sat, ParticleColor2.Value))
                })
            end
        end,
        Darker = true,
        Visible = false
    })
    ParticleColor2 = Killaura:CreateColorSlider({
        Name = 'Color End',
        Function = function(hue, sat, val)
            for _, v in Particles do
                v.ParticleEmitter.Color = ColorSequence.new({
                    ColorSequenceKeypoint.new(0, Color3.fromHSV(ParticleColor1.Hue, ParticleColor1.Sat, ParticleColor1.Value)),
                    ColorSequenceKeypoint.new(1, Color3.fromHSV(hue, sat, val))
                })
            end
        end,
        Darker = true,
        Visible = false
    })
    ParticleSize = Killaura:CreateSlider({
        Name = 'Size',
        Min = 0,
        Max = 1,
        Default = 0.2,
        Decimal = 100,
        Function = function(val)
            for _, v in Particles do
                v.ParticleEmitter.Size = NumberSequence.new(val)
            end
        end,
        Darker = true,
        Visible = false
    })
    Face = Killaura:CreateToggle({Name = 'Face target'})
    Animation = Killaura:CreateToggle({
        Name = 'Custom Animation',
        Function = function(callback)
            AnimationMode.Object.Visible = callback
            AnimationTween.Object.Visible = callback
            AnimationSpeed.Object.Visible = callback
            if Killaura.Enabled then
                Killaura:Toggle()
                Killaura:Toggle()
            end
        end
    })
    local animnames = {}
    for i in anims do
        table.insert(animnames, i)
    end
    AnimationMode = Killaura:CreateDropdown({
        Name = 'Animation Mode',
        List = animnames,
        Darker = true,
        Visible = false
    })
    AnimationSpeed = Killaura:CreateSlider({
        Name = 'Animation Speed',
        Min = 0,
        Max = 2,
        Default = 1,
        Decimal = 10,
        Darker = true,
        Visible = false
    })
    AnimationTween = Killaura:CreateToggle({
        Name = 'No Tween',
        Darker = true,
        Visible = false
    })
    Limit = Killaura:CreateToggle({
        Name = 'Limit to items',
        Function = function(callback)
            if inputService.TouchEnabled and Killaura.Enabled then
                pcall(function()
                    lplr.PlayerGui.MobileUI['2'].Visible = callback
                end)
            end
        end,
        Tooltip = 'Only attacks when the sword is held'
    })
    LegitAura = Killaura:CreateToggle({
        Name = 'Swing only',
        Tooltip = 'Only attacks while swinging manually'
    })
    Killaura:CreateToggle({
        Name = "Sigrid Check",
        Default = false,
        Function = function(call)
            sigridcheck = call
        end
    })
    SophiaCheck = Killaura:CreateToggle({
        Name = 'Sophia Check',
        Tooltip = 'Stops Killaura when frozen by Sophia',
        Default = false
    })
end)

-- granddad killaura
local Attacking
run(function()
	local Killaura
	local Targets
	local Sort
	local SwingRange
	local AttackRange
	local ChargeTime
	local UpdateRate
	local AngleSlider
	local MaxTargets
	local Mouse
	local Swing
	local GUI
	local BoxSwingColor
	local BoxAttackColor
	local ParticleTexture
    local SophiaCheck
    local FROZEN_THRESHOLD = 10
	local ParticleColor1
	local ParticleColor2
	local ParticleSize
	local Face
	local Animation
	local AnimationMode
	local AnimationSpeed
	local AnimationTween
	local Limit
	local LegitAura = {}
	local Particles, Boxes = {}, {}
	local anims, AnimDelay, AnimTween, armC0 = vape.Libraries.auraanims, tick()
	local AttackRemote = {FireServer = function() end}
	task.spawn(function()
		AttackRemote = bedwars.Client:Get(remotes.AttackEntity).instance
	end)

    local function isFrozen()
        if not entitylib.isAlive then return false end
        local char = entitylib.character.Character
        if char:GetAttribute("StatusEffect_frozen") then
            return true
        end
        local hasIceBlock = char:FindFirstChild("IceBlock") or 
                        char:FindFirstChild("FrozenBlock") or 
                        char:FindFirstChild("IceShell")
        
        if hasIceBlock then
            return true
        end
    
        return false
    end

	local function getAttackData()
        if SophiaCheck and SophiaCheck.Enabled then
            if isFrozen() then
                return false
            end
        end
		if Mouse.Enabled then
			if not inputService:IsMouseButtonPressed(0) then return false end
		end

		if GUI.Enabled then
			if bedwars.AppController:isLayerOpen(bedwars.UILayers.MAIN) then return false end
		end

		local sword = Limit.Enabled and store.hand or store.tools.sword
		if not sword or not sword.tool then return false end

		local meta = bedwars.ItemMeta[sword.tool.Name]
		if Limit.Enabled then
			if store.hand.toolType ~= 'sword' or bedwars.DaoController.chargingMaid then return false end
		end

		if LegitAura.Enabled then
			if (tick() - bedwars.SwordController.lastSwing) > 0.2 then return false end
		end

		return sword, meta
	end

	Killaura = vape.Categories.Blatant:CreateModule({
		Name = 'GrandKillaura',
		Function = function(callback)
			if callback then
				if inputService.TouchEnabled then
					pcall(function()
						lplr.PlayerGui.MobileUI['2'].Visible = Limit.Enabled
					end)
				end

				if Animation.Enabled and not (identifyexecutor and table.find({'Argon', 'Delta'}, ({identifyexecutor()})[1])) then
					local fake = {
						Controllers = {
							ViewmodelController = {
								isVisible = function()
									return not Attacking
								end,
								playAnimation = function(...)
									if not Attacking then
										bedwars.ViewmodelController:playAnimation(select(2, ...))
									end
								end
							}
						}
					}
					debug.setupvalue(oldSwing or bedwars.SwordController.playSwordEffect, 6, fake)
					debug.setupvalue(bedwars.ScytheController.playLocalAnimation, 3, fake)

					task.spawn(function()
						local started = false
						repeat
                            if SophiaCheck and SophiaCheck.Enabled then
                                if isFrozen() then
                                    Attacking = false
                                    store.KillauraTarget = nil
                                    task.wait(0.3)
                                    continue
                                end
                            end
							if Attacking then
								if not armC0 then
									armC0 = gameCamera.Viewmodel.RightHand.RightWrist.C0
								end
								local first = not started
								started = true

								if AnimationMode.Value == 'Random' then
									anims.Random = {{CFrame = CFrame.Angles(math.rad(math.random(1, 360)), math.rad(math.random(1, 360)), math.rad(math.random(1, 360))), Time = 0.12}}
								end

								for _, v in anims[AnimationMode.Value] do
									AnimTween = tweenService:Create(gameCamera.Viewmodel.RightHand.RightWrist, TweenInfo.new(first and (AnimationTween.Enabled and 0.001 or 0.1) or v.Time / AnimationSpeed.Value, Enum.EasingStyle.Linear), {
										C0 = armC0 * v.CFrame
									})
									AnimTween:Play()
									AnimTween.Completed:Wait()
									first = false
									if (not Killaura.Enabled) or (not Attacking) then break end
								end
							elseif started then
								started = false
								AnimTween = tweenService:Create(gameCamera.Viewmodel.RightHand.RightWrist, TweenInfo.new(AnimationTween.Enabled and 0.001 or 0.3, Enum.EasingStyle.Exponential), {
									C0 = armC0
								})
								AnimTween:Play()
							end

							if not started then
								task.wait(1 / UpdateRate.Value)
							end
						until (not Killaura.Enabled) or (not Animation.Enabled)
					end)
				end

				local swingCooldown = 0
				repeat
					local attacked, sword, meta = {}, getAttackData()
					Attacking = false
					store.KillauraTarget = nil
					if sword then
						local plrs = entitylib.AllPosition({
							Range = SwingRange.Value,
							Wallcheck = Targets.Walls.Enabled or nil,
							Part = 'RootPart',
							Players = Targets.Players.Enabled,
							NPCs = Targets.NPCs.Enabled,
							Limit = MaxTargets.Value,
							Sort = sortmethods[Sort.Value]
						})

						if #plrs > 0 then
							switchItem(sword.tool, 0)
							local selfpos = entitylib.character.RootPart.Position
							local localfacing = entitylib.character.RootPart.CFrame.LookVector * Vector3.new(1, 0, 1)

							for _, v in plrs do
								local delta = (v.RootPart.Position - selfpos)
								local angle = math.acos(localfacing:Dot((delta * Vector3.new(1, 0, 1)).Unit))
								if angle > (math.rad(AngleSlider.Value) / 2) then continue end

								table.insert(attacked, {
									Entity = v,
									Check = delta.Magnitude > AttackRange.Value and BoxSwingColor or BoxAttackColor
								})
								targetinfo.Targets[v] = tick() + 1

								if not Attacking then
									Attacking = true
									store.KillauraTarget = v
									if not Swing.Enabled and AnimDelay < tick() and not LegitAura.Enabled then
										AnimDelay = tick() + (meta.sword.respectAttackSpeedForEffects and meta.sword.attackSpeed or math.max(ChargeTime.Value, 0.11))
										bedwars.SwordController:playSwordEffect(meta, false)
										if meta.displayName:find(' Scythe') then
											bedwars.ScytheController:playLocalAnimation()
										end

										if vape.ThreadFix then
											setthreadidentity(8)
										end
									end
								end

								if delta.Magnitude > AttackRange.Value then continue end
								if delta.Magnitude < 14.4 and (tick() - swingCooldown) < math.max(ChargeTime.Value, 0.02) then continue end

								local actualRoot = v.Character.PrimaryPart
								if actualRoot then
									local dir = CFrame.lookAt(selfpos, actualRoot.Position).LookVector
									local pos = selfpos + dir * math.max(delta.Magnitude - 14.399, 0)
									swingCooldown = tick()
									bedwars.SwordController.lastAttack = workspace:GetServerTimeNow()
									store.attackReach = (delta.Magnitude * 100) // 1 / 100
									store.attackReachUpdate = tick() + 1

									if delta.Magnitude < 14.4 and ChargeTime.Value > 0.11 then
										AnimDelay = tick()
									end

									AttackRemote:FireServer({
										weapon = sword.tool,
										chargedAttack = {chargeRatio = 0},
										lastSwingServerTimeDelta = 0.5,
										entityInstance = v.Character,
										validate = {
											raycast = {
												cameraPosition = {value = pos},
												cursorDirection = {value = dir}
											},
											targetPosition = {value = actualRoot.Position},
											selfPosition = {value = pos}
										}
									})
								end
							end
						end
					end

					for i, v in Boxes do
						v.Adornee = attacked[i] and attacked[i].Entity.RootPart or nil
						if v.Adornee then
							v.Color3 = Color3.fromHSV(attacked[i].Check.Hue, attacked[i].Check.Sat, attacked[i].Check.Value)
							v.Transparency = 1 - attacked[i].Check.Opacity
						end
					end

					for i, v in Particles do
						v.Position = attacked[i] and attacked[i].Entity.RootPart.Position or Vector3.new(9e9, 9e9, 9e9)
						v.Parent = attacked[i] and gameCamera or nil
					end

					if Face.Enabled and attacked[1] then
						local vec = attacked[1].Entity.RootPart.Position * Vector3.new(1, 0, 1)
						entitylib.character.RootPart.CFrame = CFrame.lookAt(entitylib.character.RootPart.Position, Vector3.new(vec.X, entitylib.character.RootPart.Position.Y + 0.001, vec.Z))
					end

					task.wait(1 / UpdateRate.Value)
				until not Killaura.Enabled
			else
				store.KillauraTarget = nil
				for _, v in Boxes do
					v.Adornee = nil
				end
				for _, v in Particles do
					v.Parent = nil
				end
				if inputService.TouchEnabled then
					pcall(function()
						lplr.PlayerGui.MobileUI['2'].Visible = true
					end)
				end
				debug.setupvalue(oldSwing or bedwars.SwordController.playSwordEffect, 6, bedwars.Knit)
				debug.setupvalue(bedwars.ScytheController.playLocalAnimation, 3, bedwars.Knit)
				Attacking = false
				if armC0 then
					AnimTween = tweenService:Create(gameCamera.Viewmodel.RightHand.RightWrist, TweenInfo.new(AnimationTween.Enabled and 0.001 or 0.3, Enum.EasingStyle.Exponential), {
						C0 = armC0
					})
					AnimTween:Play()
				end
			end
		end,
		Tooltip = 'Attack players around you\nwithout aiming at them.(granddad ka)'
	})
	Targets = Killaura:CreateTargets({
		Players = true,
		NPCs = true
	})
	local methods = {'Damage', 'Distance'}
	for i in sortmethods do
		if not table.find(methods, i) then
			table.insert(methods, i)
		end
	end
	SwingRange = Killaura:CreateSlider({
		Name = 'Swing range',
		Min = 1,
		Max = 18,
		Default = 18,
		Suffix = function(val)
			return val == 1 and 'stud' or 'studs'
		end
	})
	AttackRange = Killaura:CreateSlider({
		Name = 'Attack range',
		Min = 1,
		Max = 18,
		Default = 18,
		Suffix = function(val)
			return val == 1 and 'stud' or 'studs'
		end
	})
	ChargeTime = Killaura:CreateSlider({
		Name = 'Swing time',
		Min = 0,
		Max = 0.5,
		Default = 0.42,
		Decimal = 100
	})
	AngleSlider = Killaura:CreateSlider({
		Name = 'Max angle',
		Min = 1,
		Max = 360,
		Default = 360
	})
	UpdateRate = Killaura:CreateSlider({
		Name = 'Update rate',
		Min = 1,
		Max = 120,
		Default = 60,
		Suffix = 'hz'
	})
	MaxTargets = Killaura:CreateSlider({
		Name = 'Max targets',
		Min = 1,
		Max = 5,
		Default = 5
	})
	Sort = Killaura:CreateDropdown({
		Name = 'Target Mode',
		List = methods
	})
	Mouse = Killaura:CreateToggle({Name = 'Require mouse down'})
	Swing = Killaura:CreateToggle({Name = 'No Swing'})
	GUI = Killaura:CreateToggle({Name = 'GUI check'})
	Killaura:CreateToggle({
		Name = 'Show target',
		Function = function(callback)
			BoxSwingColor.Object.Visible = callback
			BoxAttackColor.Object.Visible = callback
			if callback then
				for i = 1, 10 do
					local box = Instance.new('BoxHandleAdornment')
					box.Adornee = nil
					box.AlwaysOnTop = true
					box.Size = Vector3.new(3, 5, 3)
					box.CFrame = CFrame.new(0, -0.5, 0)
					box.ZIndex = 0
					box.Parent = vape.gui
					Boxes[i] = box
				end
			else
				for _, v in Boxes do
					v:Destroy()
				end
				table.clear(Boxes)
			end
		end
	})
	BoxSwingColor = Killaura:CreateColorSlider({
		Name = 'Target Color',
		Darker = true,
		DefaultHue = 0.6,
		DefaultOpacity = 0.5,
		Visible = false
	})
	BoxAttackColor = Killaura:CreateColorSlider({
		Name = 'Attack Color',
		Darker = true,
		DefaultOpacity = 0.5,
		Visible = false
	})
	Killaura:CreateToggle({
		Name = 'Target particles',
		Function = function(callback)
			ParticleTexture.Object.Visible = callback
			ParticleColor1.Object.Visible = callback
			ParticleColor2.Object.Visible = callback
			ParticleSize.Object.Visible = callback
			if callback then
				for i = 1, 10 do
					local part = Instance.new('Part')
					part.Size = Vector3.new(2, 4, 2)
					part.Anchored = true
					part.CanCollide = false
					part.Transparency = 1
					part.CanQuery = false
					part.Parent = Killaura.Enabled and gameCamera or nil
					local particles = Instance.new('ParticleEmitter')
					particles.Brightness = 1.5
					particles.Size = NumberSequence.new(ParticleSize.Value)
					particles.Shape = Enum.ParticleEmitterShape.Sphere
					particles.Texture = ParticleTexture.Value
					particles.Transparency = NumberSequence.new(0)
					particles.Lifetime = NumberRange.new(0.4)
					particles.Speed = NumberRange.new(16)
					particles.Rate = 128
					particles.Drag = 16
					particles.ShapePartial = 1
					particles.Color = ColorSequence.new({
						ColorSequenceKeypoint.new(0, Color3.fromHSV(ParticleColor1.Hue, ParticleColor1.Sat, ParticleColor1.Value)),
						ColorSequenceKeypoint.new(1, Color3.fromHSV(ParticleColor2.Hue, ParticleColor2.Sat, ParticleColor2.Value))
					})
					particles.Parent = part
					Particles[i] = part
				end
			else
				for _, v in Particles do
					v:Destroy()
				end
				table.clear(Particles)
			end
		end
	})
	ParticleTexture = Killaura:CreateTextBox({
		Name = 'Texture',
		Default = 'rbxassetid://14736249347',
		Function = function()
			for _, v in Particles do
				v.ParticleEmitter.Texture = ParticleTexture.Value
			end
		end,
		Darker = true,
		Visible = false
	})
	ParticleColor1 = Killaura:CreateColorSlider({
		Name = 'Color Begin',
		Function = function(hue, sat, val)
			for _, v in Particles do
				v.ParticleEmitter.Color = ColorSequence.new({
					ColorSequenceKeypoint.new(0, Color3.fromHSV(hue, sat, val)),
					ColorSequenceKeypoint.new(1, Color3.fromHSV(ParticleColor2.Hue, ParticleColor2.Sat, ParticleColor2.Value))
				})
			end
		end,
		Darker = true,
		Visible = false
	})
	ParticleColor2 = Killaura:CreateColorSlider({
		Name = 'Color End',
		Function = function(hue, sat, val)
			for _, v in Particles do
				v.ParticleEmitter.Color = ColorSequence.new({
					ColorSequenceKeypoint.new(0, Color3.fromHSV(ParticleColor1.Hue, ParticleColor1.Sat, ParticleColor1.Value)),
					ColorSequenceKeypoint.new(1, Color3.fromHSV(hue, sat, val))
				})
			end
		end,
		Darker = true,
		Visible = false
	})
	ParticleSize = Killaura:CreateSlider({
		Name = 'Size',
		Min = 0,
		Max = 1,
		Default = 0.2,
		Decimal = 100,
		Function = function(val)
			for _, v in Particles do
				v.ParticleEmitter.Size = NumberSequence.new(val)
			end
		end,
		Darker = true,
		Visible = false
	})
	Face = Killaura:CreateToggle({Name = 'Face target'})
	Animation = Killaura:CreateToggle({
		Name = 'Custom Animation',
		Function = function(callback)
			AnimationMode.Object.Visible = callback
			AnimationTween.Object.Visible = callback
			AnimationSpeed.Object.Visible = callback
			if Killaura.Enabled then
				Killaura:Toggle()
				Killaura:Toggle()
			end
		end
	})
	local animnames = {}
	for i in anims do
		table.insert(animnames, i)
	end
	AnimationMode = Killaura:CreateDropdown({
		Name = 'Animation Mode',
		List = animnames,
		Darker = true,
		Visible = false
	})
	AnimationSpeed = Killaura:CreateSlider({
		Name = 'Animation Speed',
		Min = 0,
		Max = 2,
		Default = 1,
		Decimal = 10,
		Darker = true,
		Visible = false
	})
	AnimationTween = Killaura:CreateToggle({
		Name = 'No Tween',
		Darker = true,
		Visible = false
	})
	Limit = Killaura:CreateToggle({
		Name = 'Limit to items',
		Function = function(callback)
			if inputService.TouchEnabled and Killaura.Enabled then
				pcall(function()
					lplr.PlayerGui.MobileUI['2'].Visible = callback
				end)
			end
		end,
		Tooltip = 'Only attacks when the sword is held'
	})
	LegitAura = Killaura:CreateToggle({
		Name = 'Swing only',
		Tooltip = 'Only attacks while swinging manually'
	})
    SophiaCheck = Killaura:CreateToggle({
        Name = 'Sophia Check',
        Tooltip = 'Stops Killaura when frozen by Sophia',
        Default = false
    })
end)
																																			
run(function()
	local Value
	local CameraDir
	local start
	local JumpTick, JumpSpeed, Direction = tick(), 0
	local projectileRemote = {InvokeServer = function() end}
	task.spawn(function()
		projectileRemote = bedwars.Client:Get(remotes.FireProjectile).instance
	end)
	
	local function launchProjectile(item, pos, proj, speed, dir)
		if not pos then return end
	
		pos = pos - dir * 0.1
		local shootPosition = (CFrame.lookAlong(pos, Vector3.new(0, -speed, 0)) * CFrame.new(Vector3.new(-bedwars.BowConstantsTable.RelX, -bedwars.BowConstantsTable.RelY, -bedwars.BowConstantsTable.RelZ)))
		switchItem(item.tool, 0)
		task.wait(0.1)
		bedwars.ProjectileController:createLocalProjectile(bedwars.ProjectileMeta[proj], proj, proj, shootPosition.Position, '', shootPosition.LookVector * speed, {drawDurationSeconds = 1})
		if projectileRemote:InvokeServer(item.tool, proj, proj, shootPosition.Position, pos, shootPosition.LookVector * speed, httpService:GenerateGUID(true), {drawDurationSeconds = 1}, workspace:GetServerTimeNow() - 0.045) then
			local shoot = bedwars.ItemMeta[item.itemType].projectileSource.launchSound
			shoot = shoot and shoot[math.random(1, #shoot)] or nil
			if shoot then
				bedwars.SoundManager:playSound(shoot)
			end
		end
	end
	
	local LongJumpMethods = {
		cannon = function(_, pos, dir)
			pos = pos - Vector3.new(0, (entitylib.character.HipHeight + (entitylib.character.RootPart.Size.Y / 2)) - 3, 0)
			local rounded = Vector3.new(math.round(pos.X / 3) * 3, math.round(pos.Y / 3) * 3, math.round(pos.Z / 3) * 3)
			bedwars.placeBlock(rounded, 'cannon', false)
	
			task.delay(0, function()
				local block, blockpos = getPlacedBlock(rounded)
				if block and block.Name == 'cannon' and (entitylib.character.RootPart.Position - block.Position).Magnitude < 20 then
					local breaktype = bedwars.ItemMeta[block.Name].block.breakType
					local tool = store.tools[breaktype]
					if tool then
						switchItem(tool.tool)
					end
	
					bedwars.Client:Get(remotes.CannonAim):SendToServer({
						cannonBlockPos = blockpos,
						lookVector = dir
					})
	
					local broken = 0.1
					if bedwars.BlockController:calculateBlockDamage(lplr, {blockPosition = blockpos}) < block:GetAttribute('Health') then
						broken = 0.4
						bedwars.breakBlock(block, true, true)
					end
	
					task.delay(broken, function()
						for _ = 1, 3 do
							local call = bedwars.Client:Get(remotes.CannonLaunch):CallServer({cannonBlockPos = blockpos})
							if call then
								bedwars.breakBlock(block, true, true)
								JumpSpeed = 5.25 * Value.Value
								JumpTick = tick() + 2.3
								Direction = Vector3.new(dir.X, 0, dir.Z).Unit
								break
							end
							task.wait(0.1)
						end
					end)
				end
			end)
		end,
		cat = function(_, _, dir)
			LongJump:Clean(vapeEvents.CatPounce.Event:Connect(function()
				JumpSpeed = 4 * Value.Value
				JumpTick = tick() + 2.5
				Direction = Vector3.new(dir.X, 0, dir.Z).Unit
				entitylib.character.RootPart.Velocity = Vector3.zero
			end))
	
			if not bedwars.AbilityController:canUseAbility('CAT_POUNCE') then
				repeat task.wait() until bedwars.AbilityController:canUseAbility('CAT_POUNCE') or not LongJump.Enabled
			end
	
			if bedwars.AbilityController:canUseAbility('CAT_POUNCE') and LongJump.Enabled then
				bedwars.AbilityController:useAbility('CAT_POUNCE')
			end
		end,
		fireball = function(item, pos, dir)
			launchProjectile(item, pos, 'fireball', 60, dir)
		end,
		grappling_hook = function(item, pos, dir)
			launchProjectile(item, pos, 'grappling_hook_projectile', 140, dir)
		end,
		jade_hammer = function(item, _, dir)
			if not bedwars.AbilityController:canUseAbility(item.itemType..'_jump') then
				repeat task.wait() until bedwars.AbilityController:canUseAbility(item.itemType..'_jump') or not LongJump.Enabled
			end
	
			if bedwars.AbilityController:canUseAbility(item.itemType..'_jump') and LongJump.Enabled then
				bedwars.AbilityController:useAbility(item.itemType..'_jump')
				JumpSpeed = 1.4 * Value.Value
				JumpTick = tick() + 2.5
				Direction = Vector3.new(dir.X, 0, dir.Z).Unit
			end
		end,
		tnt = function(item, pos, dir)
			pos = pos - Vector3.new(0, (entitylib.character.HipHeight + (entitylib.character.RootPart.Size.Y / 2)) - 3, 0)
			local rounded = Vector3.new(math.round(pos.X / 3) * 3, math.round(pos.Y / 3) * 3, math.round(pos.Z / 3) * 3)
			start = Vector3.new(rounded.X, start.Y, rounded.Z) + (dir * (item.itemType == 'pirate_gunpowder_barrel' and 2.6 or 0.2))
			bedwars.placeBlock(rounded, item.itemType, false)
		end,
		wood_dao = function(item, pos, dir)
			if (lplr.Character:GetAttribute('CanDashNext') or 0) > workspace:GetServerTimeNow() or not bedwars.AbilityController:canUseAbility('dash') then
				repeat task.wait() until (lplr.Character:GetAttribute('CanDashNext') or 0) < workspace:GetServerTimeNow() and bedwars.AbilityController:canUseAbility('dash') or not LongJump.Enabled
			end
	
			if LongJump.Enabled then
				bedwars.SwordController.lastAttack = workspace:GetServerTimeNow()
				switchItem(item.tool, 0.1)
				replicatedStorage['events-@easy-games/game-core:shared/game-core-networking@getEvents.Events'].useAbility:FireServer('dash', {
					direction = dir,
					origin = pos,
					weapon = item.itemType
				})
				JumpSpeed = 4.5 * Value.Value
				JumpTick = tick() + 2.4
				Direction = Vector3.new(dir.X, 0, dir.Z).Unit
			end
		end
	}
	for _, v in {'stone_dao', 'iron_dao', 'diamond_dao', 'emerald_dao'} do
		LongJumpMethods[v] = LongJumpMethods.wood_dao
	end
	LongJumpMethods.void_axe = LongJumpMethods.jade_hammer
	LongJumpMethods.siege_tnt = LongJumpMethods.tnt
	LongJumpMethods.pirate_gunpowder_barrel = LongJumpMethods.tnt
	
	LongJump = vape.Categories.Blatant:CreateModule({
		Name = 'LongJump',
		Function = function(callback)
			frictionTable.LongJump = callback or nil
			updateVelocity()
			if callback then
				LongJump:Clean(vapeEvents.EntityDamageEvent.Event:Connect(function(damageTable)
					if damageTable.entityInstance == lplr.Character and damageTable.fromEntity == lplr.Character and (not damageTable.knockbackMultiplier or not damageTable.knockbackMultiplier.disabled) then
						local knockbackBoost = bedwars.KnockbackUtil.calculateKnockbackVelocity(Vector3.one, 1, {
							vertical = 0,
							horizontal = (damageTable.knockbackMultiplier and damageTable.knockbackMultiplier.horizontal or 1)
						}).Magnitude * 1.1
	
						if knockbackBoost >= JumpSpeed then
							local pos = damageTable.fromPosition and Vector3.new(damageTable.fromPosition.X, damageTable.fromPosition.Y, damageTable.fromPosition.Z) or damageTable.fromEntity and damageTable.fromEntity.PrimaryPart.Position
							if not pos then return end
							local vec = (entitylib.character.RootPart.Position - pos)
							JumpSpeed = knockbackBoost
							JumpTick = tick() + 2.5
							Direction = Vector3.new(vec.X, 0, vec.Z).Unit
						end
					end
				end))
				LongJump:Clean(vapeEvents.GrapplingHookFunctions.Event:Connect(function(dataTable)
					if dataTable.hookFunction == 'PLAYER_IN_TRANSIT' then
						local vec = entitylib.character.RootPart.CFrame.LookVector
						JumpSpeed = 2.5 * Value.Value
						JumpTick = tick() + 2.5
						Direction = Vector3.new(vec.X, 0, vec.Z).Unit
					end
				end))
	
				start = entitylib.isAlive and entitylib.character.RootPart.Position or nil
				LongJump:Clean(runService.PreSimulation:Connect(function(dt)
					local root = entitylib.isAlive and entitylib.character.RootPart or nil
	
					if root and isnetworkowner(root) then
						if JumpTick > tick() then
							root.AssemblyLinearVelocity = Direction * (getSpeed() + ((JumpTick - tick()) > 1.1 and JumpSpeed or 0)) + Vector3.new(0, root.AssemblyLinearVelocity.Y, 0)
							if entitylib.character.Humanoid.FloorMaterial == Enum.Material.Air and not start then
								root.AssemblyLinearVelocity += Vector3.new(0, dt * (workspace.Gravity - 23), 0)
							else
								root.AssemblyLinearVelocity = Vector3.new(root.AssemblyLinearVelocity.X, 15, root.AssemblyLinearVelocity.Z)
							end
							start = nil
						else
							if start then
								root.CFrame = CFrame.lookAlong(start, root.CFrame.LookVector)
							end
							root.AssemblyLinearVelocity = Vector3.zero
							JumpSpeed = 0
						end
					else
						start = nil
					end
				end))
	
				if store.hand and LongJumpMethods[store.hand.tool.Name] then
					task.spawn(LongJumpMethods[store.hand.tool.Name], getItem(store.hand.tool.Name), start, (CameraDir.Enabled and gameCamera or entitylib.character.RootPart).CFrame.LookVector)
					return
				end
	
				for i, v in LongJumpMethods do
					local item = getItem(i)
					if item or store.equippedKit == i then
						task.spawn(v, item, start, (CameraDir.Enabled and gameCamera or entitylib.character.RootPart).CFrame.LookVector)
						break
					end
				end
			else
				JumpTick = tick()
				Direction = nil
				JumpSpeed = 0
			end
		end,
		ExtraText = function()
			return 'Heatseeker'
		end,
		Tooltip = 'Lets you jump farther'
	})
	Value = LongJump:CreateSlider({
		Name = 'Speed',
		Min = 1,
		Max = 37,
		Default = 37,
		Suffix = function(val)
			return val == 1 and 'stud' or 'studs'
		end
	})
	CameraDir = LongJump:CreateToggle({
		Name = 'Camera Direction'
	})
end)
	
run(function()
    local NoFall
    local Mode
    local Chance
    local DamageAccuracy
    local AutoToggle
    local HealthThreshold
    
    local rand = Random.new()
    local rayParams = RaycastParams.new()
    local groundHit
    
    local VECTOR_DOWN = Vector3.new(0, -1000, 0)
    local BLOCKCAST_SIZE = Vector3.new(3, 3, 3)
    local activationCheck = 0
    local lastRNGValue = 100
    
    task.spawn(function()
        groundHit = bedwars.Client:Get(remotes.GroundHit).instance
    end)
    
    rayParams.CollisionGroup = "Default"
    
    local function canActivate()
        local now = tick()
        if now - activationCheck > 0.5 then
            activationCheck = now
            lastRNGValue = rand:NextNumber(0, 100)
        end
        
        if Mode.Value == "Chance" then
            if lastRNGValue > Chance.Value then
                return false
            end
        end
        
        if not AutoToggle.Enabled then
            return true
        end
        
        local humanoid = entitylib.character and entitylib.character.Humanoid
        if not humanoid then return false end
        
        return humanoid.Health <= HealthThreshold.Value
    end
    
    local function runDamageAccuracyMode()
        local tracked = 0
        local extraGravity = 0
        
        NoFall:Clean(runService.PreSimulation:Connect(function(dt)
            if entitylib.isAlive then
                local root = store.rootpart or entitylib.character.RootPart
                local velocity = root.AssemblyLinearVelocity
                
                if velocity.Y < -85 then
                    rayParams.FilterDescendantsInstances = {lplr.Character, gameCamera}
                    rayParams.CollisionGroup = root.CollisionGroup

                    local rootSize = root.Size.Y / 2.5 + entitylib.character.HipHeight
                    local checkDistance = Vector3.new(0, (tracked * 0.1) - rootSize, 0)
                    local ray = workspace:Blockcast(root.CFrame, BLOCKCAST_SIZE, checkDistance, rayParams)
                    
                    if not ray then
                        local Failed = rand:NextNumber(0, 100) < DamageAccuracy.Value
                        local velo = velocity.Y

                        if Failed then 
                            root.AssemblyLinearVelocity = Vector3.new(velocity.X, velo + 0.5, velocity.Z)
                        else
                            root.AssemblyLinearVelocity = Vector3.new(velocity.X, -86, velocity.Z)
                        end

                        root.CFrame = root.CFrame + Vector3.new(0, (Failed and -extraGravity or extraGravity) * dt, 0)
                        extraGravity = extraGravity + (Failed and workspace.Gravity or -workspace.Gravity) * dt
                        tracked = velo
                    else
                        tracked = velocity.Y
                    end
                else
                    extraGravity = 0
                    tracked = 0
                end
            end
        end))
    end
    
    local function runChanceMode()
        local rng = Random.new(tick())
        local fallVelocityTracker = 0
        local FALL_THRESHOLD = -85
        local CHECK_INTERVAL = 0.03
        
        local function isPlayerInAir()
            if not entitylib.isAlive then return false end
            local humanoid = entitylib.character.Humanoid
            return humanoid.FloorMaterial == Enum.Material.Air
        end
        
        local function getCurrentVelocity()
            if not entitylib.isAlive then return 0 end
            return entitylib.character.RootPart.AssemblyLinearVelocity.Y
        end
        
        local function shouldTriggerNoFall()
            local roll = rng:NextNumber(0, 100)
            return roll <= Chance.Value
        end
        
        local function sendGroundHitPacket()
            pcall(function()
                local timestamp = workspace:GetServerTimeNow()
                local damageVector = Vector3.new(0, fallVelocityTracker, 0)
                bedwars.Client:Get("GroundHit"):SendToServer(nil, damageVector, timestamp)
            end)
        end
        
        local function resetFallTracker()
            fallVelocityTracker = 0
        end
        
        local function updateFallVelocity(currentVel)
            fallVelocityTracker = math.min(fallVelocityTracker, currentVel)
        end
        
        local function handleFallDamage()
            if fallVelocityTracker >= FALL_THRESHOLD then return end
            
            if shouldTriggerNoFall() and canActivate() then
                sendGroundHitPacket()
            end
            
            resetFallTracker()
        end
        
        local function monitorFallState()
            if not entitylib.isAlive then
                resetFallTracker()
                return
            end
            
            if isPlayerInAir() then
                local velocity = getCurrentVelocity()
                updateFallVelocity(velocity)
            else
                resetFallTracker()
            end
            
            handleFallDamage()
        end
        
        repeat
            monitorFallState()
            task.wait(CHECK_INTERVAL)
        until not NoFall.Enabled
    end
    
    NoFall = vape.Categories.Blatant:CreateModule({
        Name = 'NoFall',
        Function = function(callback)
            if callback then
                if Mode.Value == 'Damage Accuracy' then
                    runDamageAccuracyMode()
                elseif Mode.Value == 'Chance' then
                    runChanceMode()
                elseif Mode.Value == 'Spoof' then
                    local extraGravity = 0
                    local lastCheck = 0
                    
                    NoFall:Clean(runService.PreSimulation:Connect(function(dt)
                        if not entitylib.isAlive then return end
                        
                        local root = entitylib.character.RootPart
                        local velocity = root.AssemblyLinearVelocity
                        
                        if velocity.Y < -85 then
                            local now = tick()
                            if now - lastCheck < 0.033 then return end
                            lastCheck = now
                            
                            if canActivate() then
                                rayParams.FilterDescendantsInstances = {lplr.Character, gameCamera}
                                rayParams.CollisionGroup = root.CollisionGroup
                                
                                local tracked = velocity.Y
                                local rootSize = root.Size.Y / 2 + entitylib.character.HipHeight
                                local checkDistance = Vector3.new(0, (tracked * 0.1) - rootSize, 0)
                                local ray = workspace:Blockcast(root.CFrame, BLOCKCAST_SIZE, checkDistance, rayParams)
                                
                                if not ray then
                                    root.AssemblyLinearVelocity = Vector3.new(velocity.X, -86, velocity.Z)
                                    root.CFrame += Vector3.new(0, extraGravity * dt, 0)
                                    extraGravity += -workspace.Gravity * dt
                                end
                            end
                        else
                            extraGravity = 0
                        end
                    end))
                else
                    rayParams.FilterDescendantsInstances = {lplr.Character, gameCamera}
                    local tracked = 0
                    
                    repeat
                        if entitylib.isAlive then
                            local root = entitylib.character.RootPart
                            local velocity = root.AssemblyLinearVelocity
                            tracked = entitylib.character.Humanoid.FloorMaterial == Enum.Material.Air and math.min(tracked, velocity.Y) or 0
                            
                            if tracked < -85 and canActivate() then
                                if Mode.Value == 'Packet' then
                                    groundHit:FireServer(nil, Vector3.new(0, tracked, 0), workspace:GetServerTimeNow())
                                    tracked = 0
                                else
                                    rayParams.CollisionGroup = root.CollisionGroup
                                    local rootSize = root.Size.Y / 2 + entitylib.character.HipHeight
                                    
                                    if Mode.Value == 'Teleport' then
                                        local ray = workspace:Blockcast(root.CFrame, BLOCKCAST_SIZE, VECTOR_DOWN, rayParams)
                                        if ray then
                                            root.CFrame -= Vector3.new(0, root.Position.Y - (ray.Position.Y + rootSize), 0)
                                            tracked = 0
                                        end
                                    end
                                end
                            end
                        end
                        
                        task.wait(0.05) 
                    until not NoFall.Enabled
                end
            end
        end,
        Tooltip = 'Prevents taking fall damage.'
    })
    
    Mode = NoFall:CreateDropdown({
        Name = 'Mode',
        List = {'Packet', 'Spoof', 'Teleport', 'Chance', 'Damage Accuracy'},
        Function = function(val)
            if Chance.Object then
                Chance.Object.Visible = val == 'Chance'
            end
            if DamageAccuracy.Object then
                DamageAccuracy.Object.Visible = val == 'Damage Accuracy'
            end
            
            if NoFall.Enabled then
                NoFall:Toggle()
                NoFall:Toggle()
            end
        end
    })
    
    Chance = NoFall:CreateSlider({
        Name = 'Chance',
        Min = 0,
        Max = 100,
        Default = 100,
        Suffix = '%',
        Tooltip = 'Chance for NoFall to activate'
    })
    Chance.Object.Visible = false
    
    DamageAccuracy = NoFall:CreateSlider({
        Name = 'Damage Accuracy',
        Min = 0,
        Max = 100,
        Suffix = '%',
        Default = 0,
        Decimal = 5,
        Tooltip = 'Percentage of fall damage to take (0% = no damage, 100% = full damage)'
    })
    DamageAccuracy.Object.Visible = false
    
    AutoToggle = NoFall:CreateToggle({
        Name = "Auto Toggle",
        Default = false,
        Function = function(val) 
            HealthThreshold.Object.Visible = val
        end,
        Tooltip = "Only activate when health is below threshold"
    })
    
    HealthThreshold = NoFall:CreateSlider({
        Name = "Health Threshold",
        Min = 10,
        Max = 100,
        Default = 50,
        Tooltip = "Activate only when HP is below this"
    })
    HealthThreshold.Object.Visible = false
end)

run(function()
    local moduleData = {
        Connection = nil,
        CurrentDuration = 1,
        CachedPrompts = {}
    }
    
    local function updatePrompt(prompt, duration)
        if prompt and prompt:IsA("ProximityPrompt") then
            prompt.HoldDuration = duration
        end
    end
    
    local function updateAllPrompts(duration)
        for prompt in pairs(moduleData.CachedPrompts) do
            if prompt and prompt.Parent then
                prompt.HoldDuration = duration
            else
                moduleData.CachedPrompts[prompt] = nil
            end
        end
    end
    
    local function cacheExistingPrompts()
        moduleData.CachedPrompts = {}
        
        for _, descendant in workspace:GetDescendants() do
            if descendant:IsA("ProximityPrompt") then
                moduleData.CachedPrompts[descendant] = true
                descendant.HoldDuration = moduleData.CurrentDuration
            end
        end
    end
    
    local ProximityPromptDuration = vape.Categories.Utility:CreateModule({
        Name = 'Proximity Prompt Duration',
        Function = function(callback)
            if callback then
                if moduleData.Connection then
                    moduleData.Connection:Disconnect()
                    moduleData.Connection = nil
                end
                
                cacheExistingPrompts()
                
                moduleData.Connection = workspace.DescendantAdded:Connect(function(descendant)
                    if descendant:IsA("ProximityPrompt") then
                        moduleData.CachedPrompts[descendant] = true
                        descendant.HoldDuration = moduleData.CurrentDuration
                    end
                end)
            else
                if moduleData.Connection then
                    moduleData.Connection:Disconnect()
                    moduleData.Connection = nil
                end
                
                moduleData.CachedPrompts = {}
            end
        end,
        Tooltip = 'Set custom duration for all proximity prompts'
    })
    
    local ProximityDurationSlider = ProximityPromptDuration:CreateSlider({
        Name = 'Duration',
        Min = 0,
        Max = 10,
        Default = 1,
        Decimal = 100,
        Suffix = 's',
        Function = function(value)
            moduleData.CurrentDuration = value
            if ProximityPromptDuration.Enabled then
                updateAllPrompts(value)
            end
        end
    })
end)
	
run(function()
    local old
    local SophiaCheck
    local isFrozen = false
    local frozenStacks = 0
    local frozenCheckConnection
    local FROZEN_THRESHOLD = 10
    local lastCheckTime = 0
    local CHECK_INTERVAL = 0.1 
    
    local cachedDescendants = {}
    local lastDescendantUpdate = 0
    local DESCENDANT_CACHE_TIME = 1 
    
    local function updateDescendantCache(char)
        local now = tick()
        if now - lastDescendantUpdate < DESCENDANT_CACHE_TIME then
            return 
        end
        
        lastDescendantUpdate = now
        cachedDescendants = char:GetDescendants()
    end
    
    local function checkFrozenStatus()
        if not entitylib.isAlive then
            isFrozen = false
            frozenStacks = 0
            return
        end
        
        local char = entitylib.character.Character
        frozenStacks = 0
        isFrozen = false
        
        local coldStacks = char:GetAttribute("ColdStacks") or 
                           char:GetAttribute("FrostStacks") or 
                           char:GetAttribute("FreezeStacks") or
                           char:GetAttribute("FROZEN_STACKS")
        
        if coldStacks and coldStacks > 0 then
            frozenStacks = coldStacks
            isFrozen = frozenStacks >= FROZEN_THRESHOLD
            return
        end
        
        local statusEffects = char:GetAttribute("StatusEffects")
        if type(statusEffects) == "table" then
            for effectName, stackCount in pairs(statusEffects) do
                local nameLower = tostring(effectName):lower()
                if nameLower:match("[cold|frost|freeze]") then
                    if type(stackCount) == "number" then
                        frozenStacks = stackCount
                        isFrozen = stackCount >= FROZEN_THRESHOLD
                        return
                    elseif stackCount then
                        frozenStacks = FROZEN_THRESHOLD
                        isFrozen = true
                        return
                    end
                end
            end
        end
        
        local hasIceBlock = char:FindFirstChild("IceBlock") or 
                            char:FindFirstChild("FrozenBlock") or 
                            char:FindFirstChild("IceShell")
        
        if hasIceBlock then
            frozenStacks = FROZEN_THRESHOLD
            isFrozen = true
            return
        end
        
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid then
            local walkSpeed = humanoid.WalkSpeed
            if walkSpeed <= 2 then
                frozenStacks = FROZEN_THRESHOLD
                isFrozen = true
                return
            elseif walkSpeed < 10 then
                frozenStacks = math.clamp(math.floor(((16 - walkSpeed) / 14) * 10), 1, 10)
                isFrozen = frozenStacks >= FROZEN_THRESHOLD
                return
            end
        end
        
        updateDescendantCache(char)
        
        local hasFullIceParticles = 0
        local frostEffects = 0
        
        for _, child in ipairs(cachedDescendants) do
            if not child.Parent then continue end 
            
            if child:IsA("ParticleEmitter") then
                local nameLower = child.Name:lower()
                if nameLower:match("[ice|frost|snow]") then
                    hasFullIceParticles = hasFullIceParticles + 1
                    if hasFullIceParticles >= 5 then
                        frozenStacks = FROZEN_THRESHOLD
                        isFrozen = true
                        return
                    end
                end
            
            elseif child:IsA("BasePart") then
                local material = child.Material
                if material == Enum.Material.Ice or material == Enum.Material.Snow then
                    frostEffects = frostEffects + 2
                end
                
                local color = child.Color
                if color.r < 0.4 and color.b > 0.7 then
                    frostEffects = frostEffects + 1
                end
            
            elseif child:IsA("Decal") then
                local textureLower = child.Texture:lower()
                if textureLower:match("[ice|frost]") then
                    frostEffects = frostEffects + 3
                end
            end
            
            if frostEffects >= 10 then
                frozenStacks = FROZEN_THRESHOLD
                isFrozen = true
                return
            end
        end
        
        if frostEffects >= 8 then
            frozenStacks = 9
            isFrozen = false
        else
            frozenStacks = math.floor(frostEffects / 2)
            isFrozen = false
        end
    end

    local function setupStackMonitoring()
        if frozenCheckConnection then return end 
        
        frozenCheckConnection = runService.Heartbeat:Connect(function()
            if not entitylib.isAlive then
                frozenStacks = 0
                isFrozen = false
                return
            end
            
            local now = tick()
            if now - lastCheckTime < CHECK_INTERVAL then
                return
            end
            lastCheckTime = now
            
            local char = entitylib.character.Character
            
            local newStacks = char:GetAttribute("ColdStacks") or 
                             char:GetAttribute("FrostStacks") or 
                             char:GetAttribute("FreezeStacks") or 
                             char:GetAttribute("FROZEN_STACKS")
            
            if newStacks and newStacks > 0 then
                frozenStacks = newStacks
                isFrozen = frozenStacks >= FROZEN_THRESHOLD
                return
            end
            
            checkFrozenStatus()
        end)
    end
    
    local NoSlowdown = vape.Categories.Blatant:CreateModule({
        Name = 'NoSlowdown',
        Function = function(callback)
            local modifier = bedwars.SprintController:getMovementStatusModifier()
            if callback then
                if SophiaCheck and SophiaCheck.Enabled then
                    checkFrozenStatus()
                    setupStackMonitoring()
                end
                
                old = modifier.addModifier
                modifier.addModifier = function(self, tab)
                    if SophiaCheck and SophiaCheck.Enabled and isFrozen then
                        return old(self, tab)
                    end
                    
                    if tab.moveSpeedMultiplier then
                        tab.moveSpeedMultiplier = math.max(tab.moveSpeedMultiplier, 1)
                    end
                    return old(self, tab)
                end
    
                for i in modifier.modifiers do
                    if (i.moveSpeedMultiplier or 1) < 1 then
                        modifier:removeModifier(i)
                    end
                end
            else
                if frozenCheckConnection then
                    frozenCheckConnection:Disconnect()
                    frozenCheckConnection = nil
                end
                frozenStacks = 0
                isFrozen = false
                cachedDescendants = {}
                lastCheckTime = 0
                lastDescendantUpdate = 0
                
                modifier.addModifier = old
                old = nil
            end
        end,
        Tooltip = 'Prevents slowing down when using items.'
    })
    
    SophiaCheck = NoSlowdown:CreateToggle({
        Name = 'Sophia Check',
        Tooltip = 'Allows slowdown ONLY when completely frozen',
        Function = function(callback)
            if callback then
                if NoSlowdown.Enabled then
                    setupStackMonitoring()
                    checkFrozenStatus()
                end
            else
                if frozenCheckConnection then
                    frozenCheckConnection:Disconnect()
                    frozenCheckConnection = nil
                end
                frozenStacks = 0
                isFrozen = false
                cachedDescendants = {}
                lastCheckTime = 0
                lastDescendantUpdate = 0
            end
        end,
        Default = false
    })
end)

run(function()
    local VanessaCharger
    local ChargeDelay
    local DelaySlider
    
    local oldGetChargeTime
    local lastChargeTime = 0
    
    VanessaCharger = vape.Categories.Blatant:CreateModule({
        Name = 'VanessaCharger',
        Function = function(callback)
            if callback then
                task.spawn(function()
                    repeat task.wait() until bedwars.TripleShotProjectileController
                    
                    if bedwars.TripleShotProjectileController then
                        oldGetChargeTime = bedwars.TripleShotProjectileController.getChargeTime
                        
                        bedwars.TripleShotProjectileController.getChargeTime = function(self)
                            local currentTime = tick()
                            if ChargeDelay.Enabled then
                                local delayAmount = DelaySlider.Value
                                if currentTime - lastChargeTime < delayAmount then
                                    return oldGetChargeTime(self)
                                end
                            end
                            
                            lastChargeTime = currentTime
                            return 0
                        end
                        
                        bedwars.TripleShotProjectileController.overchargeStartTime = tick()
                    end
                end)
            else
                if oldGetChargeTime and bedwars.TripleShotProjectileController then
                    bedwars.TripleShotProjectileController.getChargeTime = oldGetChargeTime
                end
                lastChargeTime = 0
            end
        end,
        Tooltip = 'Auto charges Vanessa triple shot\nMakes arrows instant charge'
    })
    
    ChargeDelay = VanessaCharger:CreateToggle({
        Name = 'Charge Delay',
        Default = true,
        Tooltip = 'Add delay between auto charges',
        Function = function(callback)
            if DelaySlider and DelaySlider.Object then
                DelaySlider.Object.Visible = callback
            end
        end
    })
    
    DelaySlider = VanessaCharger:CreateSlider({
        Name = 'Delay',
        Min = 0,
        Max = 5,
        Default = 0.5,
        Decimal = 10,
        Suffix = 's',
        Visible = true,
        Tooltip = 'Delay in seconds between charges (0 = instant spam)'
    })
    
    task.spawn(function()
        repeat task.wait() until VanessaCharger.Object and VanessaCharger.Object.Parent
        task.wait(0.05)
        if ChargeDelay.Enabled and DelaySlider and DelaySlider.Object then
            DelaySlider.Object.Visible = true
        elseif DelaySlider and DelaySlider.Object then
            DelaySlider.Object.Visible = false
        end
    end)
end)

run(function()
	local PAMode
	local TargetPart
	local Targets
	local TargetPots
	local FOV
	local Range
	local OtherProjectiles
	local Blacklist
	local TargetVisualiser
	local DesirePAHideCursor
	local DesirePACursorViewMode
	local DesirePACursorLimitBow
	local DesirePACursorShowGUI
	local DesirePAWorkMode
	local AeroPATargetPriority
	local AeroPAHealthMode
	local AeroPAArmorMode
	local AeroPAChargePercent 
	local rayCheck = RaycastParams.new()
	rayCheck.FilterType = Enum.RaycastFilterType.Include
	rayCheck.FilterDescendantsInstances = {workspace:FindFirstChild('Map') or workspace}
	local old
	local math_sqrt = math.sqrt
	local math_abs = math.abs
	local math_min = math.min
	local math_max = math.max
	local math_cos = math.cos
	local math_rad = math.rad
	local cachedPots = {}
	local lastPotScan = 0
	local POT_SCAN_INTERVAL = 2
	local armors = {
		'none',
		'leather_chestplate',
		'iron_chestplate',
		'diamond_chestplate',
		'emerald_chestplate'
	}
	
	local aerov4bad = {
		predictStrafingMovement = function(targetPlayer, targetPart, projSpeed, gravity, origin)
			if not targetPlayer or not targetPlayer.Character or not targetPart then
				return targetPart and targetPart.Position or Vector3.zero
			end

			local currentPos = targetPart.Position
			local currentVel = targetPart.Velocity
			local distance = (currentPos - origin).Magnitude

			local baseTimeToTarget = distance / projSpeed

			local timeMultiplier = 1.0
			if distance > 80 then
				timeMultiplier = 0.95
			elseif distance > 50 then
				timeMultiplier = 0.98
			elseif distance < 20 then
				timeMultiplier = 1.08
			end

			local timeToTarget = baseTimeToTarget * timeMultiplier

			local horizontalPredictionStrength = 0.80
			if distance > 70 then
				horizontalPredictionStrength = 0.70
			elseif distance > 40 then
				horizontalPredictionStrength = 0.75
			elseif distance < 25 then
				horizontalPredictionStrength = 0.88
			end

			local horizontalVel = Vector3.new(currentVel.X, 0, currentVel.Z)
			local predictedHorizontal = horizontalVel * timeToTarget * horizontalPredictionStrength

			local verticalVel = currentVel.Y
			local verticalPrediction = 0

			local isJumping = verticalVel > 8
			local isFalling = verticalVel < -5
			local isPeaking = math.abs(verticalVel) <= 8 and verticalVel <= 0 and verticalVel >= -5

			if isFalling then
				local distanceFactor = math.clamp(1 - (distance - 30) / 120, 0.1, 1.0)
				local fallMultiplier = 0.18 * distanceFactor

				verticalPrediction = verticalVel * timeToTarget * fallMultiplier

			elseif isJumping then
				local jumpMultiplier = 0.28
				if distance > 60 then
					jumpMultiplier = 0.22
				elseif distance > 40 then
					jumpMultiplier = 0.25
				end
				verticalPrediction = verticalVel * timeToTarget * jumpMultiplier

			elseif isPeaking then
				verticalPrediction = -1 * timeToTarget
			else
				verticalPrediction = verticalVel * timeToTarget * 0.15
			end

			local finalPosition = currentPos + predictedHorizontal + Vector3.new(0, verticalPrediction, 0)
			local floorY = currentPos.Y - 8
			if finalPosition.Y < floorY then
				finalPosition = Vector3.new(finalPosition.X, floorY, finalPosition.Z)
			end

			return finalPosition
		end,

		smoothAim = function(currentCFrame, targetPosition, distance)
			local smoothnessFactor = 0.85
			if distance > 70 then
				smoothnessFactor = 0.75
			elseif distance > 40 then
				smoothnessFactor = 0.80
			elseif distance < 20 then
				smoothnessFactor = 0.92
			end
			return currentCFrame:Lerp(CFrame.new(currentCFrame.Position, targetPosition), smoothnessFactor)
		end
	}
	
	local function getArmorTier(player)
		if not player or not store.inventories[player] then return 0 end
		local inventory = store.inventories[player]
		local chestplate = inventory.armor and inventory.armor[5]
		if not chestplate or chestplate == 'empty' then return 1 end
		return table.find(armors, chestplate.itemType) or 1
	end

	local function HasSeed(character)
		if not character then return false end
		local seed = character:FindFirstChild("Seed")
		if seed then return true end
		for _, v in character:GetDescendants() do
			if v.Name == "Seed" then return true end
		end
		return false
	end

	local function updatePotCache()
		local currentTime = tick()
		if currentTime - lastPotScan < POT_SCAN_INTERVAL then
			return
		end
		
		lastPotScan = currentTime
		table.clear(cachedPots)
		
		local collectionService = game:GetService("CollectionService")
		local pots = collectionService:GetTagged("desert_pot")
		
		if #pots == 0 then
			for _, obj in pairs(workspace:GetDescendants()) do
				if obj:IsA("BasePart") and obj.Name == "desert_pot" then
					table.insert(cachedPots, obj)
				end
			end
		else
			cachedPots = pots
		end
	end

	local function getPotTarget(originPos)
		updatePotCache()
		
		local closestPot = nil
		local closestDistance = Range.Value
		local rangeSquared = Range.Value * Range.Value
		
		for _, obj in pairs(cachedPots) do
			if not obj or not obj.Parent then continue end
			
			local delta = obj.Position - originPos
			local distanceSquared = delta.X * delta.X + delta.Y * delta.Y + delta.Z * delta.Z
			
			if distanceSquared > rangeSquared then continue end
			
			local distance = math_sqrt(distanceSquared)
			if distance >= closestDistance then continue end
			
			local deltaFlat = Vector3.new(delta.X, 0, delta.Z)
			local localfacing = entitylib.character.RootPart.CFrame.LookVector * Vector3.new(1, 0, 1)
			local dotProduct = localfacing:Dot(deltaFlat.Unit)
			local fovThreshold = math_cos(math_rad(FOV.Value) / 2)
			
			if dotProduct >= fovThreshold then
				if Targets.Walls.Enabled then
					local ray = workspace:Raycast(originPos, delta, rayCheck)
					if not ray then
						closestPot = obj
						closestDistance = distance
					end
				else
					closestPot = obj
					closestDistance = distance
				end
			end
		end
		
		return closestPot
	end
	
	local function getAeroPATarget(originPos)
		local validTargets = {}
		local rangeSquared = Range.Value * Range.Value
		local fovThreshold = math_cos(math_rad(FOV.Value) / 2)
		
		if AeroPATargetPriority.Value == 'Forest' then
			local forestTargets = {}
			
			for _, ent in entitylib.List do
				if not Targets.Players.Enabled and ent.Player then continue end
				if not Targets.NPCs.Enabled and ent.NPC then continue end
				if not ent.Character or not ent.RootPart then continue end
				
				local partKey = (TargetPart.Value == 'Closest' or TargetPart.Value == 'Randomize') and 'RootPart' or TargetPart.Value
				local selectedPart = ent[partKey]
				if not selectedPart then selectedPart = ent.RootPart end
				if not selectedPart then continue end
				
				local delta = selectedPart.Position - originPos
				local distanceSquared = delta.X * delta.X + delta.Y * delta.Y + delta.Z * delta.Z
				if distanceSquared > rangeSquared then continue end
				
				local deltaFlat = Vector3.new(delta.X, 0, delta.Z)
				local localfacing = entitylib.character.RootPart.CFrame.LookVector * Vector3.new(1, 0, 1)
				if deltaFlat.Magnitude < 0.001 then continue end
				local dotProduct = localfacing:Dot(deltaFlat.Unit)
				if dotProduct < fovThreshold then continue end
				
				if Targets.Walls.Enabled then
					local ray = workspace:Raycast(originPos, delta, rayCheck)
					if ray then continue end
				end
				
				if HasSeed(ent.Character) then
					table.insert(forestTargets, ent)
				end
			end
			
			if #forestTargets > 0 then
				local closest, closestDist = nil, math.huge
				for _, ent in forestTargets do
					local d = (ent.RootPart.Position - originPos).Magnitude
					if d < closestDist then
						closestDist = d
						closest = ent
					end
				end
				return closest
			end
		end
		
		table.clear(validTargets)
		
		for _, ent in entitylib.List do
			if not Targets.Players.Enabled and ent.Player then continue end
			if not Targets.NPCs.Enabled and ent.NPC then continue end
			if not ent.Character or not ent.RootPart then continue end
			
			local partKey = (TargetPart.Value == 'Closest' or TargetPart.Value == 'Randomize') and 'RootPart' or TargetPart.Value
			local selectedPart = ent[partKey]
			if not selectedPart then continue end
			
			local delta = selectedPart.Position - originPos
			local distanceSquared = delta.X * delta.X + delta.Y * delta.Y + delta.Z * delta.Z
			if distanceSquared > rangeSquared then continue end
			
			local deltaFlat = Vector3.new(delta.X, 0, delta.Z)
			local localfacing = entitylib.character.RootPart.CFrame.LookVector * Vector3.new(1, 0, 1)
			local dotProduct = localfacing:Dot(deltaFlat.Unit)
			if dotProduct < fovThreshold then continue end
			
			if Targets.Walls.Enabled then
				local ray = workspace:Raycast(originPos, delta, rayCheck)
				if ray then continue end
			end
			
			table.insert(validTargets, ent)
		end
		
		if #validTargets == 0 then return nil end

		if AeroPATargetPriority.Value == 'Forest' or AeroPATargetPriority.Value == 'Distance' then
			local closest, closestDist = nil, math.huge
			for _, ent in validTargets do
				local d = (ent.RootPart.Position - originPos).Magnitude
				if d < closestDist then
					closestDist = d
					closest = ent
				end
			end
			return closest
		elseif AeroPATargetPriority.Value == 'Health' then
			table.sort(validTargets, function(a, b)
				local healthA = (a.Character:GetAttribute("Health") or a.Humanoid.Health)
				local healthB = (b.Character:GetAttribute("Health") or b.Humanoid.Health)
				
				if AeroPAHealthMode.Value == 'Lowest' then
					return healthA < healthB
				else 
					return healthA > healthB
				end
			end)
		elseif AeroPATargetPriority.Value == 'Armor' then
			table.sort(validTargets, function(a, b)
				local armorA = a.Player and getArmorTier(a.Player) or 1
				local armorB = b.Player and getArmorTier(b.Player) or 1
				
				if AeroPAArmorMode.Value == 'Weakest' then
					return armorA < armorB
				else 
					return armorA > armorB
				end
			end)
		end
		
		return validTargets[1]
	end
	
	local selectedTarget = nil
	local targetOutline = nil
	local hovering = false
	local CoreConnections = {}
	local cursorRenderConnection
	local lastGUIState = false
	local UserInputService = game:GetService("UserInputService")
	local isMobile = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
	
	local function isFrostStaff(tool)
		if not tool then return false end
		local toolName = tool.Name or ""
		return toolName:find("frost_staff") or toolName == "FROST_STAFF_1" or toolName == "FROST_STAFF_2" or toolName == "FROST_STAFF_3"
	end
	
	local function getFrostStaffCooldown(toolName)
		if toolName:find("frost_staff_1") then
			return 0.2  
		elseif toolName:find("frost_staff_2") then
			return 0.18 
		elseif toolName:find("frost_staff_3") then
			return 0.16 
		end
		return 0.2
	end
	
	local function isFirstPerson()
		if not (lplr.Character and lplr.Character:FindFirstChild("HumanoidRootPart")) then 
			return false 
		end
		
		local characterPos = lplr.Character.HumanoidRootPart.Position
		local cameraPos = gameCamera.CFrame.Position
		local distance = (characterPos - cameraPos).Magnitude
		
		return distance < 5 
	end
	
	local function shouldPAWork()
		if PAMode.Value ~= 'DesirePA' then return true end
		
		local inFirstPerson = isFirstPerson()
		
		if DesirePAWorkMode.Value == 'First Person' then
			return inFirstPerson
		elseif DesirePAWorkMode.Value == 'Third Person' then
			return not inFirstPerson
		elseif DesirePAWorkMode.Value == 'Both' then
			return true
		end
		
		return true
	end
	
	local function isGUIOpen()
		local guiLayers = {
			bedwars.UILayers.MAIN or 'Main',
			bedwars.UILayers.DIALOG or 'Dialog',
			bedwars.UILayers.POPUP or 'Popup'
		}
		
		for _, layerName in pairs(guiLayers) do
			if bedwars.AppController:isLayerOpen(layerName) then
				return true
			end
		end
		
		if bedwars.AppController:isAppOpen('BedwarsItemShopApp') then
			return true
		end
		
		if bedwars.Store:getState().Inventory and bedwars.Store:getState().Inventory.open then
			return true
		end
		
		return false
	end
	
	local function hasBowEquipped()
		if not store.hand or not store.hand.toolType then
			return false
		end
		
		local toolType = store.hand.toolType
		return toolType == 'bow' or toolType == 'crossbow'
	end
	
	local function hasFrostStaffEquipped()
		if not store.hand or not store.hand.tool then
			return false
		end
		return isFrostStaff(store.hand.tool)
	end
	
	local function shouldHideCursor()
		if PAMode.Value ~= 'DesirePA' or not DesirePAHideCursor.Enabled then return false end
		
		if DesirePACursorShowGUI.Enabled and isGUIOpen() then
			return false
		end
		
		if DesirePACursorLimitBow.Enabled then
			if not hasBowEquipped() and not hasFrostStaffEquipped() then
				return false
			end
		end
		
		local inFirstPerson = isFirstPerson()
		
		if DesirePACursorViewMode.Value == 'First Person' then
			return inFirstPerson
		elseif DesirePACursorViewMode.Value == 'Third Person' then
			return not inFirstPerson
		elseif DesirePACursorViewMode.Value == 'Both' then
			return true
		end
		
		return false
	end
	
	local function updateCursor()
		if shouldHideCursor() then
			pcall(function()
				inputService.MouseIconEnabled = false
			end)
		else
			pcall(function()
				inputService.MouseIconEnabled = true
			end)
		end
	end
	
	local function checkGUIState()
		local currentGUIState = isGUIOpen()
		if lastGUIState ~= currentGUIState then
			updateCursor()
			lastGUIState = currentGUIState
		end
	end

	local function updateOutline(target, isPot)
		if targetOutline then
			pcall(function()
				targetOutline:Destroy()
			end)
			targetOutline = nil
		end
		
		if target and TargetVisualiser and TargetVisualiser.Enabled then
			pcall(function()
				targetOutline = Instance.new("Highlight")
				targetOutline.FillTransparency = 1
				targetOutline.OutlineColor = isPot and Color3.fromRGB(255, 165, 0) or Color3.fromRGB(255, 0, 0)
				targetOutline.OutlineTransparency = 0
				targetOutline.Adornee = isPot and target or target.Character
				targetOutline.Parent = isPot and target or target.Character
			end)
		end
	end

	local function handlePlayerSelection()
		local function selectTarget(target)
			if not target then return end
			if target and target.Parent then
				local plr = playersService:GetPlayerFromCharacter(target.Parent)
				if plr then
					if selectedTarget == plr then
						selectedTarget = nil
						updateOutline(nil)
					else
						selectedTarget = plr
						updateOutline(plr)
					end
				end
			end
		end
		
		local con
		if isMobile then
			con = UserInputService.TouchTapInWorld:Connect(function(touchPos)
				if not hovering then updateOutline(nil); return end
				if not ProjectileAimbot.Enabled then pcall(function() con:Disconnect() end); updateOutline(nil); return end
				local ray = workspace.CurrentCamera:ScreenPointToRay(touchPos.X, touchPos.Y)
				local result = workspace:Raycast(ray.Origin, ray.Direction * 1000)
				if result and result.Instance then
					selectTarget(result.Instance)
				end
			end)
			table.insert(CoreConnections, con)
		end
	end
	
	local function updateOptionsVisibility()
		local mode = PAMode.Value
		
		if DesirePAHideCursor then
			DesirePAHideCursor.Object.Visible = (mode == 'DesirePA')
		end
		if DesirePACursorViewMode then
			DesirePACursorViewMode.Object.Visible = (mode == 'DesirePA')
		end
		if DesirePACursorLimitBow then
			DesirePACursorLimitBow.Object.Visible = (mode == 'DesirePA')
		end
		if DesirePACursorShowGUI then
			DesirePACursorShowGUI.Object.Visible = (mode == 'DesirePA')
		end
		if DesirePAWorkMode then
			DesirePAWorkMode.Object.Visible = (mode == 'DesirePA')
		end
		
		if AeroPATargetPriority then
			AeroPATargetPriority.Object.Visible = (mode == 'AeroPA')
		end
		if AeroPAHealthMode then
			AeroPAHealthMode.Object.Visible = (mode == 'AeroPA' and AeroPATargetPriority.Value == 'Health')
		end
		if AeroPAArmorMode then
			AeroPAArmorMode.Object.Visible = (mode == 'AeroPA' and AeroPATargetPriority.Value == 'Armor')
		end
		if AeroPAChargePercent then
			AeroPAChargePercent.Object.Visible = (mode == 'AeroPA')
		end
	end
	
	local ProjectileAimbot
	
	ProjectileAimbot = vape.Categories.Blatant:CreateModule({
		Name = 'ProjectileAimbot',
		Function = function(callback)
			if callback then
				if PAMode.Value == 'DesirePA' and DesirePAHideCursor.Enabled and not cursorRenderConnection then
					cursorRenderConnection = runService.RenderStepped:Connect(function()
						checkGUIState()
						updateCursor()
					end)
				end

				handlePlayerSelection()
				
				old = bedwars.ProjectileController.calculateImportantLaunchValues
				bedwars.ProjectileController.calculateImportantLaunchValues = function(...)
					hovering = true
					local self, projmeta, worldmeta, origin, shootpos = ...
					local originPos = entitylib.isAlive and (shootpos or entitylib.character.RootPart.Position) or Vector3.zero
					
					local plr
					local targetingPot = false
					local potTarget = nil

					if selectedTarget and selectedTarget.Character and selectedTarget.Character.PrimaryPart then
						local dist = (selectedTarget.Character.PrimaryPart.Position - originPos).Magnitude
						if dist <= Range.Value then
							if PAMode.Value == 'AeroPA' and AeroPATargetPriority.Value == 'Forest' and not HasSeed(selectedTarget.Character) then
								selectedTarget = nil
								updateOutline(nil)
							else
								plr = selectedTarget
							end
						else
							selectedTarget = nil
							updateOutline(nil)
						end
					end
					
					if not plr then
						if TargetPots.Enabled then
							potTarget = getPotTarget(originPos)
							if potTarget then
								targetingPot = true
							end
						end
						
						if not targetingPot then
							if PAMode.Value == 'AeroPA' and AeroPATargetPriority.Value ~= 'Distance' then
								plr = getAeroPATarget(originPos)
							else
								local entityPart = (TargetPart.Value == 'Closest' or TargetPart.Value == 'Randomize') and 'RootPart' or TargetPart.Value
								plr = entitylib.EntityMouse({
									Part = entityPart,
									Range = FOV.Value,
									Players = Targets.Players.Enabled,
									NPCs = Targets.NPCs.Enabled,
									Wallcheck = Targets.Walls.Enabled,
									Origin = originPos
								})
							end
						end
					end
					
					if targetingPot then
						updateOutline(potTarget, true)
					elseif plr then
						updateOutline(plr, false)
					else
						updateOutline(nil)
					end
					
					if not shouldPAWork() then
						hovering = false
						return old(...)
					end
					
					if targetingPot and potTarget then
						local pos = shootpos or self:getLaunchPosition(origin)
						if not pos then
							hovering = false
							return old(...)
						end
						
						local meta = projmeta:getProjectileMeta()
						local lifetime = (worldmeta and meta.predictionLifetimeSec or meta.lifetimeSec or 3)
						local gravity = (meta.gravitationalAcceleration or 196.2) * projmeta.gravityMultiplier
						local projSpeed = (meta.launchVelocity or 100)
						local offsetpos = pos + projmeta.fromPositionOffset
						
						local targetPos = potTarget.Position + Vector3.new(0, 1.2, 0)
						local newlook = CFrame.new(offsetpos, targetPos)
						
						hovering = false
						return {
							initialVelocity = newlook.LookVector * projSpeed,
							positionFrom = offsetpos,
							deltaT = lifetime,
							gravitationalAcceleration = gravity,
							drawDurationSeconds = 5
						}
					
					elseif plr and plr.Character then
						local targetBodyPart = nil

						local partsList = {
							'HumanoidRootPart', 'Head', 'LeftHand', 'RightHand',
							'LeftLowerArm', 'RightLowerArm', 'LeftUpperArm', 'RightUpperArm',
							'LeftFoot', 'RightFoot', 'LeftLowerLeg', 'RightLowerLeg',
							'LeftUpperLeg', 'RightUpperLeg', 'LowerTorso', 'UpperTorso'
						}

						if TargetPart.Value == 'Closest' then
							local mousePos = inputService:GetMouseLocation()
							local viewportSize = gameCamera.ViewportSize
							local mouseRay = gameCamera:ViewportPointToRay(mousePos.X, mousePos.Y, 0)
							local closestAngle = math.huge

							for _, partName in partsList do
								local part = plr.Character:FindFirstChild(partName)
								if part then
									local dirTopart = (part.Position - mouseRay.Origin).Unit
									local angle = math.acos(math.clamp(mouseRay.Direction:Dot(dirTopart), -1, 1))
									if angle < closestAngle then
										closestAngle = angle
										targetBodyPart = part
									end
								end
							end
							if not targetBodyPart then
								targetBodyPart = plr.RootPart
							end

						elseif TargetPart.Value == 'Randomize' then
							local validParts = {}
							for _, partName in partsList do
								local part = plr.Character:FindFirstChild(partName)
								if part then
									table.insert(validParts, part)
								end
							end
							targetBodyPart = #validParts > 0 and validParts[math.random(1, #validParts)] or plr.RootPart

						elseif TargetPart.Value == 'Head' then
							targetBodyPart = plr.Character:FindFirstChild('Head') or plr.Head
						elseif TargetPart.Value == 'RootPart' then
							targetBodyPart = plr.Character:FindFirstChild('HumanoidRootPart') or plr.RootPart
						else
							targetBodyPart = plr[TargetPart.Value]
						end

						if not targetBodyPart then
							targetBodyPart = plr.RootPart
						end
						
						if not targetBodyPart then
							hovering = false
							return old(...)
						end
						
						local dist = (targetBodyPart.Position - originPos).Magnitude
						if dist > Range.Value then
							hovering = false
							return old(...)
						end
						
						local pos = shootpos or self:getLaunchPosition(origin)
						if not pos then
							hovering = false
							return old(...)
						end
	
						local isFrostStaffProjectile = false
						if projmeta and projmeta.projectile then
							isFrostStaffProjectile = projmeta.projectile:find("frosty_snowball") ~= nil
						end
						
						local usingFrostStaff = false
						local frostStaffTier = 0
						if store.hand and store.hand.tool then
							usingFrostStaff = isFrostStaff(store.hand.tool)
							if usingFrostStaff then
								isFrostStaffProjectile = true
								local toolName = store.hand.tool.Name
								if toolName:find("frost_staff_2") then
									frostStaffTier = 2
								elseif toolName:find("frost_staff_3") then
									frostStaffTier = 3
								else
									frostStaffTier = 1
								end
							end
						end

						local isTurretProjectile = projmeta.projectile:find('turret') ~= nil or projmeta.projectile:find('vulcan') ~= nil

						if (not OtherProjectiles.Enabled) and not projmeta.projectile:find('arrow') and not isFrostStaffProjectile and not isTurretProjectile then
							hovering = false
							return old(...)
						end

						if table.find(Blacklist.ListEnabled, projmeta.projectile) then
							hovering = false
							return old(...)
						end
	
						local meta = projmeta:getProjectileMeta()
						local lifetime = (worldmeta and meta.predictionLifetimeSec or meta.lifetimeSec or 3)
						local gravity = (meta.gravitationalAcceleration or 196.2) * projmeta.gravityMultiplier
						local projSpeed = (meta.launchVelocity or 100)
						local offsetpos = pos + (projmeta.projectile == 'owl_projectile' and Vector3.zero or projmeta.fromPositionOffset)
						local balloons = plr.Character:GetAttribute('InflatedBalloons')
						local playerGravity = workspace.Gravity
	
						if balloons and balloons > 0 then
							playerGravity = workspace.Gravity * (1 - (balloons >= 4 and 1.2 or balloons >= 3 and 1 or 0.975))
						end
	
						if plr.Character.PrimaryPart:FindFirstChild('rbxassetid://8200754399') then
							playerGravity = 6
						end

						if plr.Player and plr.Player:GetAttribute('IsOwlTarget') then
							for _, owl in collectionService:GetTagged('Owl') do
								if owl:GetAttribute('Target') == plr.Player.UserId and owl:GetAttribute('Status') == 2 then
									playerGravity = 0
									break
								end
							end
						end
						
						if PAMode.Value == 'SavyPA' then
							local newlook = CFrame.new(offsetpos, targetBodyPart.Position) * CFrame.new(projmeta.projectile == 'owl_projectile' and Vector3.zero or Vector3.new(bedwars.BowConstantsTable.RelX, bedwars.BowConstantsTable.RelY, bedwars.BowConstantsTable.RelZ))
							local calc = prediction.SolveTrajectory(
								newlook.p, 
								projSpeed, 
								gravity, 
								targetBodyPart.Position,  
								projmeta.projectile == 'telepearl' and Vector3.zero or targetBodyPart.Velocity, 
								playerGravity, 
								plr.HipHeight, 
								plr.Jumping and 42.6 or nil, 
								rayCheck
							)
							
							if calc then
								if targetinfo and targetinfo.Targets then
									targetinfo.Targets[plr] = tick() + 1
								end
								
								hovering = false
								return {
									initialVelocity = CFrame.new(newlook.Position, calc).LookVector * projSpeed,
									positionFrom = offsetpos,
									deltaT = lifetime,
									gravitationalAcceleration = gravity,
									drawDurationSeconds = 5
								}
							end
						
						elseif PAMode.Value == 'AeroPA' then
							local distance = (targetBodyPart.Position - offsetpos).Magnitude
							local rawLook = CFrame.new(offsetpos, targetBodyPart.Position)
							
							local predictedPosition = aerov4bad.predictStrafingMovement(
								plr.Player,
								targetBodyPart, 
								projSpeed,
								gravity,
								offsetpos
							)
							
							local newlook = aerov4bad.smoothAim(rawLook, predictedPosition, distance)
							
							if projmeta.projectile ~= 'owl_projectile' then
								newlook = newlook * CFrame.new(
									bedwars.BowConstantsTable.RelX or 0,
									bedwars.BowConstantsTable.RelY or 0,
									bedwars.BowConstantsTable.RelZ or 0
								)
							end
							
							local targetVelocity = projmeta.projectile == 'telepearl' and Vector3.zero or targetBodyPart.Velocity
							
							local calc = prediction.SolveTrajectory(
								newlook.p,
								projSpeed,
								gravity,
								predictedPosition,
								targetVelocity,
								playerGravity,
								plr.HipHeight,
								plr.Jumping and 50 or nil,
								rayCheck
							)
							
							if calc then
								if targetinfo and targetinfo.Targets then
									targetinfo.Targets[plr] = tick() + 1
								end
								
								local customDrawDuration = 0.58 * (AeroPAChargePercent.Value / 100)
								
								if usingFrostStaff then
									customDrawDuration = getFrostStaffCooldown(store.hand.tool.Name)
									customDrawDuration = customDrawDuration * (AeroPAChargePercent.Value / 100)
								end
								
								local finalDirection = (calc - newlook.p).Unit
								local angleFromHorizontal = math.acos(math.clamp(finalDirection:Dot(Vector3.new(0, 1, 0)), -1, 1))
								
								local minAngle = math.rad(1)
								local maxAngle = math.rad(179)
								
								if angleFromHorizontal > minAngle and angleFromHorizontal < maxAngle then
									hovering = false
									return {
										initialVelocity = finalDirection * projSpeed,
										positionFrom = offsetpos,
										deltaT = lifetime,
										gravitationalAcceleration = gravity,
										drawDurationSeconds = customDrawDuration
									}
								end
							end
						else
							local newlook = CFrame.new(offsetpos, targetBodyPart.Position) * CFrame.new(projmeta.projectile == 'owl_projectile' and Vector3.zero or Vector3.new(bedwars.BowConstantsTable.RelX, bedwars.BowConstantsTable.RelY, bedwars.BowConstantsTable.RelZ))
							local calc = prediction.SolveTrajectory(
								newlook.p, 
								projSpeed, 
								gravity, 
								targetBodyPart.Position,  
								projmeta.projectile == 'telepearl' and Vector3.zero or targetBodyPart.Velocity, 
								playerGravity, 
								plr.HipHeight, 
								plr.Jumping and 42.6 or nil, 
								rayCheck
							)
							
							if calc then
								if targetinfo and targetinfo.Targets then
									targetinfo.Targets[plr] = tick() + 1
								end
								
								local customDrawDuration = 5
								if PAMode.Value == 'AeroPA' and AeroPAChargePercent then
									customDrawDuration = 0.58 * (AeroPAChargePercent.Value / 100)
								end
								
								if usingFrostStaff then
									customDrawDuration = getFrostStaffCooldown(store.hand.tool.Name)
									if PAMode.Value == 'AeroPA' and AeroPAChargePercent then
										customDrawDuration = customDrawDuration * (AeroPAChargePercent.Value / 100)
									end
								end
								
								hovering = false
								return {
									initialVelocity = CFrame.new(newlook.Position, calc).LookVector * projSpeed,
									positionFrom = offsetpos,
									deltaT = lifetime,
									gravitationalAcceleration = gravity,
									drawDurationSeconds = customDrawDuration
								}
							end
						end
					end
	
					hovering = false
					return old(...)
				end
			else
				bedwars.ProjectileController.calculateImportantLaunchValues = old
				if targetOutline then
					pcall(function()
						targetOutline:Destroy()
					end)
					targetOutline = nil
				end
				selectedTarget = nil
				for i,v in pairs(CoreConnections) do
					pcall(function() v:Disconnect() end)
				end
				table.clear(CoreConnections)
				
				if cursorRenderConnection then
					cursorRenderConnection:Disconnect()
					cursorRenderConnection = nil
				end
				
				pcall(function()
					inputService.MouseIconEnabled = true
				end)
			end
		end,
		Tooltip = 'Silently adjusts your aim towards the enemy'
	})
	
	PAMode = ProjectileAimbot:CreateDropdown({
		Name = 'PA Mode',
		List = {'Vape', 'AeroPA', 'DesirePA', 'SavyPA'},
		Default = 'Vape',
		Tooltip = 'Select prediction algorithm',
		Function = function()
			updateOptionsVisibility()
		end
	})
	
	Targets = ProjectileAimbot:CreateTargets({
		Players = true,
		Walls = true
	})
	TargetPart = ProjectileAimbot:CreateDropdown({
		Name = 'Part',
		List = {'RootPart', 'Head', 'Closest', 'Randomize'},
		Default = 'RootPart',
		Tooltip = 'Select which body part to aim at'
	})
	FOV = ProjectileAimbot:CreateSlider({
		Name = 'FOV',
		Min = 1,
		Max = 1000,
		Default = 1000
	})
	Range = ProjectileAimbot:CreateSlider({
		Name = 'Range',
		Min = 10,
		Max = 500,
		Default = 100,
		Tooltip = 'Maximum distance for target locking'
	})
	TargetVisualiser = ProjectileAimbot:CreateToggle({
		Name = "Target Visualiser", 
		Default = true,
		Function = function(callback)
			if not callback then
				updateOutline(nil)
			end
		end
	})
	OtherProjectiles = ProjectileAimbot:CreateToggle({
		Name = 'Other Projectiles',
		Default = true,
		Function = function(call)
			if Blacklist then
				Blacklist.Object.Visible = call
			end
		end
	})
	Blacklist = ProjectileAimbot:CreateTextList({
		Name = 'Blacklist',
		Darker = true,
		Default = {'telepearl'}
	})
	
	DesirePAWorkMode = ProjectileAimbot:CreateDropdown({
		Name = 'PA Work Mode',
		List = {'First Person', 'Third Person', 'Both'},
		Default = 'Both'
	})
	
	DesirePAHideCursor = ProjectileAimbot:CreateToggle({
		Name = 'Hide Cursor',
		Default = false,
		Function = function(callback)
			if callback and ProjectileAimbot.Enabled and PAMode.Value == 'DesirePA' then
				if not cursorRenderConnection then
					cursorRenderConnection = runService.RenderStepped:Connect(function()
						checkGUIState()
						updateCursor()
					end)
				end
				updateCursor()
			else
				if cursorRenderConnection then
					cursorRenderConnection:Disconnect()
					cursorRenderConnection = nil
				end
				pcall(function()
					inputService.MouseIconEnabled = true
				end)
			end
		end
	})
	
	DesirePACursorViewMode = ProjectileAimbot:CreateDropdown({
		Name = 'Cursor View Mode',
		List = {'First Person', 'Third Person', 'Both'},
		Default = 'First Person',
		Darker = true,
		Function = function()
			if ProjectileAimbot.Enabled and DesirePAHideCursor.Enabled and PAMode.Value == 'DesirePA' then
				updateCursor()
			end
		end
	})
	
	DesirePACursorLimitBow = ProjectileAimbot:CreateToggle({
		Name = 'Limit to Bow',
		Darker = true,
		Function = function()
			if ProjectileAimbot.Enabled and DesirePAHideCursor.Enabled and PAMode.Value == 'DesirePA' then
				updateCursor()
			end
		end
	})
	
	DesirePACursorShowGUI = ProjectileAimbot:CreateToggle({
		Name = 'Show on GUI',
		Darker = true,
		Function = function()
			if ProjectileAimbot.Enabled and DesirePAHideCursor.Enabled and PAMode.Value == 'DesirePA' then
				updateCursor()
			end
		end
	})
	
	AeroPATargetPriority = ProjectileAimbot:CreateDropdown({
		Name = 'Target Priority',
		List = {'Distance', 'Health', 'Armor', 'Forest'},
		Default = 'Distance',
		Tooltip = 'How to prioritize targets',
		Function = function()
			updateOptionsVisibility()
		end
	})
	
	AeroPAHealthMode = ProjectileAimbot:CreateDropdown({
		Name = 'Health Mode',
		List = {'Lowest', 'Highest'},
		Default = 'Lowest',
		Darker = true,
		Tooltip = 'Target lowest or highest health players'
	})
	
	AeroPAArmorMode = ProjectileAimbot:CreateDropdown({
		Name = 'Armor Mode',
		List = {'Weakest', 'Strongest'},
		Default = 'Weakest',
		Darker = true,
		Tooltip = 'Target weakest or strongest armored players'
	})
	TargetPots = ProjectileAimbot:CreateToggle({
		Name = 'Desert Pots',
		Default = false,
		Tooltip = 'Target desert pots'
	})
	AeroPAChargePercent = ProjectileAimbot:CreateSlider({
		Name = 'Charge Percent',
		Min = 1,
		Max = 100,
		Default = 100,
		Darker = true,
		Tooltip = 'Control bow charge percentage (affects damage): 100% = full damage, 50% = half damage, etc.'
	})
	
	updateOptionsVisibility()
	
	vape:Clean(vapeEvents.InventoryChanged.Event:Connect(function()
		if ProjectileAimbot.Enabled and DesirePAHideCursor.Enabled and PAMode.Value == 'DesirePA' then
			updateCursor()
		end
	end))
end)
	
local function isFirstPerson()
	if not (lplr.Character and lplr.Character:FindFirstChild("Head")) then return false end
	local dx = lplr.Character.Head.Position.X - gameCamera.CFrame.Position.X
	local dy = lplr.Character.Head.Position.Y - gameCamera.CFrame.Position.Y
	local dz = lplr.Character.Head.Position.Z - gameCamera.CFrame.Position.Z
	return (dx * dx + dy * dy + dz * dz) < 4 
end

run(function()
	local shooting, old = false
	local AutoShootInterval
	local AutoShootSwitchSpeed
	local AutoShootRange
	local AutoShootFOV
	local AutoShootWaitDelay
	local lastAutoShootTime = 0
	local autoShootEnabled = false
	local KillauraTargetCheck
	local FirstPersonCheck
	
	_G.autoShootLock = _G.autoShootLock or false

	local VirtualInputManager = game:GetService("VirtualInputManager")
	
	local cachedBows = {}
	local cachedSwordSlot = nil
	local cachedHasArrows = false
	local lastInventoryUpdate = 0
	local INVENTORY_CACHE_TIME = 0.5
	local lastTargetCheck = 0
	local lastTargetResult = false
	local TARGET_CHECK_INTERVAL = 0.15
	
	local math_acos = math.acos
	local math_rad = math.rad
	local tick = tick
	
	local function leftClick()
		pcall(function()
			VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
			task.wait(0.05)
			VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
		end)
	end
	
	local function updateInventoryCache()
		local now = tick()
		if now - lastInventoryUpdate < INVENTORY_CACHE_TIME then
			return
		end
		lastInventoryUpdate = now
		
		local arrowItem = getItem('arrow')
		cachedHasArrows = arrowItem and arrowItem.amount > 0
		
		table.clear(cachedBows)
		cachedSwordSlot = nil
		
		local hotbar = store.inventory.hotbar
		for i = 1, #hotbar do
			local v = hotbar[i]
			if v.item and v.item.itemType then
				local itemMeta = bedwars.ItemMeta[v.item.itemType]
				if itemMeta then
					if itemMeta.projectileSource then
						local projectileSource = itemMeta.projectileSource
						if projectileSource.ammoItemTypes and table.find(projectileSource.ammoItemTypes, 'arrow') then
							table.insert(cachedBows, i - 1)
						end
					end
					if itemMeta.sword and not cachedSwordSlot then
						cachedSwordSlot = i - 1
					end
				end
			end
		end
	end
	
	local function hasArrows()
		updateInventoryCache()
		return cachedHasArrows
	end
	
	local function getBows()
		updateInventoryCache()
		return cachedBows
	end
	
	local function getSwordSlot()
		updateInventoryCache()
		return cachedSwordSlot
	end
	
	local function hasValidTarget()
		if KillauraTargetCheck.Enabled then
			return store.KillauraTarget ~= nil
		end
		
		local now = tick()
		if now - lastTargetCheck < TARGET_CHECK_INTERVAL then
			return lastTargetResult
		end
		lastTargetCheck = now
		
		if not entitylib.isAlive then 
			lastTargetResult = false
			return false 
		end
		
		local myPos = entitylib.character.RootPart.Position
		local myLook = entitylib.character.RootPart.CFrame.LookVector
		local rangeSquared = AutoShootRange.Value * AutoShootRange.Value
		local fovRad = math_rad(AutoShootFOV.Value)
		local myTeam = lplr:GetAttribute('Team')
		
		for _, entity in entitylib.List do
			if entity.Player == lplr then continue end
			if not entity.Character then continue end
			
			local rootPart = entity.RootPart
			if not rootPart then continue end
			
			if entity.Player then
				if myTeam == entity.Player:GetAttribute('Team') then
					continue
				end
			else
				if not entity.Targetable then
					continue
				end
			end
			
			local pos = rootPart.Position
			local dx = pos.X - myPos.X
			local dy = pos.Y - myPos.Y
			local dz = pos.Z - myPos.Z
			local distanceSquared = dx * dx + dy * dy + dz * dz
			
			if distanceSquared > rangeSquared then continue end
			
			local distance = math.sqrt(distanceSquared)
			if distance < 0.01 then 
				lastTargetResult = true
				return true 
			end
			
			local toTargetX = dx / distance
			local toTargetY = dy / distance
			local toTargetZ = dz / distance
			local dot = myLook.X * toTargetX + myLook.Y * toTargetY + myLook.Z * toTargetZ
			local angle = math_acos(math.max(-1, math.min(1, dot)))
			
			if angle <= fovRad then
				lastTargetResult = true
				return true
			end
		end
		
		lastTargetResult = false
		return false
	end
	
	local AutoShoot = vape.Categories.Utility:CreateModule({
		Name = 'AutoShoot',
		Function = function(callback)
			if callback then
				autoShootEnabled = true
				
				lastInventoryUpdate = 0
				updateInventoryCache()
				
				old = bedwars.ProjectileController.createLocalProjectile
				bedwars.ProjectileController.createLocalProjectile = function(...)
					local source, data, proj = ...
					if source and proj and (proj == 'arrow' or bedwars.ProjectileMeta[proj] and bedwars.ProjectileMeta[proj].combat) and not _G.autoShootLock then
						task.spawn(function()
							if not hasArrows() then
								return
							end
							
							if FirstPersonCheck.Enabled and not isFirstPerson() then
								return
							end
							
							if KillauraTargetCheck.Enabled then
								if not store.KillauraTarget then
									return
								end
							else
								if not hasValidTarget() then
									return
								end
							end
							
							local bows = getBows()
							if #bows > 0 then
								_G.autoShootLock = true
								task.wait(AutoShootWaitDelay.Value)
								local selected = store.inventory.hotbarSlot
								for i = 1, #bows do
									local v = bows[i]
									if hotbarSwitch(v) then
										task.wait(0.05)
										leftClick()
										task.wait(0.05)
									end
								end
								hotbarSwitch(selected)
								_G.autoShootLock = false
							end
						end)
					end
					return old(...)
				end
				
				task.spawn(function()
					repeat
						task.wait(0.15) 
						if autoShootEnabled and not _G.autoShootLock then
							if not hasArrows() then
								continue
							end
							
							if FirstPersonCheck.Enabled and not isFirstPerson() then
								continue
							end
							
							local hasTarget = false
							if KillauraTargetCheck.Enabled then
								hasTarget = store.KillauraTarget ~= nil
							else
								hasTarget = hasValidTarget()
							end
							
							if not hasTarget then
								continue
							end
							
							local currentTime = tick()
							if (currentTime - lastAutoShootTime) >= AutoShootInterval.Value then
								local bows = getBows()
								
								if #bows > 0 then
									_G.autoShootLock = true
									lastAutoShootTime = currentTime
									local originalSlot = store.inventory.hotbarSlot
									
									for i = 1, #bows do
										local bowSlot = bows[i]
										if hotbarSwitch(bowSlot) then
											task.wait(AutoShootSwitchSpeed.Value)
											leftClick()
											task.wait(0.05)
										end
									end
									
									local swordSlot = getSwordSlot()
									if swordSlot then
										hotbarSwitch(swordSlot)
									else
										hotbarSwitch(originalSlot)
									end
									
									_G.autoShootLock = false
								end
							end
						end
					until not autoShootEnabled
				end)
			else
				autoShootEnabled = false
				if old then
					bedwars.ProjectileController.createLocalProjectile = old
				end
				_G.autoShootLock = false
				
				table.clear(cachedBows)
				cachedSwordSlot = nil
				cachedHasArrows = false
				lastInventoryUpdate = 0
			end
		end,
		Tooltip = 'Automatically switches to bows and shoots them'
	})
	
	AutoShootInterval = AutoShoot:CreateSlider({
		Name = 'Shoot Interval',
		Min = 0.1,
		Max = 3,
		Default = 0.5,
		Decimal = 10,
		Suffix = function(val)
			return val == 1 and 'second' or 'seconds'
		end,
		Tooltip = 'How often to auto-shoot bows'
	})
	
	AutoShootSwitchSpeed = AutoShoot:CreateSlider({
		Name = 'Switch Delay',
		Min = 0,
		Max = 0.2,
		Default = 0.05,
		Decimal = 100,
		Suffix = 's',
		Tooltip = 'Delay between switching and shooting (lower = faster)'
	})
	
	AutoShootWaitDelay = AutoShoot:CreateSlider({
		Name = 'Wait Delay',
		Min = 0,
		Max = 1,
		Default = 0,
		Decimal = 100,
		Suffix = 's',
		Tooltip = 'Delay before shooting (helps prevent ghosting)'
	})
	
	AutoShootRange = AutoShoot:CreateSlider({
		Name = 'Range',
		Min = 1,
		Max = 30,
		Default = 20,
		Suffix = function(val)
			return val == 1 and 'stud' or 'studs'
		end,
		Tooltip = 'Maximum range to auto-shoot'
	})
	
	AutoShootFOV = AutoShoot:CreateSlider({
		Name = 'FOV',
		Min = 1,
		Max = 180,
		Default = 90,
		Tooltip = 'Field of view for target detection (1-180 degrees)'
	})
	
	KillauraTargetCheck = AutoShoot:CreateToggle({
		Name = 'Require Killaura Target',
		Default = false,
		Tooltip = 'Only auto-shoot when Killaura has a target (overrides Range/FOV)'
	})
	
	FirstPersonCheck = AutoShoot:CreateToggle({
		Name = 'First Person Only',
		Default = false,
		Tooltip = 'Only works in first person mode'
	})
	
	vape:Clean(vapeEvents.InventoryChanged.Event:Connect(function()
		lastInventoryUpdate = 0
	end))
end)

run(function()
	local ProjectileAura
	local Targets
	local Range
	local List
	local HandCheck
	local FireSpeed
	local rayCheck = RaycastParams.new()
	rayCheck.FilterType = Enum.RaycastFilterType.Include
	local projectileRemote = {InvokeServer = function() end}
	local FireDelays = {}
	task.spawn(function()
		projectileRemote = bedwars.Client:Get(remotes.FireProjectile).instance
	end)
	
	local function getAmmo(check)
		for _, item in store.inventory.inventory.items do
			if check.ammoItemTypes and table.find(check.ammoItemTypes, item.itemType) then
				return item.itemType
			end
		end
	end
	
	local function getProjectiles()
		local items = {}
		for _, item in store.inventory.inventory.items do
			local proj = bedwars.ItemMeta[item.itemType].projectileSource
			local ammo = proj and getAmmo(proj)
			if ammo and table.find(List.ListEnabled, ammo) then
				table.insert(items, {
					item,
					ammo,
					proj.projectileType(ammo),
					proj
				})
			end
		end
		return items
	end
	
	ProjectileAura = vape.Categories.Blatant:CreateModule({
		Name = 'ProjectileAura',
		Function = function(callback)
			if callback then
				repeat
					local holdingCrossbow = store.hand and store.hand.tool and store.hand.tool.Name:find('crossbow')
					local holdingBow = store.hand and store.hand.tool and store.hand.tool.Name:find('bow')
					
					if HandCheck.Enabled and not holdingCrossbow and not holdingBow then
						task.wait(0.1)
						continue
					end
					
					if (workspace:GetServerTimeNow() - bedwars.SwordController.lastAttack) > 0.5 then
						local ent = entitylib.EntityPosition({
							Part = 'RootPart',
							Range = Range.Value,
							Players = Targets.Players.Enabled,
							NPCs = Targets.NPCs.Enabled,
							Wallcheck = Targets.Walls.Enabled
						})
	
						if ent then
							local pos = entitylib.character.RootPart.Position
							for _, data in getProjectiles() do
								local item, ammo, projectile, itemMeta = unpack(data)
								if (FireDelays[item.itemType] or 0) < tick() then
									rayCheck.FilterDescendantsInstances = {workspace.Map}
									local meta = bedwars.ProjectileMeta[projectile]
									local projSpeed, gravity = meta.launchVelocity, meta.gravitationalAcceleration or 196.2
									local calc = prediction.SolveTrajectory(pos, projSpeed, gravity, ent.RootPart.Position, ent.RootPart.Velocity, workspace.Gravity, ent.HipHeight, ent.Jumping and 42.6 or nil, rayCheck)
									if calc then
										targetinfo.Targets[ent] = tick() + 1
										local switched = switchItem(item.tool)
	
										task.spawn(function()
											local dir, id = CFrame.lookAt(pos, calc).LookVector, httpService:GenerateGUID(true)
											local shootPosition = (CFrame.new(pos, calc) * CFrame.new(Vector3.new(-bedwars.BowConstantsTable.RelX, -bedwars.BowConstantsTable.RelY, -bedwars.BowConstantsTable.RelZ))).Position
											
											if holdingCrossbow then
												bedwars.ViewmodelController:playAnimation(bedwars.AnimationType.FP_CROSSBOW_FIRE)
												bedwars.GameAnimationUtil:playAnimation(lplr, bedwars.AnimationType.CROSSBOW_FIRE)
											elseif holdingBow then
												bedwars.ViewmodelController:playAnimation(bedwars.AnimationType.FP_CROSSBOW_FIRE)
												bedwars.GameAnimationUtil:playAnimation(lplr, bedwars.AnimationType.BOW_FIRE)
											else
												local shootAnim = bedwars.ItemMeta[item.tool.Name].thirdPerson and bedwars.ItemMeta[item.tool.Name].thirdPerson.shootAnimation
												if shootAnim then
													bedwars.GameAnimationUtil:playAnimation(lplr, shootAnim)
												end
											end
											
											bedwars.ProjectileController:createLocalProjectile(meta, ammo, projectile, shootPosition, id, dir * projSpeed, {drawDurationSeconds = 1})
											local res = projectileRemote:InvokeServer(item.tool, ammo, projectile, shootPosition, pos, dir * projSpeed, id, {drawDurationSeconds = 1, shotId = httpService:GenerateGUID(false)}, workspace:GetServerTimeNow() - 0.045)
											if not res then
												FireDelays[item.itemType] = tick()
											else
												local shoot = itemMeta.launchSound
												shoot = shoot and shoot[math.random(1, #shoot)] or nil
												if shoot then
													bedwars.SoundManager:playSound(shoot)
												end
											end
										end)
	
										FireDelays[item.itemType] = tick() + (itemMeta.fireDelaySec / FireSpeed.Value)
										if switched then
											task.wait(0.05)
										end
									end
								end
							end
						end
					end
					task.wait(0.1)
				until not ProjectileAura.Enabled
			end
		end,
		Tooltip = 'Shoots people around you with viewmodel animations'
	})
	Targets = ProjectileAura:CreateTargets({
		Players = true,
		Walls = true
	})
	List = ProjectileAura:CreateTextList({
		Name = 'Projectiles',
		Default = {'arrow', 'snowball'}
	})
	Range = ProjectileAura:CreateSlider({
		Name = 'Range',
		Min = 1,
		Max = 50,
		Default = 50,
		Suffix = function(val)
			return val == 1 and 'stud' or 'studs'
		end
	})
	HandCheck = ProjectileAura:CreateToggle({
		Name = 'Hand Check',
		Default = false,
		Tooltip = 'Only shoot when holding a bow or crossbow'
	})
	FireSpeed = ProjectileAura:CreateSlider({
		Name = 'Fire Speed',
		Min = 0.5,
		Max = 3,
		Default = 1,
		Decimal = 10,
		Tooltip = 'Lower = faster, Higher = slower. 1.0 = normal speed'
	})
end)

run(function()
	local a = {Enabled = false}
	a = vape.Categories.World:CreateModule({
		Name = "Leave Party",
		Function = function(call)
			if call then
				a:Toggle(false)
				game:GetService("ReplicatedStorage"):WaitForChild("events-@easy-games/lobby:shared/event/lobby-events@getEvents.Events"):WaitForChild("leaveParty"):FireServer()
			end
		end
	})
end)

run(function()
    local ChargePercent
    local AutoChargeBow = {Enabled = false}
    local old
    
    local maxChargeTime = 0.58
    
    AutoChargeBow = vape.Categories.Utility:CreateModule({
        Name = 'AutoChargeBow',
        Function = function(callback)
            if callback then
                old = bedwars.ProjectileController.calculateImportantLaunchValues
                bedwars.ProjectileController.calculateImportantLaunchValues = function(...)
                    local result = old(...)
                    
                    if result then
                        result.drawDurationSeconds = (ChargePercent.Value / 100) * maxChargeTime
                    end
                    
                    return result
                end
            else
                bedwars.ProjectileController.calculateImportantLaunchValues = old
            end
        end,
        Tooltip = 'Automatically charges your bow with controllable charge percentage'
    })

    ChargePercent = AutoChargeBow:CreateSlider({
        Name = 'Charge Percent',
        Min = 0,
        Max = 100,
        Default = 100,
        Suffix = '%',
        Tooltip = 'Control bow charge percentage (affects damage): 100% = full damage, 50% = half damage, etc.'
    })
end)

run(function()
    local EffectsOnly
    local moduleConnectionList = {}
    local processedObjects = {} 
    local originalProperties = {}
    
    local titanPatterns = {"titan", "golem", "bhaa", "spiritgolem", "voidgolem"}
    
    local function matchesTitanPattern(name)
        local lowerName = name:lower()
        for _, pattern in ipairs(titanPatterns) do
            if lowerName:find(pattern, 1, true) then 
                return true
            end
        end
        return false
    end
    
    local Aerov4TitanRemover = vape.Categories.BoostFPS:CreateModule({
        Name = 'Titan Remover',
        Function = function(callback)
            if callback then
                for _, conn in ipairs(moduleConnectionList) do
                    if conn and type(conn) == "userdata" and conn.Connected then
                        conn:Disconnect()
                    end
                end
                moduleConnectionList = {}
                processedObjects = {}
                originalProperties = {}

                local function processModel(model)
                    if processedObjects[model] then return end
                    processedObjects[model] = true
                    
                    local effectsOnly = EffectsOnly and EffectsOnly.Enabled
                    
                    local descendants = model:GetDescendants()
                    
                    for _, part in ipairs(descendants) do
                        if part.Name == "Nametag" and part.Parent and part.Parent.Name == "Head" then
                            continue
                        end
                        
                        if part:IsA("BasePart") and not effectsOnly then
                            if not originalProperties[part] then
                                originalProperties[part] = {
                                    Transparency = part.Transparency,
                                    CanCollide = part.CanCollide,
                                    CastShadow = part.CastShadow,
                                    CanQuery = part.CanQuery
                                }
                                
                                part.Transparency = 1
                                part.CanCollide = false
                                part.CastShadow = false
                                part.CanQuery = false
                            end
                            
                        elseif (part:IsA("Decal") or part:IsA("Texture")) and not effectsOnly then
                            if not originalProperties[part] then
                                originalProperties[part] = {Transparency = part.Transparency}
                                part.Transparency = 1
                            end
                            
                        elseif part:IsA("ParticleEmitter") then
                            if not originalProperties[part] then
                                originalProperties[part] = {Enabled = part.Enabled}
                                part.Enabled = false
                            end
                            
                        elseif part:IsA("Sound") then
                            if not originalProperties[part] then
                                originalProperties[part] = {Volume = part.Volume}
                                part.Volume = 0
                            end
                            
                        elseif part:IsA("SurfaceGui") or part:IsA("BillboardGui") then
                            if not originalProperties[part] then
                                originalProperties[part] = {Enabled = part.Enabled}
                                part.Enabled = false
                            end
                        end
                    end
                end

                local function hideTitanAssets()
                    for _, model in ipairs(workspace:GetChildren()) do
                        if model:IsA("Model") and matchesTitanPattern(model.Name) then
                            processModel(model)
                        end
                    end
                    
                    local function hideBossBars()
                        for _, screenGui in ipairs(game:GetService("CoreGui"):GetDescendants()) do
                            if screenGui:IsA("ScreenGui") and (screenGui.Name:find("BossBar") or screenGui.Name:find("Boss")) then
                                if not originalProperties[screenGui] then
                                    originalProperties[screenGui] = {Enabled = screenGui.Enabled}
                                    screenGui.Enabled = false
                                end
                            end
                        end
                        
                        local player = game:GetService("Players").LocalPlayer
                        if player and player:FindFirstChild("PlayerGui") then
                            for _, screenGui in ipairs(player.PlayerGui:GetDescendants()) do
                                if screenGui:IsA("ScreenGui") and (screenGui.Name:find("BossBar") or screenGui.Name:find("Boss")) then
                                    if not originalProperties[screenGui] then
                                        originalProperties[screenGui] = {Enabled = screenGui.Enabled}
                                        screenGui.Enabled = false
                                    end
                                end
                            end
                        end
                    end
                    
                    pcall(hideBossBars)
                end

                hideTitanAssets()
                
                local descendantConnection = workspace.DescendantAdded:Connect(function(descendant)
                    if descendant:IsA("Model") and matchesTitanPattern(descendant.Name) then
                        task.delay(0.1, function()
                            if descendant.Parent then
                                processModel(descendant)
                            end
                        end)
                        
                    elseif descendant:IsA("ParticleEmitter") then
                        local parent = descendant.Parent
                        if parent and matchesTitanPattern(parent.Name) then
                            if not originalProperties[descendant] then
                                originalProperties[descendant] = {Enabled = descendant.Enabled}
                                descendant.Enabled = false
                            end
                        end
                        
                    elseif descendant:IsA("Sound") then
                        if matchesTitanPattern(descendant.Name) then
                            if not originalProperties[descendant] then
                                originalProperties[descendant] = {Volume = descendant.Volume}
                                descendant.Volume = 0
                            end
                        end
                    end
                end)
                table.insert(moduleConnectionList, descendantConnection)
                
                task.spawn(function()
                    local collectionService = game:GetService("CollectionService")
                    local tagsToMonitor = {"Bhaa", "spiritGolem", "GolemBoss", "Titan"}
                    
                    for _, tag in ipairs(tagsToMonitor) do
                        local success, tagged = pcall(function()
                            return collectionService:GetTagged(tag)
                        end)
                        
                        if success then
                            for _, obj in ipairs(tagged) do
                                if obj:IsA("Model") and not processedObjects[obj] then
                                    processModel(obj)
                                end
                            end
                            
                            local tagAddedConnection = collectionService:GetInstanceAddedSignal(tag):Connect(function(obj)
                                if obj:IsA("Model") and not processedObjects[obj] then
                                    task.delay(0.1, function()
                                        if obj.Parent then
                                            processModel(obj)
                                        end
                                    end)
                                end
                            end)
                            table.insert(moduleConnectionList, tagAddedConnection)
                        end
                    end
                end)
                
            else
                for _, conn in ipairs(moduleConnectionList) do
                    if conn and type(conn) == "userdata" and conn.Connected then
                        pcall(function()
                            conn:Disconnect()
                        end)
                    end
                end
                moduleConnectionList = {}
                
                for object, properties in pairs(originalProperties) do
                    if object and object.Parent then
                        pcall(function()
                            for prop, value in pairs(properties) do
                                if object[prop] ~= nil then
                                    object[prop] = value
                                end
                            end
                        end)
                    end
                end
                
                processedObjects = {}
                originalProperties = {}
            end
        end,
        Tooltip = 'Removes Titan/Bhaa models and effects for FPS boost'
    })

    EffectsOnly = Aerov4TitanRemover:CreateToggle({
        Name = 'Effects Only',
        Default = false,
        Tooltip = 'Only hides particles keeps titan models visible',
        Function = function(callback)
            if Aerov4TitanRemover.Enabled then
                for object, properties in pairs(originalProperties) do
                    if object and object.Parent then
                        pcall(function()
                            for prop, value in pairs(properties) do
                                if object[prop] ~= nil then
                                    object[prop] = value
                                end
                            end
                        end)
                    end
                end
                processedObjects = {}
                originalProperties = {}
                
                Aerov4TitanRemover:Toggle()
                task.wait()
                Aerov4TitanRemover:Toggle()
            end
        end
    })
end)
	
run(function()
	local Mode
	local Value
	local WallCheck
	local AutoJump
	local AlwaysJump
	local rayCheck = RaycastParams.new()
	rayCheck.RespectCanCollide = true
	
	Speed = vape.Categories.Blatant:CreateModule({
		Name = 'Speed',
		Function = function(callback)
			frictionTable.Speed = callback or nil
			updateVelocity()
			pcall(function()
				debug.setconstant(bedwars.WindWalkerController.updateSpeed, 7, callback and 'constantSpeedMultiplier' or 'moveSpeedMultiplier')
			end)
	
			if callback then
				Speed:Clean(runService.PreSimulation:Connect(function(dt)
					bedwars.StatefulEntityKnockbackController.lastImpulseTime = callback and math.huge or time()
					if entitylib.isAlive then
						if not Fly.Enabled and not (InfiniteFly or {}).Enabled and not LongJump.Enabled then
							bedwars.SprintController:setSpeed(Mode.Value == 'CFrame' and 20 or Value.Value)
							if Mode.Value == 'CFrame' then
								local state = entitylib.character.Humanoid:GetState()
								if state == Enum.HumanoidStateType.Climbing then return end
			
								local root, velo = entitylib.character.RootPart, getSpeed()
								local moveDirection = AntiFallDirection or entitylib.character.Humanoid.MoveDirection
								local destination = (moveDirection * math.max(Value.Value - velo, 0) * dt)
			
								if WallCheck.Enabled then
									rayCheck.FilterDescendantsInstances = {lplr.Character, gameCamera}
									rayCheck.CollisionGroup = root.CollisionGroup
									local ray = workspace:Raycast(root.Position, destination, rayCheck)
									if ray then
										destination = ((ray.Position + ray.Normal) - root.Position)
									end
								end
			
								root.CFrame += destination
								root.AssemblyLinearVelocity = (moveDirection * velo) + Vector3.new(0, root.AssemblyLinearVelocity.Y, 0)
								if AutoJump.Enabled and (state == Enum.HumanoidStateType.Running or state == Enum.HumanoidStateType.Landed) and moveDirection ~= Vector3.zero and (Attacking or AlwaysJump.Enabled) then
									entitylib.character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
								end
							end
						end
					end
				end))
			else
				bedwars.SprintController:setSpeed(bedwars.SprintController:isSprinting() and 20 or 14)
			end
		end,
		ExtraText = function()
			return 'Heatseeker'
		end,
		Tooltip = 'Increases your movement with various methods.'
	})
	Mode = Speed:CreateDropdown({
		Name = 'Method',
		List = {'Bedwars', 'CFrame'},
		Default = 'CFrame'
	})
	Value = Speed:CreateSlider({
		Name = 'Speed',
		Min = 1,
		Max = 23,
		Default = 23,
		Suffix = function(val)
			return val == 1 and 'stud' or 'studs'
		end
	})
	WallCheck = Speed:CreateToggle({
		Name = 'Wall Check',
		Default = true
	})
	AutoJump = Speed:CreateToggle({
		Name = 'AutoJump',
		Function = function(callback)
			AlwaysJump.Object.Visible = callback
		end
	})
	AlwaysJump = Speed:CreateToggle({
		Name = 'Always Jump',
		Visible = false,
		Darker = true
	})
end)

run(function()
	local GrimReaperFix
	GrimReaperFix = vape.Categories.Utility:CreateModule({
		Name = 'GrimReaperFix',
		Function = function(callback)
			if callback then
				GrimReaperFix:Clean(runService.Heartbeat:Connect(function()
					if not entitylib.isAlive then return end
					local humanoid = entitylib.character.Humanoid
					if humanoid.HipHeight > 2.1 then
						humanoid.HipHeight = 2.05
					end
				end))
			end
		end,
		Tooltip = 'Fixes Grim Reaper height (prevents being too tall)'
	})
end)
	
run(function()
	local BedESP
	local Reference = {}
	local Folder = Instance.new('Folder')
	Folder.Parent = vape.gui
	
	local function Added(bed)
		if not BedESP.Enabled then return end
		local BedFolder = Instance.new('Folder')
		BedFolder.Parent = Folder
		Reference[bed] = BedFolder
		local parts = bed:GetChildren()
		table.sort(parts, function(a, b)
			return a.Name > b.Name
		end)
	
		for _, part in parts do
			if part:IsA('BasePart') and part.Name ~= 'Blanket' then
				local handle = Instance.new('BoxHandleAdornment')
				handle.Size = part.Size + Vector3.new(.01, .01, .01)
				handle.AlwaysOnTop = true
				handle.ZIndex = 2
				handle.Visible = true
				handle.Adornee = part
				handle.Color3 = part.Color
				if part.Name == 'Legs' then
					handle.Color3 = Color3.fromRGB(167, 112, 64)
					handle.Size = part.Size + Vector3.new(.01, -1, .01)
					handle.CFrame = CFrame.new(0, -0.4, 0)
					handle.ZIndex = 0
				end
				handle.Parent = BedFolder
			end
		end
	
		table.clear(parts)
	end
	
	BedESP = vape.Categories.Render:CreateModule({
		Name = 'BedESP',
		Function = function(callback)
			if callback then
				BedESP:Clean(collectionService:GetInstanceAddedSignal('bed'):Connect(function(bed)
					task.delay(0.2, Added, bed)
				end))
				BedESP:Clean(collectionService:GetInstanceRemovedSignal('bed'):Connect(function(bed)
					if Reference[bed] then
						Reference[bed]:Destroy()
						Reference[bed] = nil
					end
				end))
				for _, bed in collectionService:GetTagged('bed') do
					Added(bed)
				end
			else
				Folder:ClearAllChildren()
				table.clear(Reference)
			end
		end,
		Tooltip = 'Render Beds through walls'
	})
end)
	
run(function()
	local Health
	
	Health = vape.Categories.Render:CreateModule({
		Name = 'Health',
		Function = function(callback)
			if callback then
				local label = Instance.new('TextLabel')
				label.Size = UDim2.fromOffset(100, 20)
				label.Position = UDim2.new(0.5, 6, 0.5, 30)
				label.BackgroundTransparency = 1
				label.AnchorPoint = Vector2.new(0.5, 0)
				label.Text = entitylib.isAlive and math.round(lplr.Character:GetAttribute('Health'))..' ' or ''
				label.TextColor3 = entitylib.isAlive and Color3.fromHSV((lplr.Character:GetAttribute('Health') / lplr.Character:GetAttribute('MaxHealth')) / 2.8, 0.86, 1) or Color3.new()
				label.TextSize = 18
				label.Font = Enum.Font.Arial
				label.Parent = vape.gui
				Health:Clean(label)
				Health:Clean(vapeEvents.AttributeChanged.Event:Connect(function()
					label.Text = entitylib.isAlive and math.round(lplr.Character:GetAttribute('Health'))..' ' or ''
					label.TextColor3 = entitylib.isAlive and Color3.fromHSV((lplr.Character:GetAttribute('Health') / lplr.Character:GetAttribute('MaxHealth')) / 2.8, 0.86, 1) or Color3.new()
				end))
			end
		end,
		Tooltip = 'Displays your health in the center of your screen.'
	})
end)
	
run(function()
	local KitESP
	local Notify
	local Background
	local Color = {}
	local Reference = {}
	local Folder = Instance.new('Folder')
	Folder.Parent = vape.gui
	
	local ESPKits = {
		alchemist = {'alchemist_ingedients', 'wild_flower'},
		beekeeper = {'bee', 'bee'},
		bigman = {'treeOrb', 'natures_essence_1'},
		ghost_catcher = {'ghost', 'ghost_orb'},
		metal_detector = {'hidden-metal', 'iron'},
		sheep_herder = {'SheepModel', 'purple_hay_bale'},
		sorcerer = {'alchemy_crystal', 'wild_flower'},
		star_collector = {'stars', 'crit_star'},
		black_market_trader = {'shadow_coin', 'shadow_coin'},
		miner = {'petrified-player', 'large_rock'},
		trapper = {'snap_trap', 'snap_trap'}
	}
	local NONTaggedKits = {
        necromancer = {'Gravestone', true},
        battery = {'Open', true},
	}

	local function getStarImage(v)
		local parent = v and v.Parent
		if parent and parent:IsA("Model") then
			local modelName = parent.Name
			if modelName == "CritStar" or modelName:lower():find("crit") then
				return bedwars.getIcon({itemType = 'crit_star'}, true)
			elseif modelName == "VitalityStar" or modelName:lower():find("vitality") then
				return bedwars.getIcon({itemType = 'vitality_star'}, true)
			end
		end
		return bedwars.getIcon({itemType = 'crit_star'}, true)
	end

	local function Added(v, icon, non)
		if Notify.Enabled then
			vape:CreateNotification("KitESP", `New object is added {v.Name}`, 2)
		end
		local billboard = Instance.new('BillboardGui')
		billboard.Parent = Folder
		billboard.Name = icon
		billboard.StudsOffsetWorldSpace = Vector3.new(0, 3, 0)
		billboard.Size = UDim2.fromOffset(36, 36)
		billboard.AlwaysOnTop = true
		billboard.ClipsDescendants = false
		billboard.Adornee = v
		local blur = addBlur(billboard)
		blur.Visible = Background.Enabled
		local image = Instance.new('ImageLabel')
		image.Size = UDim2.fromOffset(36, 36)
		image.Position = UDim2.fromScale(0.5, 0.5)
		image.AnchorPoint = Vector2.new(0.5, 0.5)
		image.BackgroundColor3 = Color3.fromHSV(Color.Hue, Color.Sat, Color.Value)
		image.BackgroundTransparency = 1 - (Background.Enabled and Color.Opacity or 0)
		image.BorderSizePixel = 0
		local result = nil
		if non then
			result = icon
		else
			result = bedwars.getIcon({itemType = icon}, true)
		end
		image.Image = result
		image.Parent = billboard
		local uicorner = Instance.new('UICorner')
		uicorner.CornerRadius = UDim.new(0, 4)
		uicorner.Parent = image
		Reference[v] = billboard
	end

	local function AddedStar(v)
		if not v or not v.Parent then return end
		if Reference[v] then return end

		if Notify.Enabled then
			vape:CreateNotification("KitESP", `New object is added {v.Name}`, 2)
		end
		local billboard = Instance.new('BillboardGui')
		billboard.Parent = Folder
		billboard.Name = 'star'
		billboard.StudsOffsetWorldSpace = Vector3.new(0, 3, 0)
		billboard.Size = UDim2.fromOffset(36, 36)
		billboard.AlwaysOnTop = true
		billboard.ClipsDescendants = false
		billboard.Adornee = v
		local blur = addBlur(billboard)
		blur.Visible = Background.Enabled
		local image = Instance.new('ImageLabel')
		image.Size = UDim2.fromOffset(36, 36)
		image.Position = UDim2.fromScale(0.5, 0.5)
		image.AnchorPoint = Vector2.new(0.5, 0.5)
		image.BackgroundColor3 = Color3.fromHSV(Color.Hue, Color.Sat, Color.Value)
		image.BackgroundTransparency = 1 - (Background.Enabled and Color.Opacity or 0)
		image.BorderSizePixel = 0
		image.Image = getStarImage(v)
		image.Parent = billboard
		local uicorner = Instance.new('UICorner')
		uicorner.CornerRadius = UDim.new(0, 4)
		uicorner.Parent = image
		Reference[v] = billboard
	end
	
	local function addKit(tag, icon)
		if tag == 'stars' then
			KitESP:Clean(collectionService:GetInstanceAddedSignal(tag):Connect(function(v)
				if v:IsA("Model") and v.PrimaryPart then
					task.wait(0.1)
					AddedStar(v.PrimaryPart)
				end
			end))
			KitESP:Clean(collectionService:GetInstanceRemovedSignal(tag):Connect(function(v)
				if v.PrimaryPart and Reference[v.PrimaryPart] then
					Reference[v.PrimaryPart]:Destroy()
					Reference[v.PrimaryPart] = nil
				end
			end))
			for _, v in collectionService:GetTagged(tag) do
				if v:IsA("Model") and v.PrimaryPart then
					AddedStar(v.PrimaryPart)
				end
			end
			return
		end

		KitESP:Clean(collectionService:GetInstanceAddedSignal(tag):Connect(function(v)
			Added(v.PrimaryPart, icon, false)
		end))
		KitESP:Clean(collectionService:GetInstanceRemovedSignal(tag):Connect(function(v)
			if Reference[v.PrimaryPart] then
				Reference[v.PrimaryPart]:Destroy()
				Reference[v.PrimaryPart] = nil
			end
		end))
		for _, v in collectionService:GetTagged(tag) do
			Added(v.PrimaryPart, icon, false)
		end
	end

	local function addKitNon(objName, icon)
		if typeof(icon) == "boolean" then
			if objName == "Gravestone" then
				icon = "rbxassetid://6307844310"
			elseif objName == "Open" then
				icon = "rbxassetid://10159166528"
			else
				icon = bedwars.getIcon({itemType = icon}, true) or ''
			end
		else
			icon = bedwars.getIcon({itemType = icon}, true)
		end
        KitESP:Clean(workspace.ChildAdded:Connect(function(child)
            if child:IsA("Model") and child.Name == objName then
                task.wait(0.1)
                if child.PrimaryPart then
                    Added(child, icon, true)
                end
            end
        end))
        KitESP:Clean(workspace.ChildRemoved:Connect(function(child)
            if child:IsA("Model") and child.Name == objName then
                if Reference[child] then
                    Reference[child]:Destroy()
                    Reference[child] = nil
                end
            end
        end))
	end
	
	KitESP = vape.Categories.Kits:CreateModule({
		Name = 'KitESP',
		Function = function(callback)
			if callback then
				repeat task.wait() until store.equippedKit ~= '' or (not KitESP.Enabled)
				local kit = KitESP.Enabled and ESPKits[store.equippedKit] or nil
				local nontag = KitESP.Enabled and NONTaggedKits[store.equippedKit] or nil
				if kit then
					addKit(kit[1], kit[2])
				end
				if nontag then
					addKitNon(nontag[1], nontag[2])
				end
			else
				Folder:ClearAllChildren()
				table.clear(Reference)
			end
		end,
		Tooltip = 'ESP for certain kit related objects'
	})
	Notify = KitESP:CreateToggle({
		Name = "Notify",
		Default = false
	})
	Background = KitESP:CreateToggle({
		Name = 'Background',
		Function = function(callback)
			if Color.Object then Color.Object.Visible = callback end
			for _, v in Reference do
				v.ImageLabel.BackgroundTransparency = 1 - (callback and Color.Opacity or 0)
				v.Blur.Visible = callback
			end
		end,
		Default = true
	})
	Color = KitESP:CreateColorSlider({
		Name = 'Background Color',
		DefaultValue = 0,
		DefaultOpacity = 0.5,
		Function = function(hue, sat, val, opacity)
			for _, v in Reference do
				v.ImageLabel.BackgroundColor3 = Color3.fromHSV(hue, sat, val)
				v.ImageLabel.BackgroundTransparency = 1 - opacity
			end
		end,
		Darker = true
	})
end)

run(function()
	local LootESP
	local IronToggle
	local DiamondToggle
	local EmeraldToggle
	local Reference = {}
	local Folder = Instance.new('Folder')
	Folder.Parent = vape.gui
	
	local CollectionService = game:GetService("CollectionService")
	
	local lootTypes = {
		iron = {
			keywords = {'iron'},
			color = Color3.fromRGB(200, 200, 200),
			icon = 'iron',
			displayName = 'IRON'
		},
		diamond = {
			keywords = {'diamond'},
			color = Color3.fromRGB(85, 200, 255),
			icon = 'diamond',
			displayName = 'DIAMOND'
		},
		emerald = {
			keywords = {'emerald'},
			color = Color3.fromRGB(0, 255, 100),
			icon = 'emerald',
			displayName = 'EMERALD'
		}
	}
	
	local function getLootType(itemName)
		local nameLower = itemName:lower()
		for lootType, config in pairs(lootTypes) do
			for _, keyword in ipairs(config.keywords) do
				if nameLower:find(keyword, 1, true) then 
					return lootType, config
				end
			end
		end
		return nil
	end
	
	local function isLootEnabled(lootType)
		if lootType == 'iron' then
			return IronToggle.Enabled
		elseif lootType == 'diamond' then
			return DiamondToggle.Enabled
		elseif lootType == 'emerald' then
			return EmeraldToggle.Enabled
		end
		return false
	end
	
	local function getProperIcon(lootType)
		local icon = bedwars.getIcon({itemType = lootType}, true)
		
		if not icon or icon == "" then
			return nil
		end
		
		return icon
	end
	
	local function Added(lootHandle, lootType, config)
		if not isLootEnabled(lootType) then return end
		if Reference[lootHandle] then return end 
		
		local billboard = Instance.new('BillboardGui')
		billboard.Parent = Folder
		billboard.Name = lootType
		billboard.StudsOffsetWorldSpace = Vector3.new(0, 3, 0)
		billboard.Size = UDim2.fromOffset(40, 40)
		billboard.AlwaysOnTop = true
		billboard.ClipsDescendants = false
		billboard.Adornee = lootHandle
		
		local blur = addBlur(billboard)
		blur.Visible = true 
		
		local iconImage = getProperIcon(config.icon)
		
		if iconImage then
			local image = Instance.new('ImageLabel')
			image.Size = UDim2.fromOffset(40, 40)
			image.Position = UDim2.fromScale(0.5, 0.5)
			image.AnchorPoint = Vector2.new(0.5, 0.5)
			image.BackgroundColor3 = Color3.new(0, 0, 0) 
			image.BackgroundTransparency = 0.3 
			image.BorderSizePixel = 0
			image.Image = iconImage
			image.Parent = billboard
			
			local uicorner = Instance.new('UICorner')
			uicorner.CornerRadius = UDim.new(0, 4)
			uicorner.Parent = image
		else
			local frame = Instance.new('Frame')
			frame.Size = UDim2.fromScale(1, 1)
			frame.BackgroundColor3 = Color3.new(0, 0, 0) 
			frame.BackgroundTransparency = 0.3 
			frame.BorderSizePixel = 0
			frame.Parent = billboard
			
			local uicorner = Instance.new('UICorner')
			uicorner.CornerRadius = UDim.new(0, 4)
			uicorner.Parent = frame
			
			local textLabel = Instance.new('TextLabel')
			textLabel.Size = UDim2.fromScale(1, 1)
			textLabel.Position = UDim2.fromScale(0.5, 0.5)
			textLabel.AnchorPoint = Vector2.new(0.5, 0.5)
			textLabel.BackgroundTransparency = 1
			textLabel.Text = config.displayName
			textLabel.TextColor3 = config.color
			textLabel.TextScaled = true
			textLabel.Font = Enum.Font.GothamBold
			textLabel.TextStrokeTransparency = 0.5
			textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
			textLabel.Parent = frame
		end
		
		Reference[lootHandle] = billboard
	end
	
	local function Removed(lootHandle)
		if Reference[lootHandle] then
			Reference[lootHandle]:Destroy()
			Reference[lootHandle] = nil
		end
	end
	
	local function findExistingLoot()
		local tagged = CollectionService:GetTagged('ItemDrop')
		for _, drop in ipairs(tagged) do
			local handle = drop:FindFirstChild('Handle')
			if handle then
				local lootType, config = getLootType(drop.Name)
				if lootType and isLootEnabled(lootType) then
					if not Reference[handle] then
						Added(handle, lootType, config)
					end
				end
			end
		end
	end
	
	local function refreshLootType(lootType)
		if not LootESP.Enabled then return end
		
		local enabled = isLootEnabled(lootType)
		
		if not enabled then
			for handle, billboard in pairs(Reference) do
				if billboard.Name == lootType then
					billboard:Destroy()
					Reference[handle] = nil
				end
			end
		else
			local tagged = CollectionService:GetTagged('ItemDrop')
			for _, drop in ipairs(tagged) do
				local handle = drop:FindFirstChild('Handle')
				if handle then
					local dropLootType, config = getLootType(drop.Name)
					if dropLootType == lootType and not Reference[handle] then
						Added(handle, lootType, config)
					end
				end
			end
		end
	end
	
	LootESP = vape.Categories.Render:CreateModule({
		Name = 'LootESP',
		Function = function(callback)
			if callback then
				findExistingLoot()
				
				LootESP:Clean(CollectionService:GetInstanceAddedSignal('ItemDrop'):Connect(function(drop)
					if not LootESP.Enabled then return end
					
					task.defer(function()
						local handle = drop:FindFirstChild('Handle')
						if not handle then return end
						
						local lootType, config = getLootType(drop.Name)
						if lootType and isLootEnabled(lootType) then
							Added(handle, lootType, config)
						end
					end)
				end))
				
				LootESP:Clean(CollectionService:GetInstanceRemovedSignal('ItemDrop'):Connect(function(drop)
					local handle = drop:FindFirstChild('Handle')
					if handle then
						Removed(handle)
					end
				end))
				
			else
				for handle, billboard in pairs(Reference) do
					billboard:Destroy()
				end
				table.clear(Reference)
			end
		end,
		Tooltip = 'ESP for loot drops (iron, diamond, emerald)'
	})
	
	IronToggle = LootESP:CreateToggle({
		Name = 'Iron',
		Function = function(callback)
			refreshLootType('iron')
		end,
		Default = true
	})
	
	DiamondToggle = LootESP:CreateToggle({
		Name = 'Diamond',
		Function = function(callback)
			refreshLootType('diamond')
		end,
		Default = true
	})
	
	EmeraldToggle = LootESP:CreateToggle({
		Name = 'Emerald',
		Function = function(callback)
			refreshLootType('emerald')
		end,
		Default = true
	})
end)
	
run(function()
    local NameTags
    local Targets
    local Color
    local Background
    local DisplayName
    local Health
    local Distance
    local Equipment
    local DrawingToggle
    local ShowKits 
    local Scale
    local FontOption
    local Teammates
    local DistanceCheck
    local DistanceLimit
    local Strings, Sizes, Reference = {}, {}, {}
    local Folder = Instance.new('Folder')
    Folder.Parent = vape.gui
    local methodused
    local lastUpdate = {}
    local kitCache = {}
    local equipmentCache = {}
    local tick = tick
    local math_floor = math.floor
    local math_round = math.round
    local math_clamp = math.clamp
    local math_huge = math.huge
    local string_format = string.format
    local vector2new = Vector2.new
    local vector3new = Vector3.new
    local color3fromHSV = Color3.fromHSV
    local color3new = Color3.new
    local udim2fromOffset = UDim2.fromOffset
    
    local kitImageIds = {
        ['none'] = "rbxassetid://16493320215",
        ["random"] = "rbxassetid://79773209697352",
        ["cowgirl"] = "rbxassetid://9155462968",
        ["davey"] = "rbxassetid://9155464612",
        ["warlock"] = "rbxassetid://15186338366",
        ["ember"] = "rbxassetid://9630017904",
        ["black_market_trader"] = "rbxassetid://9630017904",
        ["yeti"] = "rbxassetid://9166205917",
        ["scarab"] = "rbxassetid://137137517627492",
        ["defender"] = "rbxassetid://131690429591874",
        ["cactus"] = "rbxassetid://104436517801089",
        ["oasis"] = "rbxassetid://120283205213823",
        ["berserker"] = "rbxassetid://90258047545241",
        ["sword_shield"] = "rbxassetid://131690429591874",
        ["airbender"] = "rbxassetid://74712750354593",
        ["gun_blade"] = "rbxassetid://138231219644853",
        ["frost_hammer_kit"] = "rbxassetid://11838567073",
        ["spider_queen"] = "rbxassetid://95237509752482",
        ["archer"] = "rbxassetid://9224796984",
        ["axolotl"] = "rbxassetid://9155466713",
        ["baker"] = "rbxassetid://9155463919",
        ["barbarian"] = "rbxassetid://9166207628",
        ["builder"] = "rbxassetid://9155463708",
        ["necromancer"] = "rbxassetid://11343458097",
        ["cyber"] = "rbxassetid://9507126891",
        ["sorcerer"] = "rbxassetid://97940108361528",
        ["bigman"] = "rbxassetid://9155467211",
        ["spirit_assassin"] = "rbxassetid://10406002412",
        ["farmer_cletus"] = "rbxassetid://9155466936",
        ["ice_queen"] = "rbxassetid://9155466204",
        ["grim_reaper"] = "rbxassetid://9155467410",
        ["spirit_gardener"] = "rbxassetid://132108376114488",
        ["hannah"] = "rbxassetid://10726577232",
        ["shielder"] = "rbxassetid://9155464114",
        ["summoner"] = "rbxassetid://18922378956",
        ["glacial_skater"] = "rbxassetid://84628060516931",
        ["dragon_sword"] = "rbxassetid://16215630104",
        ["lumen"] = "rbxassetid://9630018371",
        ["flower_bee"] = "rbxassetid://101569742252812",
        ["jellyfish"] = "rbxassetid://18129974852",
        ["melody"] = "rbxassetid://9155464915",
        ["mimic"] = "rbxassetid://14783283296",
        ["miner"] = "rbxassetid://9166208461",
        ["nazar"] = "rbxassetid://18926951849",
        ["seahorse"] = "rbxassetid://11902552560",
        ["elk_master"] = "rbxassetid://15714972287",
        ["rebellion_leader"] = "rbxassetid://18926409564",
        ["void_hunter"] = "rbxassetid://122370766273698",
        ["taliyah"] = "rbxassetid://13989437601",
        ["angel"] = "rbxassetid://9166208240",
        ["harpoon"] = "rbxassetid://18250634847",
        ["void_walker"] = "rbxassetid://78915127961078",
        ["spirit_summoner"] = "rbxassetid://95760990786863",
        ["triple_shot"] = "rbxassetid://9166208149",
        ["void_knight"] = "rbxassetid://73636326782144",
        ["regent"] = "rbxassetid://9166208904",
        ["vulcan"] = "rbxassetid://9155465543",
        ["owl"] = "rbxassetid://12509401147",
        ["dasher"] = "rbxassetid://9155467645",
        ["disruptor"] = "rbxassetid://11596993583",
        ["wizard"] = "rbxassetid://13353923546",
        ["aery"] = "rbxassetid://9155463221",
        ["agni"] = "rbxassetid://17024640133",
        ["alchemist"] = "rbxassetid://9155462512",
        ["spearman"] = "rbxassetid://9166207341",
        ["beekeeper"] = "rbxassetid://9312831285",
        ["falconer"] = "rbxassetid://17022941869",
        ["bounty_hunter"] = "rbxassetid://9166208649",
        ["blood_assassin"] = "rbxassetid://12520290159",
        ["battery"] = "rbxassetid://10159166528",
        ["steam_engineer"] = "rbxassetid://15380413567",
        ["vesta"] = "rbxassetid://9568930198",
        ["beast"] = "rbxassetid://9155465124",
        ["dino_tamer"] = "rbxassetid://9872357009",
        ["drill"] = "rbxassetid://12955100280",
        ["elektra"] = "rbxassetid://13841413050",
        ["fisherman"] = "rbxassetid://9166208359",
        ["queen_bee"] = "rbxassetid://12671498918",
        ["card"] = "rbxassetid://13841410580",
        ["frosty"] = "rbxassetid://9166208762",
        ["gingerbread_man"] = "rbxassetid://9155464364",
        ["ghost_catcher"] = "rbxassetid://9224802656",
        ["tinker"] = "rbxassetid://17025762404",
        ["ignis"] = "rbxassetid://13835258938",
        ["oil_man"] = "rbxassetid://9166206259",
        ["jade"] = "rbxassetid://9166306816",
        ["dragon_slayer"] = "rbxassetid://10982192175",
        ["paladin"] = "rbxassetid://11202785737",
        ["pinata"] = "rbxassetid://10011261147",
        ["merchant"] = "rbxassetid://9872356790",
        ["metal_detector"] = "rbxassetid://9378298061",
        ["slime_tamer"] = "rbxassetid://15379766168",
        ["nyoka"] = "rbxassetid://17022941410",
        ["midnight"] = "rbxassetid://9155462763",
        ["pyro"] = "rbxassetid://9155464770",
        ["raven"] = "rbxassetid://9166206554",
        ["santa"] = "rbxassetid://9166206101",
        ["sheep_herder"] = "rbxassetid://9155465730",
        ["smoke"] = "rbxassetid://9155462247",
        ["spirit_catcher"] = "rbxassetid://9166207943",
        ["star_collector"] = "rbxassetid://9872356516",
        ["styx"] = "rbxassetid://17014536631",
        ["block_kicker"] = "rbxassetid://15382536098",
        ["trapper"] = "rbxassetid://9166206875",
        ["hatter"] = "rbxassetid://12509388633",
        ["ninja"] = "rbxassetid://15517037848",
        ["jailor"] = "rbxassetid://11664116980",
        ["warrior"] = "rbxassetid://9166207008",
        ["mage"] = "rbxassetid://10982191792",
        ["void_dragon"] = "rbxassetid://10982192753",
        ["cat"] = "rbxassetid://15350740470",
        ["wind_walker"] = "rbxassetid://9872355499",
        ['skeleton'] = "rbxassetid://120123419412119",
        ['winter_lady'] = "rbxassetid://83274578564074",
    }
    
    local Added = {
        Normal = function(ent)
            if not Targets.Players.Enabled and ent.Player then return end
            if not Targets.NPCs.Enabled and ent.NPC then return end
            if Teammates.Enabled and (not ent.Targetable) and (not ent.Friend) then return end
            
            local nametag = Instance.new('TextLabel')
            Strings[ent] = ent.Player and whitelist:tag(ent.Player, true)..(DisplayName.Enabled and ent.Player.DisplayName or ent.Player.Name) or ent.Character.Name
            
            if Health.Enabled then
                local healthColor = color3fromHSV(math_clamp(ent.Health / ent.MaxHealth, 0, 1) / 2.5, 0.89, 0.75)
                Strings[ent] = Strings[ent]..' '..math_round(ent.Health)..''
            end
            
            if Distance.Enabled then
                Strings[ent] = '[%s] '..Strings[ent]
            end
            
            if Equipment.Enabled then
                for i, v in {'Hand', 'Helmet', 'Chestplate', 'Boots'} do
                    local Icon = Instance.new('ImageLabel')
                    Icon.Name = v
                    Icon.Size = udim2fromOffset(30, 30)
                    Icon.Position = udim2fromOffset(-60 + (i * 30), -30)
                    Icon.BackgroundTransparency = 1
                    Icon.Image = ''
                    Icon.Parent = nametag
                end
            end
            
            if ShowKits.Enabled and ent.Player then
                local kitIcon = Instance.new('ImageLabel')
                kitIcon.Name = 'KitIcon'
                kitIcon.Size = udim2fromOffset(30, 30)
                kitIcon.AnchorPoint = vector2new(0.5, 0)
                kitIcon.BackgroundTransparency = 1
                kitIcon.Image = ''
                
                if Equipment.Enabled then
                    kitIcon.Position = udim2fromOffset(110, -30)
                else
                    kitIcon.Position = UDim2.new(0.5, 0, 0, -35)
                end
                
                kitIcon.Parent = nametag
                
                local kit = ent.Player:GetAttribute('PlayingAsKits')
                if kit then
                    local kitImage = kitImageIds[kit:lower()]
                    kitIcon.Image = kitImage or kitImageIds["none"]
                    kitCache[ent] = kitImage or kitImageIds["none"]
                else
                    kitIcon.Image = kitImageIds["none"]
                    kitCache[ent] = kitImageIds["none"]
                end
            end
            
            nametag.TextSize = 14 * Scale.Value
            nametag.FontFace = FontOption.Value
            local size = getfontsize(removeTags(Strings[ent]), nametag.TextSize, nametag.FontFace, vector2new(100000, 100000))
            nametag.Name = ent.Player and ent.Player.Name or ent.Character.Name
            nametag.Size = udim2fromOffset(size.X + 8, size.Y + 7)
            nametag.AnchorPoint = vector2new(0.5, 1)
            nametag.BackgroundColor3 = color3new()
            nametag.BackgroundTransparency = Background.Value
            nametag.BorderSizePixel = 0
            nametag.Visible = false
            nametag.Text = Strings[ent]
            nametag.TextColor3 = entitylib.getEntityColor(ent) or color3fromHSV(Color.Hue, Color.Sat, Color.Value)
            nametag.RichText = true
            nametag.Parent = Folder
            Reference[ent] = nametag
            lastUpdate[ent] = 0
        end,
        Drawing = function(ent)
            if not Targets.Players.Enabled and ent.Player then return end
            if not Targets.NPCs.Enabled and ent.NPC then return end
            if Teammates.Enabled and (not ent.Targetable) and (not ent.Friend) then return end
            
            local nametag = {}
            nametag.BG = Drawing.new('Square')
            nametag.BG.Filled = true
            nametag.BG.Transparency = 1 - Background.Value
            nametag.BG.Color = color3new()
            nametag.BG.ZIndex = 1
            nametag.Text = Drawing.new('Text')
            nametag.Text.Size = 15 * Scale.Value
            nametag.Text.Font = 0
            nametag.Text.ZIndex = 2
            Strings[ent] = ent.Player and whitelist:tag(ent.Player, true)..(DisplayName.Enabled and ent.Player.DisplayName or ent.Player.Name) or ent.Character.Name
            
            if Health.Enabled then
                Strings[ent] = Strings[ent]..' '..math_round(ent.Health)
            end
            
            if Distance.Enabled then
                Strings[ent] = '[%s] '..Strings[ent]
            end
            
            if ShowKits.Enabled and ent.Player then
                local kit = ent.Player:GetAttribute('PlayingAsKits')
                if kit then
                    local kitName = kit:gsub("_", " "):gsub("^%l", string.upper)
                    Strings[ent] = Strings[ent]..' ('..kitName..')'
                end
            end
            
            nametag.Text.Text = Strings[ent]
            nametag.Text.Color = entitylib.getEntityColor(ent) or color3fromHSV(Color.Hue, Color.Sat, Color.Value)
            nametag.BG.Size = vector2new(nametag.Text.TextBounds.X + 8, nametag.Text.TextBounds.Y + 7)
            Reference[ent] = nametag
            lastUpdate[ent] = 0
        end
    }
    
    local Removed = {
        Normal = function(ent)
            local v = Reference[ent]
            if v then
                Reference[ent] = nil
                Strings[ent] = nil
                Sizes[ent] = nil
                lastUpdate[ent] = nil
                kitCache[ent] = nil
                equipmentCache[ent] = nil
                v:Destroy()
            end
        end,
        Drawing = function(ent)
            local v = Reference[ent]
            if v then
                Reference[ent] = nil
                Strings[ent] = nil
                Sizes[ent] = nil
                lastUpdate[ent] = nil
                kitCache[ent] = nil
                for _, obj in v do
                    pcall(function()
                        obj.Visible = false
                        obj:Remove()
                    end)
                end
            end
        end
    }
    
    local Updated = {
        Normal = function(ent)
            local nametag = Reference[ent]
            if nametag then
                Sizes[ent] = nil
                Strings[ent] = ent.Player and whitelist:tag(ent.Player, true)..(DisplayName.Enabled and ent.Player.DisplayName or ent.Player.Name) or ent.Character.Name
                
                if Health.Enabled then
                    local healthColor = color3fromHSV(math_clamp(ent.Health / ent.MaxHealth, 0, 1) / 2.5, 0.89, 0.75)
                    Strings[ent] = Strings[ent]..' '..math_round(ent.Health)..''
                end
                
                if Distance.Enabled then
                    Strings[ent] = '[%s] '..Strings[ent]
                end
                
                if Equipment.Enabled and ent.Player and store.inventories[ent.Player] then
                    local inventory = store.inventories[ent.Player]
                    local currentEquip = {
                        inventory.hand and inventory.hand.itemType or '',
                        inventory.armor[4] and inventory.armor[4].itemType or '',
                        inventory.armor[5] and inventory.armor[5].itemType or '',
                        inventory.armor[6] and inventory.armor[6].itemType or ''
                    }
                    
                    local equipKey = table.concat(currentEquip, "|")
                    if equipmentCache[ent] ~= equipKey then
                        equipmentCache[ent] = equipKey
                        if nametag.Hand then
                            nametag.Hand.Image = bedwars.getIcon(inventory.hand or {itemType = ''}, true)
                        end
                        if nametag.Helmet then
                            nametag.Helmet.Image = bedwars.getIcon(inventory.armor[4] or {itemType = ''}, true)
                        end
                        if nametag.Chestplate then
                            nametag.Chestplate.Image = bedwars.getIcon(inventory.armor[5] or {itemType = ''}, true)
                        end
                        if nametag.Boots then
                            nametag.Boots.Image = bedwars.getIcon(inventory.armor[6] or {itemType = ''}, true)
                        end
                    end
                end
                
                local size = getfontsize(removeTags(Strings[ent]), nametag.TextSize, nametag.FontFace, vector2new(100000, 100000))
                nametag.Size = udim2fromOffset(size.X + 8, size.Y + 7)
                nametag.Text = Strings[ent]
            end
        end,
        Drawing = function(ent)
            local nametag = Reference[ent]
            if nametag then
                if vape.ThreadFix then setthreadidentity(8) end
                Sizes[ent] = nil
                Strings[ent] = ent.Player and whitelist:tag(ent.Player, true)..(DisplayName.Enabled and ent.Player.DisplayName or ent.Player.Name) or ent.Character.Name
                
                if Health.Enabled then
                    Strings[ent] = Strings[ent]..' '..math_round(ent.Health)
                end
                
                if Distance.Enabled then
                    Strings[ent] = '[%s] '..Strings[ent]
                    nametag.Text.Text = entitylib.isAlive and string_format(Strings[ent], math_floor((entitylib.character.RootPart.Position - ent.RootPart.Position).Magnitude)) or Strings[ent]
                else
                    nametag.Text.Text = Strings[ent]
                end
                
                if ShowKits.Enabled and ent.Player then
                    local kit = ent.Player:GetAttribute('PlayingAsKits')
                    if kit then
                        local kitName = kit:gsub("_", " "):gsub("^%l", string.upper)
                        nametag.Text.Text = nametag.Text.Text..' ('..kitName..')'
                    end
                end
                
                nametag.BG.Size = vector2new(nametag.Text.TextBounds.X + 8, nametag.Text.TextBounds.Y + 7)
                nametag.Text.Color = entitylib.getEntityColor(ent) or color3fromHSV(Color.Hue, Color.Sat, Color.Value)
            end
        end
    }
    
    local ColorFunc = {
        Normal = function(hue, sat, val)
            local color = color3fromHSV(hue, sat, val)
            for i, v in Reference do
                v.TextColor3 = entitylib.getEntityColor(i) or color
            end
        end,
        Drawing = function(hue, sat, val)
            local color = color3fromHSV(hue, sat, val)
            for i, v in Reference do
                v.Text.Color = entitylib.getEntityColor(i) or color
            end
        end
    }
    
    local frameCounter = 0
    local Loop = {
        Normal = function()
            frameCounter = frameCounter + 1
            local currentTime = tick()
            
            for ent, nametag in Reference do
                if DistanceCheck.Enabled then
                    local distance = entitylib.isAlive and (entitylib.character.RootPart.Position - ent.RootPart.Position).Magnitude or math_huge
                    if distance < DistanceLimit.ValueMin or distance > DistanceLimit.ValueMax then
                        nametag.Visible = false
                        continue
                    end
                end
                
                local headPos, headVis = gameCamera:WorldToViewportPoint(ent.RootPart.Position + vector3new(0, ent.HipHeight + 1, 0))
                nametag.Visible = headVis
                if not headVis then continue end
                
                nametag.Position = udim2fromOffset(headPos.X, headPos.Y)
                
                if Distance.Enabled then
                    local mag = entitylib.isAlive and math_floor((entitylib.character.RootPart.Position - ent.RootPart.Position).Magnitude) or 0
                    if Sizes[ent] ~= mag then
                        nametag.Text = string_format(Strings[ent], mag)
                        local size = getfontsize(removeTags(nametag.Text), nametag.TextSize, nametag.FontFace, vector2new(100000, 100000))
                        nametag.Size = udim2fromOffset(size.X + 8, size.Y + 7)
                        Sizes[ent] = mag
                    end
                end
                
                if ShowKits.Enabled and frameCounter % 30 == 0 then
                    local kitIcon = nametag:FindFirstChild('KitIcon')
                    if kitIcon and ent.Player then
                        local kit = ent.Player:GetAttribute('PlayingAsKits')
                        local newKitImage = kit and (kitImageIds[kit:lower()] or kitImageIds["none"]) or kitImageIds["none"]
                        
                        if kitCache[ent] ~= newKitImage then
                            kitIcon.Image = newKitImage
                            kitCache[ent] = newKitImage
                        end
                    end
                end
            end
        end,
        Drawing = function()
            frameCounter = frameCounter + 1
            
            for ent, nametag in Reference do
                if DistanceCheck.Enabled then
                    local distance = entitylib.isAlive and (entitylib.character.RootPart.Position - ent.RootPart.Position).Magnitude or math_huge
                    if distance < DistanceLimit.ValueMin or distance > DistanceLimit.ValueMax then
                        nametag.Text.Visible = false
                        nametag.BG.Visible = false
                        continue
                    end
                end
                
                local headPos, headVis = gameCamera:WorldToViewportPoint(ent.RootPart.Position + vector3new(0, ent.HipHeight + 1, 0))
                nametag.Text.Visible = headVis
                nametag.BG.Visible = headVis
                if not headVis then continue end
                
                if Distance.Enabled then
                    local mag = entitylib.isAlive and math_floor((entitylib.character.RootPart.Position - ent.RootPart.Position).Magnitude) or 0
                    if Sizes[ent] ~= mag then
                        nametag.Text.Text = string_format(Strings[ent], mag)
                        nametag.BG.Size = vector2new(nametag.Text.TextBounds.X + 8, nametag.Text.TextBounds.Y + 7)
                        Sizes[ent] = mag
                    end
                end
                
                nametag.BG.Position = vector2new(headPos.X - (nametag.BG.Size.X / 2), headPos.Y - nametag.BG.Size.Y)
                nametag.Text.Position = nametag.BG.Position + vector2new(4, 3)
            end
        end
    }
    
    NameTags = vape.Categories.Render:CreateModule({
        Name = 'NameTags',
        Function = function(callback)
            if callback then
                methodused = DrawingToggle.Enabled and 'Drawing' or 'Normal'
                frameCounter = 0
                
                if Removed[methodused] then
                    NameTags:Clean(entitylib.Events.EntityRemoved:Connect(Removed[methodused]))
                end
                
                if Added[methodused] then
                    for _, v in entitylib.List do
                        if Reference[v] then Removed[methodused](v) end
                        Added[methodused](v)
                    end
                    NameTags:Clean(entitylib.Events.EntityAdded:Connect(function(ent)
                        if Reference[ent] then Removed[methodused](ent) end
                        Added[methodused](ent)
                    end))
                end
                
                if Updated[methodused] then
                    NameTags:Clean(entitylib.Events.EntityUpdated:Connect(Updated[methodused]))
                    for _, v in entitylib.List do
                        Updated[methodused](v)
                    end
                end
                
                if ColorFunc[methodused] then
                    NameTags:Clean(vape.Categories.Friends.ColorUpdate.Event:Connect(function()
                        ColorFunc[methodused](Color.Hue, Color.Sat, Color.Value)
                    end))
                end
                
                if Loop[methodused] then
                    NameTags:Clean(runService.RenderStepped:Connect(Loop[methodused]))
                end
            else
                if Removed[methodused] then
                    for i in Reference do
                        Removed[methodused](i)
                    end
                end
                lastUpdate = {}
                kitCache = {}
                equipmentCache = {}
            end
        end,
        Tooltip = 'Renders nametags on entities through walls.'
    })
    
    Targets = NameTags:CreateTargets({
        Players = true,
        Function = function()
            if NameTags.Enabled then
                NameTags:Toggle()
                NameTags:Toggle()
            end
        end
    })
    
    FontOption = NameTags:CreateFont({
        Name = 'Font',
        Blacklist = 'Arial',
        Function = function()
            if NameTags.Enabled then
                NameTags:Toggle()
                NameTags:Toggle()
            end
        end
    })
    
    Color = NameTags:CreateColorSlider({
        Name = 'Player Color',
        Function = function(hue, sat, val)
            if NameTags.Enabled and ColorFunc[methodused] then
                ColorFunc[methodused](hue, sat, val)
            end
        end
    })
    
    Scale = NameTags:CreateSlider({
        Name = 'Scale',
        Function = function()
            if NameTags.Enabled then
                NameTags:Toggle()
                NameTags:Toggle()
            end
        end,
        Default = 1,
        Min = 0.1,
        Max = 1.5,
        Decimal = 10
    })
    
    Background = NameTags:CreateSlider({
        Name = 'Transparency',
        Function = function()
            if NameTags.Enabled then
                NameTags:Toggle()
                NameTags:Toggle()
            end
        end,
        Default = 0.5,
        Min = 0,
        Max = 1,
        Decimal = 10
    })
    
    Health = NameTags:CreateToggle({
        Name = 'Health',
        Function = function()
            if NameTags.Enabled then
                NameTags:Toggle()
                NameTags:Toggle()
            end
        end
    })
    
    Distance = NameTags:CreateToggle({
        Name = 'Distance',
        Function = function()
            if NameTags.Enabled then
                NameTags:Toggle()
                NameTags:Toggle()
            end
        end
    })
    
    Equipment = NameTags:CreateToggle({
        Name = 'Equipment',
        Function = function()
            if NameTags.Enabled then
                NameTags:Toggle()
                NameTags:Toggle()
            end
        end
    })
    
    ShowKits = NameTags:CreateToggle({
        Name = 'Show Kits',
        Function = function()
            if NameTags.Enabled then
                NameTags:Toggle()
                NameTags:Toggle()
            end
        end,
        Tooltip = 'Shows player kits with icons in nametags'
    })
    
    DisplayName = NameTags:CreateToggle({
        Name = 'Use Displayname',
        Function = function()
            if NameTags.Enabled then
                NameTags:Toggle()
                NameTags:Toggle()
            end
        end,
        Default = true
    })
    
    Teammates = NameTags:CreateToggle({
        Name = 'Priority Only',
        Function = function()
            if NameTags.Enabled then
                NameTags:Toggle()
                NameTags:Toggle()
            end
        end,
        Default = true
    })
    
    DrawingToggle = NameTags:CreateToggle({
        Name = 'Drawing',
        Function = function()
            if NameTags.Enabled then
                NameTags:Toggle()
                NameTags:Toggle()
            end
        end,
    })
    
    DistanceCheck = NameTags:CreateToggle({
        Name = 'Distance Check',
        Function = function(callback)
            DistanceLimit.Object.Visible = callback
        end
    })
    
    DistanceLimit = NameTags:CreateTwoSlider({
        Name = 'Player Distance',
        Min = 0,
        Max = 256,
        DefaultMin = 0,
        DefaultMax = 64,
        Darker = true,
        Visible = false
    })
end)

run(function()
	local BedAlarm
	local DetectionRange
	local RepeatNotifications
	local NotificationDelay
	local UseDisplayName
	local NotifyKits
	local TepearlCheck
	local TepearlRange
	local HighlightEnemies
	local HighlightColor
	local PlayAlarmSound
	local AlarmSoundId
	local AlarmVolume
	local AlarmActive = false
	local PlayersNearBed = {}
	local LastNotificationTime = {}
	local CachedBed = nil
	local CachedBedPosition = nil
	local LastBedCheck = 0
	local PearlCache = {} 
	local LastPearlCheck = {}
	local ActiveHighlights = {}
	local AlarmSound = nil
	
	local function getKitName(kitId)
		if bedwars.BedwarsKitMeta[kitId] then
			return bedwars.BedwarsKitMeta[kitId].name
		end
		return kitId:gsub("_", " "):gsub("^%l", string.upper)
	end
	
	local function getOwnBed()
		local currentTime = tick()
		
		if CachedBed and CachedBed.Parent and (currentTime - LastBedCheck) < 2 then
			return CachedBed, CachedBedPosition
		end
		
		if not entitylib.isAlive then 
			CachedBed = nil
			CachedBedPosition = nil
			return nil 
		end
		
		local playerTeam = lplr:GetAttribute('Team')
		if not playerTeam then 
			CachedBed = nil
			CachedBedPosition = nil
			return nil 
		end
		
		local tagged = collectionService:GetTagged('bed')
		for _, bed in ipairs(tagged) do
			if bed:GetAttribute('Team'..playerTeam..'NoBreak') then
				CachedBed = bed
				CachedBedPosition = bed.Position
				LastBedCheck = currentTime
				return bed, CachedBedPosition
			end
		end
		
		CachedBed = nil
		CachedBedPosition = nil
		return nil
	end
	
	local function getPlayerName(ent)
		if not ent.Player then return ent.Character.Name end
		return UseDisplayName.Enabled and ent.Player.DisplayName or ent.Player.Name
	end
	
	local function getPlayerKit(ent)
		if not ent.Player then return nil end
		local kit = ent.Player:GetAttribute('PlayingAsKits')
		if kit and kit ~= 'none' then
			return getKitName(kit)
		end
		return nil
	end
	
	local function isHoldingPearl(ent, currentTime)
		if not ent.Player then return false end
		
		local lastCheck = LastPearlCheck[ent] or 0
		if (currentTime - lastCheck) < 0.5 and PearlCache[ent] ~= nil then
			return PearlCache[ent]
		end
		
		local inventory = store.inventories[ent.Player]
		if not inventory then 
			PearlCache[ent] = false
			LastPearlCheck[ent] = currentTime
			return false 
		end
		
		local handItem = inventory.hand
		
		if handItem and handItem.itemType then
			local itemType = handItem.itemType:lower()
			local hasPearl = itemType == 'telepearl' or itemType == 'teleport_pearl' or itemType:find('pearl', 1, true)
			PearlCache[ent] = hasPearl
			LastPearlCheck[ent] = currentTime
			return hasPearl
		end
		
		PearlCache[ent] = false
		LastPearlCheck[ent] = currentTime
		return false
	end
	
	local function createHighlight(ent)
		if not HighlightEnemies.Enabled then return end
		if ActiveHighlights[ent] then return end
		
		local character = ent.Character
		if not character then return end
		
		local highlight = Instance.new("Highlight")
		highlight.Name = "BedAlarmHighlight"
		highlight.Adornee = character
		local hue, sat, val = HighlightColor.Hue, HighlightColor.Sat, HighlightColor.Value
		local color = Color3.fromHSV(hue, sat, val)
		highlight.FillColor = color
		highlight.OutlineColor = color
		highlight.FillTransparency = 0.5
		highlight.OutlineTransparency = 0
		highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
		highlight.Parent = character
		
		ActiveHighlights[ent] = highlight
	end
	
	local function removeHighlight(ent)
		if ActiveHighlights[ent] then
			ActiveHighlights[ent]:Destroy()
			ActiveHighlights[ent] = nil
		end
	end
	
	local function playAlarm()
		if not PlayAlarmSound.Enabled then return end
		
		if AlarmSound and AlarmSound.Playing then
			return
		end
		
		if not AlarmSound then
			AlarmSound = Instance.new("Sound")
			AlarmSound.Name = "BedAlarmSound"
			AlarmSound.SoundId = "rbxassetid://" .. AlarmSoundId.Value
			AlarmSound.Volume = AlarmVolume.Value / 100
			AlarmSound.Looped = true
			AlarmSound.Parent = workspace
		end
		
		AlarmSound.SoundId = "rbxassetid://" .. AlarmSoundId.Value
		AlarmSound.Volume = AlarmVolume.Value / 100
		AlarmSound:Play()
	end
	
	local function stopAlarm()
		if AlarmSound and AlarmSound.Playing then
			AlarmSound:Stop()
		end
	end
	
	local function createNotification(ent, hasPearl)
		local playerName = getPlayerName(ent)
		local message = playerName..' is near your bed!'
		
		if hasPearl then
			message = playerName..' is near your bed WITH A PEARL!'
		end
		
		if NotifyKits.Enabled then
			local kit = getPlayerKit(ent)
			if kit then
				if hasPearl then
					message = playerName..' is near your bed WITH A PEARL! (Kit: '..kit..')'
				else
					message = playerName..' is near your bed! (Kit: '..kit..')'
				end
			end
		end
		
		notif('Bed Alarm', message, 3)
	end
	
	local lastCheckTime = 0
	local function checkPlayers()
		if not BedAlarm.Enabled then return end
		if not entitylib.isAlive then return end
		
		local currentTime = tick()
		
		if (currentTime - lastCheckTime) < 0.1 then
			return
		end
		lastCheckTime = currentTime
		
		local bed, bedPosition = getOwnBed()
		if not bed or not bedPosition then return end
		
		local currentPlayersNear = {}
		local normalRange = DetectionRange.Value
		local pearlRangeEnabled = TepearlCheck.Enabled
		local pearlRange = pearlRangeEnabled and TepearlRange.Value or normalRange
		
		local normalRangeSq = normalRange * normalRange
		local pearlRangeSq = pearlRange * pearlRange
		
		local anyoneNear = false
		
		for _, ent in ipairs(entitylib.List) do
			if not ent.Targetable then continue end
			
			local distanceVector = ent.RootPart.Position - bedPosition
			local distanceSq = distanceVector.X * distanceVector.X + distanceVector.Y * distanceVector.Y + distanceVector.Z * distanceVector.Z
			
			local hasPearl = false
			local inRange = false
			
			if pearlRangeEnabled and distanceSq <= pearlRangeSq then
				hasPearl = isHoldingPearl(ent, currentTime)
				if hasPearl then
					inRange = true
				end
			end
			
			if not inRange and distanceSq <= normalRangeSq then
				inRange = true
			end
			
			if inRange then
				currentPlayersNear[ent] = true
				anyoneNear = true
				
				createHighlight(ent)
				
				local shouldNotify = false
				
				if not PlayersNearBed[ent] then
					shouldNotify = true
				elseif RepeatNotifications.Enabled then
					local lastTime = LastNotificationTime[ent] or 0
					if currentTime - lastTime >= NotificationDelay.Value then
						shouldNotify = true
					end
				end
				
				if shouldNotify then
					createNotification(ent, hasPearl)
					LastNotificationTime[ent] = currentTime
				end
			else
				removeHighlight(ent)
			end
		end
		
		if anyoneNear then
			playAlarm()
		else
			stopAlarm()
		end
		
		for ent, _ in pairs(ActiveHighlights) do
			if not currentPlayersNear[ent] then
				removeHighlight(ent)
			end
		end
		
		PlayersNearBed = currentPlayersNear
	end
	
	BedAlarm = vape.Categories.Utility:CreateModule({
		Name = 'BedAlarm',
		Function = function(callback)
			if callback then
				local bed = getOwnBed()
				if not bed then
					notif('BedAlarm', 'Cannot locate your bed!', 3)
					BedAlarm:Toggle()
					return
				end
				
				AlarmActive = true
				PlayersNearBed = {}
				LastNotificationTime = {}
				PearlCache = {}
				LastPearlCheck = {}
				ActiveHighlights = {}
				lastCheckTime = 0
				
				BedAlarm:Clean(runService.Heartbeat:Connect(checkPlayers))
			else
				AlarmActive = false
				
				stopAlarm()
				if AlarmSound then
					AlarmSound:Destroy()
					AlarmSound = nil
				end
				
				for ent, highlight in pairs(ActiveHighlights) do
					if highlight then
						highlight:Destroy()
					end
				end
				
				table.clear(PlayersNearBed)
				table.clear(LastNotificationTime)
				table.clear(PearlCache)
				table.clear(LastPearlCheck)
				table.clear(ActiveHighlights)
				CachedBed = nil
				CachedBedPosition = nil
			end
		end,
		Tooltip = 'Alerts you when enemies are near your bed'
	})
	
	DetectionRange = BedAlarm:CreateSlider({
		Name = 'Detection Range',
		Function = function() end,
		Default = 30,
		Min = 10,
		Max = 100,
		Tooltip = 'Distance in studs to detect players near bed'
	})
	
	TepearlCheck = BedAlarm:CreateToggle({
		Name = 'Telepearl Check',
		Function = function(callback)
			if TepearlRange and TepearlRange.Object then
				TepearlRange.Object.Visible = callback
			end
		end,
		Default = false,
		Tooltip = 'Extended detection range for players holding pearls'
	})
	
	TepearlRange = BedAlarm:CreateSlider({
		Name = 'Pearl Range',
		Function = function() end,
		Default = 250,
		Min = 100,
		Max = 500,
		Visible = false,
		Tooltip = 'Detection range for players with pearls'
	})
	
	RepeatNotifications = BedAlarm:CreateToggle({
		Name = 'Repeat Notifications',
		Function = function(callback)
			if NotificationDelay and NotificationDelay.Object then
				NotificationDelay.Object.Visible = callback
			end
		end,
		Default = false,
		Tooltip = 'Continue notifying while players remain near bed'
	})
	
	NotificationDelay = BedAlarm:CreateSlider({
		Name = 'Notification Delay',
		Function = function() end,
		Default = 5,
		Min = 1,
		Max = 10,
		Visible = false,
		Tooltip = 'Seconds between repeat notifications'
	})
	
	UseDisplayName = BedAlarm:CreateToggle({
		Name = 'Show Display Name',
		Function = function() end,
		Default = true,
		Tooltip = 'Show player display names instead of usernames'
	})
	
	NotifyKits = BedAlarm:CreateToggle({
		Name = 'Notify Kits',
		Function = function() end,
		Default = true,
		Tooltip = 'Include player kit in notification'
	})
	
	HighlightEnemies = BedAlarm:CreateToggle({
		Name = 'Highlight Enemies',
		Function = function(callback)
			if HighlightColor and HighlightColor.Object then
				HighlightColor.Object.Visible = callback
			end
			
			if not callback then
				for ent, highlight in pairs(ActiveHighlights) do
					if highlight then
						highlight:Destroy()
					end
				end
				table.clear(ActiveHighlights)
			end
		end,
		Default = false,
		Tooltip = 'Highlight enemies near your bed through walls'
	})
	
	HighlightColor = BedAlarm:CreateColorSlider({
		Name = 'Highlight Color',
		Function = function(hue, sat, val)
			local newColor = Color3.fromHSV(hue, sat, val)
			for ent, highlight in pairs(ActiveHighlights) do
				if highlight then
					highlight.FillColor = newColor
					highlight.OutlineColor = newColor
				end
			end
		end,
		Default = 1,
		Visible = false,
		Tooltip = 'Color of the enemy highlight'
	})
	
	PlayAlarmSound = BedAlarm:CreateToggle({
		Name = 'Play Alarm Sound',
		Function = function(callback)
			if AlarmSoundId and AlarmSoundId.Object then
				AlarmSoundId.Object.Visible = callback
			end
			if AlarmVolume and AlarmVolume.Object then
				AlarmVolume.Object.Visible = callback
			end
			
			if not callback then
				stopAlarm()
			end
		end,
		Default = false,
		Tooltip = 'Play alarm sound when enemies are near bed'
	})
	
	AlarmSoundId = BedAlarm:CreateTextBox({
		Name = 'Alarm Sound ID',
		Function = function(value)
			if AlarmSound then
				AlarmSound.SoundId = "rbxassetid://" .. value
			end
		end,
		Default = '6518811702',
		Visible = false,
		Tooltip = 'Roblox sound asset ID'
	})
	
	AlarmVolume = BedAlarm:CreateSlider({
		Name = 'Alarm Volume',
		Function = function(value)
			if AlarmSound then
				AlarmSound.Volume = value / 100
			end
		end,
		Default = 50,
		Min = 1,
		Max = 100,
		Visible = false,
		Tooltip = 'Volume of the alarm sound'
	})
end)
	
run(function()
	local StorageESP
	local List
	local Background
	local Color = {}
	local Reference = {}
	local ChestContents = {} 
	local Folder = Instance.new('Folder')
	Folder.Parent = vape.gui
	
	local function getEnabledItemsSet()
		local set = {}
		for _, v in ipairs(List.ListEnabled) do
			set[v] = true
		end
		return set
	end
	
	local function nearStorageItem(item, enabledSet)
		for itemName in pairs(enabledSet) do
			if item:find(itemName, 1, true) then return itemName end
		end
		return nil
	end
	
	local function refreshAdornee(v)
		local chest = v.Adornee:FindFirstChild('ChestFolderValue')
		chest = chest and chest.Value or nil
		if not chest then
			v.Enabled = false
			return
		end
		
		local chestitems = chest:GetChildren()
		local enabledSet = getEnabledItemsSet()
		
		local newItems = {}
		for _, item in ipairs(chestitems) do
			if enabledSet[item.Name] or nearStorageItem(item.Name, enabledSet) then
				newItems[item.Name] = true
			end
		end
		
		local contentsKey = table.concat(table.create(#chestitems, function(i) return chestitems[i].Name end), "|")
		if ChestContents[v] == contentsKey then
			return 
		end
		ChestContents[v] = contentsKey
		
		for _, obj in ipairs(v.Frame:GetChildren()) do
			if obj:IsA('ImageLabel') and obj.Name ~= 'Blur' then
				if not newItems[obj.Name] then
					obj:Destroy()
				else
					newItems[obj.Name] = nil 
				end
			end
		end
		
		v.Enabled = next(newItems) ~= nil or #v.Frame:GetChildren() > 1 
		
		for itemName in pairs(newItems) do
			local blockimage = Instance.new('ImageLabel')
			blockimage.Name = itemName
			blockimage.Size = UDim2.fromOffset(31, 31)
			blockimage.BackgroundTransparency = 1
			blockimage.Image = bedwars.getIcon({itemType = itemName}, true)
			blockimage.Parent = v.Frame
		end
	end
	
	local function Added(v)
		if Reference[v] then return end
		
		local billboard = Instance.new('BillboardGui')
		billboard.Parent = Folder
		billboard.Name = 'chest'
		billboard.StudsOffsetWorldSpace = Vector3.new(0, 3, 0)
		billboard.Size = UDim2.fromOffset(35, 35)
		billboard.AlwaysOnTop = true
		billboard.Adornee = v
		
		local frame = Instance.new('Frame')
		frame.Size = UDim2.fromScale(1, 1)
		frame.BackgroundColor3 = Color3.fromHSV(Color.Hue, Color.Sat, Color.Value)
		frame.BackgroundTransparency = Background.Enabled and (1 - Color.Opacity) or 1
		frame.BorderSizePixel = 0
		frame.Parent = billboard
		
		local uilist = Instance.new('UIListLayout')
		uilist.FillDirection = Enum.FillDirection.Horizontal
		uilist.HorizontalAlignment = Enum.HorizontalAlignment.Left
		uilist.VerticalAlignment = Enum.VerticalAlignment.Top
		uilist.SortOrder = Enum.SortOrder.LayoutOrder
		uilist.Padding = UDim.new(0, 2)
		uilist.Parent = frame
		
		local blur = addBlur(billboard)
		blur.Name = 'Blur'
		blur.Visible = Background.Enabled
		blur.Parent = frame
		
		Reference[v] = billboard
		ChestContents[v] = ""
		
		refreshAdornee(billboard)
	end
	
	local function Removed(v)
		if Reference[v] then
			Reference[v]:Destroy()
			Reference[v] = nil
			ChestContents[v] = nil
		end
	end
	
	StorageESP = vape.Categories.Render:CreateModule({
		Name = 'Storage ESP',
		Function = function(callback)
			if callback then
				local tagged = collectionService:GetTagged('chest')
				for _, v in ipairs(tagged) do
					Added(v)
				end
				
				StorageESP:Clean(collectionService:GetInstanceAddedSignal('chest'):Connect(Added))
				StorageESP:Clean(collectionService:GetInstanceRemovedSignal('chest'):Connect(Removed))
				
				StorageESP:Clean(runService.Heartbeat:Connect(function()
					for chest, billboard in pairs(Reference) do
						if chest and chest.Parent then
							refreshAdornee(billboard)
						else
							Removed(chest)
						end
					end
				end))
			else
				for chest in pairs(Reference) do
					Removed(chest)
				end
			end
		end,
		Tooltip = 'Displays items in chests'
	})
	
	List = StorageESP:CreateTextList({
		Name = 'Item',
		Function = function()
			table.clear(ChestContents)
			for _, v in pairs(Reference) do
				refreshAdornee(v)
			end
		end
	})
	
	Background = StorageESP:CreateToggle({
		Name = 'Background',
		Function = function(callback)
			if Color.Object then Color.Object.Visible = callback end
			for _, v in pairs(Reference) do
				v.Frame.BackgroundTransparency = 1 - (callback and Color.Opacity or 0)
				local blur = v.Frame:FindFirstChild('Blur')
				if blur then
					blur.Visible = callback
				end
			end
		end,
		Default = true
	})
	
	Color = StorageESP:CreateColorSlider({
		Name = 'Background Color',
		DefaultValue = 0,
		DefaultOpacity = 0.5,
		Function = function(hue, sat, val, opacity)
			for _, v in pairs(Reference) do
				v.Frame.BackgroundColor3 = Color3.fromHSV(hue, sat, val)
				v.Frame.BackgroundTransparency = 1 - opacity
			end
		end,
		Darker = true
	})
end)
	
run(function()
	local AutoKit
	local Legit
	local Toggles = {}
	
	local function kitCollection(id, func, range, specific)
		local objs = type(id) == 'table' and id or collection(id, AutoKit)
		repeat
			if entitylib.isAlive then
				local localPosition = entitylib.character.RootPart.Position
				for _, v in objs do
					if InfiniteFly.Enabled or not AutoKit.Enabled then break end
					local part = not v:IsA('Model') and v or v.PrimaryPart
					if part and (part.Position - localPosition).Magnitude <= (not Legit.Enabled and specific and math.huge or range) then
						func(v)
					end
				end
			end
			task.wait(0.1)
		until not AutoKit.Enabled
	end
	
	local AutoKitFunctions = {
		spider_queen = function()
			local isAiming = false
			local aimingTarget = nil
			
			repeat
				if entitylib.isAlive and bedwars.AbilityController then
					local plr = entitylib.EntityPosition({
						Range = not Legit.Enabled and 80 or 50,
						Part = 'RootPart',
						Players = true,
						Sort = sortmethods.Health
					})
					
					if plr and not isAiming and bedwars.AbilityController:canUseAbility('spider_queen_web_bridge_aim') then
						bedwars.AbilityController:useAbility('spider_queen_web_bridge_aim')
						isAiming = true
						aimingTarget = plr
						task.wait(0.1)
					end
					
					if isAiming and aimingTarget and aimingTarget.RootPart then
						local localPosition = entitylib.character.RootPart.Position
						local targetPosition = aimingTarget.RootPart.Position
						
						local direction
						if Legit.Enabled then
							direction = (targetPosition - localPosition).Unit
						else
							direction = (targetPosition - localPosition).Unit
						end
						
						if bedwars.AbilityController:canUseAbility('spider_queen_web_bridge_fire') then
							bedwars.AbilityController:useAbility('spider_queen_web_bridge_fire', newproxy(true), {
								direction = direction
							})
							isAiming = false
							aimingTarget = nil
							task.wait(0.3)
						end
					end
					
					if isAiming and (not aimingTarget or not aimingTarget.RootPart) then
						isAiming = false
						aimingTarget = nil
					end
					
					local summonAbility = 'spider_queen_summon_spiders'
					if bedwars.AbilityController:canUseAbility(summonAbility) then
						bedwars.AbilityController:useAbility(summonAbility)
					end
				end
				
				task.wait(0.05)
			until not AutoKit.Enabled
		end,
		wizard = function()
			math.randomseed(os.clock() * 1e6)
			local roll = math.random(0,100)
			repeat
				local ability = lplr:GetAttribute("WizardAbility")
				if not ability then
					task.wait(0.85)
					continue
				end
				local plr = entitylib.EntityPosition({
					Range = Legit.Enabled and 32 or 50,
					Part = "RootPart",
					Players = true,
					NPCs = true,
					Sort = sortmethods.Health
				})
				if not plr or not store.hand.tool then
					task.wait(0.85)
					continue
				end
				local itemType = store.hand.tooltype
				local targetPos = plr.RootPart.Position
				if bedwars.AbilityController:canUseAbility(ability) then
					bedwars.AbilityController:useAbility(ability,newproxy(true),{target = targetPos})
				end
				if itemType == "wizard_staff_2" or itemType == "wizard_staff_3" then
					local plr2 = entitylib.EntityPosition({
						Range = Legit.Enabled and 13 or 20,
						Part = "RootPart",
						Players = true,
						Sort = sortmethods.Health
					})

					if plr2 then
						if roll <= 50 then
							if bedwars.AbilityController:canUseAbility("SHOCKWAVE") then
								bedwars.AbilityController:useAbility("SHOCKWAVE",newproxy(true),{target = Vector3.zero})
								 roll = math.random(0,100)
							end
						else
							if bedwars.AbilityController:canUseAbility(ability) then
								bedwars.AbilityController:useAbility(ability,newproxy(true),{target = targetPos})
								 roll = math.random(0,100)
							end
						end
					end
				end
				if itemType == "wizard_staff_3" then
					local plr3 = entitylib.EntityPosition({
						Range = Legit.Enabled and 12 or 18,
						Part = "RootPart",
						Players = true,
						Sort = sortmethods.Health
					})
					if plr3 then
						if roll <= 40 then
							if bedwars.AbilityController:canUseAbility(ability) then
								bedwars.AbilityController:useAbility(ability,newproxy(true),{target = targetPos})
								 roll = math.random(0,100)
							end
						elseif roll <= 70 then
							if bedwars.AbilityController:canUseAbility("SHOCKWAVE") then
								bedwars.AbilityController:useAbility("SHOCKWAVE",newproxy(true),{target = Vector3.zero})
								 roll = math.random(0,100)
							end
						else
							if bedwars.AbilityController:canUseAbility("LIGHTNING_STORM") then
								bedwars.AbilityController:useAbility("LIGHTNING_STORM",newproxy(true),{target = targetPos})
								 roll = math.random(0,100)
							end
						end
					end
				end
				task.wait(0.85)
			until not AutoKit.Enabled
		end,
		necromancer = function()
			local r = 0
			if Legit.Enabled then
				r = 8
			else
				r = 12
			end
			kitCollection('Gravestone', function(v)
				local armorType = v:GetAttribute('ArmorType')
				local weaponType = v:GetAttribute('SwordType')
				local associatedPlayerUserId = v:GetAttribute('GravestonePlayerUserId')
				local secret = v:GetAttribute('GravestoneSecret')
				local position = v:GetAttribute('GravestonePosition')
				if bedwars.Client:Get('ActivateGravestone'):CallServer({skeletonData={armorType=armorType,weaponType=weaponType,associatedPlayerUserId=associatedPlayerUserId},secret=secret,position=position}) then
					if Legit.Enabled then
						bedwars.GameAnimationUtil:playAnimation(lplr.Character, bedwars.AnimationType.PUNCH)
						bedwars.ViewmodelController:playAnimation(bedwars.AnimationType.FP_USE_ITEM)
						bedwars.SoundManager:playSound(bedwars.SoundList.GRAVESTONE_USE)
					end
				end
			end, r, false)
		end,
		midnight = function()
			repeat
				if not entitylib.isAlive then
					task.wait(0.1)
					continue
				end
				
				if bedwars.AbilityController:canUseAbility('midnight') then
					local plr = entitylib.EntityPosition({
						Range = Legit.Enabled and 20 or 30,
						Part = 'RootPart',
						Players = true,
						NPCs = false,
						Sort = sortmethods.Distance
					})
				
					if plr or not Legit.Enabled then
						bedwars.AbilityController:useAbility('midnight')
						task.wait(0.5)
					end
				end
				
				task.wait(0.1)
			until not AutoKit.Enabled
		end,
		fisherman = function()
			local old = bedwars.FishingMinigameController.startMinigame
			bedwars.FishingMinigameController.startMinigame = function(_, _, result)
				if Legit.Enabled then
					local Chance = 50
					local rng = (math.random((Chance/3),(Chance/2))) - math.random()
					if rng <= 18 then
						bedwars.GameAnimationUtil:playAnimation(lplr.Character, bedwars.AnimationType.FISHING_ROD_PULLING)
						task.wait(math.random(2,4) - math.random())
						result({win = true})
					else
						result({win = false})
					end
				else
					result({win = true})
				end
			end
		
			AutoKit:Clean(function()
				bedwars.FishingMinigameController.startMinigame = old
			end)
		end,
		sorcerer = function()
			local r = 0
						if Legit.Enabled then
				r = 12
			else
				r = 16
			end
			kitCollection('alchemy_crystal', function(v)
			    bedwars.Client:Get("CollectCollectableEntity"):SendToServer({id = v:GetAttribute("Id"),collectableName = v.Name})
			end, r, false)
		end,
		davey = function()
			local old = bedwars.CannonHandController.launchSelf
			bedwars.CannonHandController.launchSelf = function(...)
				local res = {old(...)}
				local self, block = ...
	
				if block:GetAttribute('PlacedByUserId') == lplr.UserId and (block.Position - entitylib.character.RootPart.Position).Magnitude < 30 then
					task.spawn(bedwars.breakBlock, block, false, nil, true)
				end
	
				return unpack(res)
			end
	
			AutoKit:Clean(function()
				bedwars.CannonHandController.launchSelf = old
			end)
		end,
		battery = function()
			repeat
				if entitylib.isAlive then
					local localPosition = entitylib.character.RootPart.Position
					for i, v in bedwars.BatteryEffectsController.liveBatteries do
						if (v.position - localPosition).Magnitude <= 10 then
							local BatteryInfo = bedwars.BatteryEffectsController:getBatteryInfo(i)
							if not BatteryInfo or BatteryInfo.activateTime >= workspace:GetServerTimeNow() or BatteryInfo.consumeTime + 0.1 >= workspace:GetServerTimeNow() then continue end
							BatteryInfo.consumeTime = workspace:GetServerTimeNow()
							bedwars.Client:Get(remotes.ConsumeBattery):SendToServer({batteryId = i})
						end
					end
				end
				task.wait(0.1)
			until not AutoKit.Enabled
		end,
        alchemist = function()
			local r= 0
						if Legit.Enabled then
				r = 8
			else
				r = 16
			end
			kitCollection('alchemist_ingedients', function(v)
			    bedwars.Client:Get("CollectCollectableEntity"):SendToServer({id = v:GetAttribute("Id"),collectableName = v.Name})
			end, r, false)
        end,
		defender = function()
		    repeat
			    if not entitylib.isAlive then task.wait(0.1); continue end
				local handItem = lplr.Character:FindFirstChild('HandInvItem')
				local hasScanner = false
				if handItem and handItem.Value then
					local itemType = handItem.Value.Name
					hasScanner = itemType:find('defense_scanner')
				end
				
				if not hasScanner then
					task.wait(0.1)
					continue
				end

				for i, v in workspace:GetChildren() do
					if v:IsA("BasePart") then
						if v.Name == "DefenderSchematicBlock" then
							v.Transparency = 0.85
							v.Grid.Transparency = 1
							local BP = bedwars.BlockController:getBlockPosition(v.Position)
							bedwars.Client:Get("DefenderRequestPlaceBlock"):CallServer({["blockPos"] = BP})
							pcall(function()
								local sounds = {
									bedwars.SoundList.DEFENDER_UPGRADE_DEFENSE_04,
									bedwars.SoundList.DEFENDER_UPGRADE_DEFENSE_03,
									bedwars.SoundList.DEFENDER_UPGRADE_DEFENSE_02,
									bedwars.SoundList.DEFENDER_UPGRADE_DEFENSE_01
								}

								for i = 4, 1, -1 do
									bedwars.SoundManager:playSound(sounds[i], {
										position = BP,
										playbackSpeedMultiplier = 0.8
									})
									task.wait(0.082)
								end
							end)
							
							task.wait(Legit.Enabled and math.random(1,2) - math.random() or (0.5 - math.random()))
						end
					end
				end

				AutoKit:Clean(workspace.ChildAdded:Connect(function(v)
					if v:IsA("BasePart") then
						if v.Name == "DefenderSchematicBlock" then
							v.Transparency = 0.85
							v.Grid.Transparency = 1
							local BP = bedwars.BlockController:getBlockPosition(v.Position)
							bedwars.Client:Get("DefenderRequestPlaceBlock"):SendToServer({["blockPos"] = BP})
							pcall(function()
								local sounds = {
									bedwars.SoundList.DEFENDER_UPGRADE_DEFENSE_04,
									bedwars.SoundList.DEFENDER_UPGRADE_DEFENSE_03,
									bedwars.SoundList.DEFENDER_UPGRADE_DEFENSE_02,
									bedwars.SoundList.DEFENDER_UPGRADE_DEFENSE_01
								}

								for i = 4, 1, -1 do
									bedwars.SoundManager:playSound(sounds[i], {
										position = BP,
										playbackSpeedMultiplier = 0.8
									})
									task.wait(0.082)
								end
							end)
							
							task.wait(math.random(1,2) - math.random())
						end
					end
				end))
				task.wait(0.1)
			until not AutoKit.Enabled
		end,
		block_kicker = function()
			local old = bedwars.BlockKickerKitController.getKickBlockProjectileOriginPosition
			bedwars.BlockKickerKitController.getKickBlockProjectileOriginPosition = function(...)
				local origin, dir = select(2, ...)
				local plr = entitylib.EntityMouse({
					Part = 'RootPart',
					Range = Legit.Enabled and 50 or 250,
					Origin = origin,
					Players = true,
					Wallcheck = Legit.Enabled
				})
		
				if plr then
					local calc = prediction.SolveTrajectory(origin, 100, 20, plr.RootPart.Position, plr.RootPart.Velocity, workspace.Gravity, plr.HipHeight, plr.Jumping and 42.6 or nil)
		
					if calc then
						for i, v in debug.getstack(2) do
							if v == dir then
								debug.setstack(2, i, CFrame.lookAt(origin, calc).LookVector)
							end
						end
					end
				end
		
				return old(...)
			end
		
			AutoKit:Clean(function()
				bedwars.BlockKickerKitController.getKickBlockProjectileOriginPosition = old
			end)
		end,
		cat = function()
			local old = bedwars.CatController.leap
			bedwars.CatController.leap = function(...)
				vapeEvents.CatPounce:Fire()
				return old(...)
			end
	
			AutoKit:Clean(function()
				bedwars.CatController.leap = old
			end)
		end,
		dragon_slayer = function()
			kitCollection('KaliyahPunchInteraction', function(v)
				local character = game:GetService("Players").LocalPlayer.Character
				if not character or not character.PrimaryPart then return end
				
				bedwars.DragonSlayerController:deleteEmblem(v)
				
				local playerPos = character:GetPrimaryPartCFrame().Position
				local targetPos = v:GetPrimaryPartCFrame().Position * Vector3.new(1, 0, 1) + Vector3.new(0, playerPos.Y, 0)
				local lookAtCFrame = CFrame.new(playerPos, targetPos)
				
				character:PivotTo(lookAtCFrame)
				
				bedwars.DragonSlayerController:playPunchAnimation(lookAtCFrame - lookAtCFrame.Position)
				
				bedwars.Client:Get("RequestDragonPunch"):SendToServer({
					target = v
				})
			end, 18, true)
		end,
		ice_queen = function()
			repeat
				if not entitylib.isAlive then
					task.wait(0.1)
					continue
				end
				
				if bedwars.AbilityController:canUseAbility('ice_queen') then
					local plr = entitylib.EntityPosition({
						Range = Legit.Enabled and 20 or 30,
						Part = 'RootPart',
						Players = true,
						NPCs = false,
						Sort = sortmethods.Distance
					})
				
					if plr or not Legit.Enabled then
						bedwars.AbilityController:useAbility('ice_queen')
						task.wait(0.5)
					end
				end
				
				task.wait(0.1)
			until not AutoKit.Enabled
		end,
		drill = function()
			repeat
				if not AutoKit.Enabled then
					break
				end
		
				local foundDrill = false
				for _, child in workspace:GetDescendants() do
					if child:IsA("Model") and child.Name == "Drill" then
						local drillPrimaryPart = child.PrimaryPart
						if drillPrimaryPart then
							foundDrill = true
							local args = {
								{
									drill = child
								}
							}
							local success, err = pcall(function()
								game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("node_modules"):WaitForChild("@rbxts"):WaitForChild("net"):WaitForChild("out"):WaitForChild("_NetManaged"):WaitForChild("ExtractFromDrill"):FireServer(unpack(args))
							end)
		
							task.wait(0.05)
						end
					elseif child:IsA("BasePart") and child.Name == "Drill" then
						foundDrill = true
						local args = {
							{
								drill = child
							}
						}
						local success, err = pcall(function()
							game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("node_modules"):WaitForChild("@rbxts"):WaitForChild("net"):WaitForChild("out"):WaitForChild("_NetManaged"):WaitForChild("ExtractFromDrill"):FireServer(unpack(args))
						end)
		
						task.wait(0.05)
					end
				end
				task.wait(0.5)
			until not AutoKit.Enabled
		end,
		hannah = function()
			local r = 0
					if Legit.Enabled then
				r = 15
			else
				r = 30
			end
			kitCollection('HannahExecuteInteraction', function(v)
				local billboard = bedwars.Client:Get(remotes.HannahKill):CallServer({
					user = lplr,
					victimEntity = v
				}) and v:FindFirstChild('Hannah Execution Icon')
		
				if billboard then
					billboard:Destroy()
				end
			end, r, true)
		end,
		jailor = function()
			local r = 0
			if Legit.Enabled then
				r = 9
			else
				r = 20
			end
			kitCollection('jailor_soul', function(v)
				bedwars.JailorController:collectEntity(lplr, v, 'JailorSoul')
			end, r, false)
		end,
		grim_reaper = function()
			local r = 0
			if Legit.Enabled then
				r = 35
			else
				r = 120
			end
			kitCollection(bedwars.GrimReaperController.soulsByPosition, function(v)
				if entitylib.isAlive and lplr.Character:GetAttribute('Health') <= (lplr.Character:GetAttribute('MaxHealth') / 4) and (not lplr.Character:GetAttribute('GrimReaperChannel')) then
					bedwars.Client:Get(remotes.ConsumeSoul):CallServer({
						secret = v:GetAttribute('GrimReaperSoulSecret')
					})
				end
			end,  r, false)
		end,
		farmer_cletus = function()
			local r = 0
			if Legit.Enabled then
				r = 5
			else
				r = 10
			end
			
			kitCollection('HarvestableCrop', function(v)
				bedwars.GameAnimationUtil:playAnimation(lplr.Character, bedwars.AnimationType.PUNCH)
				bedwars.ViewmodelController:playAnimation(bedwars.AnimationType.FP_USE_ITEM)
				bedwars.SoundManager:playSound(bedwars.SoundList.CROP_HARVEST)
				
				bedwars.Client:Get('CropHarvest'):CallServer({
					position = bedwars.BlockController:getBlockPosition(v.Position)
				})
			end, r, false)
		end,
		melody = function()
			repeat
				local mag, hp, ent = 30, math.huge
				if entitylib.isAlive then
					local localPosition = entitylib.character.RootPart.Position
					for _, v in entitylib.List do
						if v.Player and v.Player:GetAttribute('Team') == lplr:GetAttribute('Team') then
							local newmag = (localPosition - v.RootPart.Position).Magnitude
							if newmag <= mag and v.Health < hp and v.Health < v.MaxHealth then
								mag, hp, ent = newmag, v.Health, v
							end
						end
					end
				end
	
				if ent and getItem('guitar') then
					bedwars.Client:Get(remotes.GuitarHeal):SendToServer({
						healTarget = ent.Character
					})
				end
	
				task.wait(0.1)
			until not AutoKit.Enabled
		end,
		mimic = function()
			repeat
				if not entitylib.isAlive then
					task.wait(0.1)
					continue
				end
				
				local localPosition = entitylib.character.RootPart.Position
				for _, v in entitylib.List do
					if v.Targetable and v.Character and v.Player then
						local distance = (v.RootPart.Position - localPosition).Magnitude
						if distance <= (Legit.Enabled and 12 or 30) then
							if collectionService:HasTag(v.Character, "MimicBLockPickPocketPlayer") then
								pcall(function()
									local success = replicatedStorage:WaitForChild("rbxts_include"):WaitForChild("node_modules"):WaitForChild("@rbxts"):WaitForChild("net"):WaitForChild("out"):WaitForChild("_NetManaged"):WaitForChild("MimicBlockPickPocketPlayer"):InvokeServer(v.Player)
								end)
								task.wait(0.5)
							end
						end
					end
				end
				
				task.wait(0.1)
			until not AutoKit.Enabled
		end,
		pinata = function()
			local r = 0
					if Legit.Enabled then
				r = 8
			else
				r =18
			end
			kitCollection(lplr.Name..':pinata', function(v)
				if getItem('candy') then
					bedwars.Client:Get('DepositCoins'):CallServer(v)
				end
			end,  r, true)
		end,
		spirit_assassin = function()
			local r = Legit.Enabled and 35 or 120
					if Legit.Enabled then
				r = 35
			else
				r = 120
			end
			kitCollection('EvelynnSoul', function(v)
				bedwars.SpiritAssassinController:useSpirit(lplr, v)
			end, r , true)
		end,
		void_knight = function()
			repeat
				if not entitylib.isAlive then
					task.wait(0.1)
					continue
				end
				
				local currentTier = lplr:GetAttribute('VoidKnightTier') or 0
				local currentProgress = lplr:GetAttribute('VoidKnightProgress') or 0
				local currentKills = lplr:GetAttribute('VoidKnightKills') or 0
				local haltedProgress = lplr:GetAttribute('VoidKnightHaltedProgress')
				
				if haltedProgress then
					task.wait(0.5)
					continue
				end
				
				if currentTier < 4 then
					if currentTier < 3 then
						local ironAmount = getItem('iron')
						ironAmount = ironAmount and ironAmount.amount or 0
						
						if ironAmount >= 10 and bedwars.AbilityController:canUseAbility('void_knight_consume_iron') then
							bedwars.AbilityController:useAbility('void_knight_consume_iron')
							task.wait(0.5)
						end
					end
					
					if currentTier >= 2 and currentTier < 4 then
						local emeraldAmount = getItem('emerald')
						emeraldAmount = emeraldAmount and emeraldAmount.amount or 0
						
						if emeraldAmount >= 1 and bedwars.AbilityController:canUseAbility('void_knight_consume_emerald') then
							bedwars.AbilityController:useAbility('void_knight_consume_emerald')
							task.wait(0.5)
						end
					end
				end
				
				if currentTier >= 4 and bedwars.AbilityController:canUseAbility('void_knight_ascend') then
					local shouldAscend = false
					
					local health = lplr.Character:GetAttribute('Health') or 100
					local maxHealth = lplr.Character:GetAttribute('MaxHealth') or 100
					if health < (maxHealth * 0.5) then
						shouldAscend = true
					end
					
					if not shouldAscend then
						local plr = entitylib.EntityPosition({
							Range = Legit.Enabled and 30 or 50,
							Part = 'RootPart',
							Players = true,
							Sort = sortmethods.Health
						})
						if plr then
							shouldAscend = true
						end
					end
					
					if shouldAscend then
						bedwars.AbilityController:useAbility('void_knight_ascend')
						task.wait(16)
					end
				end
				
				task.wait(0.5)
			until not AutoKit.Enabled
		end,
		void_dragon = function()
			local oldflap = bedwars.VoidDragonController.flapWings
			local flapped
	
			bedwars.VoidDragonController.flapWings = function(self)
				if not flapped and bedwars.Client:Get(remotes.DragonFly):CallServer() then
					local modifier = bedwars.SprintController:getMovementStatusModifier():addModifier({
						blockSprint = true,
						constantSpeedMultiplier = 2
					})
					self.SpeedMaid:GiveTask(modifier)
					self.SpeedMaid:GiveTask(function()
						flapped = false
					end)
					flapped = true
				end
			end
	
			AutoKit:Clean(function()
				bedwars.VoidDragonController.flapWings = oldflap
			end)
	
			repeat
				if not entitylib.isAlive then
					task.wait(0.1)
					continue
				end
				
				if bedwars.VoidDragonController.inDragonForm then
					local plr = entitylib.EntityPosition({
						Range = 30,
						Part = 'RootPart',
						Players = true
					})
	
					if plr then
						bedwars.Client:Get(remotes.DragonBreath):SendToServer({
							player = lplr,
							targetPoint = plr.RootPart.Position
						})
					end
				end
				task.wait(0.1)
			until not AutoKit.Enabled
		end,
		cactus = function()
			repeat
				if not entitylib.isAlive then
					task.wait(0.1)
					continue
				end
				
				if bedwars.AbilityController:canUseAbility('cactus_fire') then
					local plr = entitylib.EntityPosition({
						Range = Legit.Enabled and 60 or 80,
						Part = 'RootPart',
						Players = true,
						NPCs = false,
						Sort = sortmethods.Health
					})
					
					if plr then
						bedwars.AbilityController:useAbility('cactus_fire')
						task.wait(0.5)
					end
				end
				
				task.wait(0.1)
			until not AutoKit.Enabled
		end,
		card = function()
			repeat
				if not entitylib.isAlive then
					task.wait(0.1)
					continue
				end
				
				if bedwars.AbilityController:canUseAbility('CARD_THROW') then
					local plr = entitylib.EntityPosition({
						Range = Legit.Enabled and 50 or 80,
						Part = 'RootPart',
						Players = true,
						NPCs = false,
						Sort = sortmethods.Health
					})
					
					if plr then
						bedwars.AbilityController:useAbility('CARD_THROW')
						
						task.wait(0.1)
						pcall(function()
							replicatedStorage:WaitForChild("rbxts_include"):WaitForChild("node_modules"):WaitForChild("@rbxts"):WaitForChild("net"):WaitForChild("out"):WaitForChild("_NetManaged"):WaitForChild("AttemptCardThrow"):FireServer({
								targetEntityInstance = plr.Character
							})
						end)
						
						task.wait(0.5)
					end
				end
				
				task.wait(0.1)
			until not AutoKit.Enabled
		end,
		black_market_trader = function()
			local r = 0
			if Legit.Enabled then
				r = 8
			else
				r = 16
			end
			kitCollection('shadow_coin', function(v)
			    bedwars.Client:Get("CollectCollectableEntity"):SendToServer({id = v:GetAttribute("Id"),collectableName = 'shadow_coin'})
			end, r, false)
		end,
		melody = function()
				local r = 0
			if Legit.Enabled then
				r = 15
			else
				r = 45
			end
			repeat

				local mag, hp, ent = r, math.huge
				if entitylib.isAlive then
					local localPosition = entitylib.character.RootPart.Position
					for _, v in entitylib.List do
						if v.Player and v.Player:GetAttribute('Team') == lplr:GetAttribute('Team') then
							local newmag = (localPosition - v.RootPart.Position).Magnitude
							if newmag <= mag and v.Health < hp and v.Health < v.MaxHealth then
								mag, hp, ent = newmag, v.Health, v
							end
						end
					end
				end
		
				if ent and getItem('guitar') then
					bedwars.Client:Get(remotes.GuitarHeal):SendToServer({
						healTarget = ent.Character
					})
				end
		
				task.wait(0.1)
			until not AutoKit.Enabled
		end,
		beekeeper = function()
			local r =  0
						if Legit.Enabled then
				r = 8
			else
				r = 16
			end
			kitCollection('bee', function(v)
				bedwars.Client:Get(remotes.BeePickup):SendToServer({beeId = v:GetAttribute('BeeId')})
			end,r, false)
		end,
		summoner = function()
			local lastAttackTime = 0
			local attackCooldown = 0.65
				
			repeat
				if not entitylib.isAlive then
					task.wait(0.1)
					continue
				end
					
				local isCasting = false
				if Legit.Enabled then
					if lplr.Character:GetAttribute("Casting") or 
					lplr.Character:GetAttribute("UsingAbility") or
					lplr.Character:GetAttribute("SummonerCasting") then
						isCasting = true
					end
						
					local humanoid = lplr.Character:FindFirstChildOfClass("Humanoid")
					if humanoid and humanoid:GetState() == Enum.HumanoidStateType.Freefall then
						isCasting = true
					end
				end
					
				if Legit.Enabled and isCasting then
					task.wait(0.1)
					continue
				end
					
				if (workspace:GetServerTimeNow() - lastAttackTime) < attackCooldown then
					task.wait(0.1)
					continue
				end
					
				local handItem = lplr.Character:FindFirstChild('HandInvItem')
				local hasClaw = false
				if handItem and handItem.Value then
					local itemType = handItem.Value.Name
					hasClaw = itemType:find('summoner_claw')
				end
					
				if not hasClaw then
					task.wait(0.1)
					continue
				end
					
				local range = Legit.Enabled and 23 or 35
				local plr = entitylib.EntityPosition({
					Range = range, 
					Part = 'RootPart',
					Players = true,
					NPCs = true,
					Sort = sortmethods.Health
				})

				if plr then
					local distance = (entitylib.character.RootPart.Position - plr.RootPart.Position).Magnitude
					if Legit.Enabled and distance > 23 then
						plr = nil 
					end
				end

				if plr and (not Legit.Enabled or (lplr.Character:GetAttribute('Health') or 0) > 0) then
					local localPosition = entitylib.character.RootPart.Position
					local shootDir = CFrame.lookAt(localPosition, plr.RootPart.Position).LookVector
					localPosition += shootDir * math.max((localPosition - plr.RootPart.Position).Magnitude - 16, 0)

					lastAttackTime = workspace:GetServerTimeNow()

					pcall(function()
						bedwars.AnimationUtil:playAnimation(lplr, bedwars.GameAnimationUtil:getAssetId(bedwars.AnimationType.SUMMONER_CHARACTER_SWIPE), {
							looped = false
						})
					end)

					task.spawn(function()
						pcall(function()
							local clawModel = replicatedStorage.Assets.Misc.Kaida.Summoner_DragonClaw:Clone()
									
							clawModel.Parent = workspace
								
							if gameCamera.CFrame.Position and (gameCamera.CFrame.Position - entitylib.character.RootPart.Position).Magnitude < 1 then
								for _, part in clawModel:GetDescendants() do
									if part:IsA('MeshPart') then
										part.Transparency = 0.6
									end
								end
							end
								
							local rootPart = entitylib.character.RootPart
							local Unit = Vector3.new(shootDir.X, 0, shootDir.Z).Unit
							local startPos = rootPart.Position + Unit:Cross(Vector3.new(0, 1, 0)).Unit * -1 * 5 + Unit * 6
							local direction = (startPos + shootDir * 13 - startPos).Unit
							local cframe = CFrame.new(startPos, startPos + direction)
							
							clawModel:PivotTo(cframe)
							clawModel.PrimaryPart.Anchored = true
							
							if clawModel:FindFirstChild('AnimationController') then
								local animator = clawModel.AnimationController:FindFirstChildOfClass('Animator')
								if animator then
									bedwars.AnimationUtil:playAnimation(animator, bedwars.GameAnimationUtil:getAssetId(bedwars.AnimationType.SUMMONER_CLAW_ATTACK), {
										looped = false,
										speed = 1
									})
								end
							end
								
							pcall(function()
								local sounds = {
									bedwars.SoundList.SUMMONER_CLAW_ATTACK_1,
									bedwars.SoundList.SUMMONER_CLAW_ATTACK_2,
									bedwars.SoundList.SUMMONER_CLAW_ATTACK_3,
									bedwars.SoundList.SUMMONER_CLAW_ATTACK_4
								}
								bedwars.SoundManager:playSound(sounds[math.random(1, #sounds)], {
									position = rootPart.Position
								})
							end)
								
							task.wait(0.65)
							clawModel:Destroy()
						end)
					end)

					bedwars.Client:Get(remotes.SummonerClawAttack):SendToServer({
						position = localPosition,
						direction = shootDir,
						clientTime = workspace:GetServerTimeNow()
					})
				end

				task.wait(0.1)
				until not AutoKit.Enabled
		end,
		bigman = function()
			local r = 0
			if Legit.Enabled then
				r = 8
			else
				r = 12
			end

			kitCollection('treeOrb', function(v)
				bedwars.GameAnimationUtil:playAnimation(lplr, bedwars.AnimationType.PUNCH)
				bedwars.ViewmodelController:playAnimation(bedwars.AnimationType.FP_USE_ITEM)
				bedwars.SoundManager:playSound(bedwars.SoundList.CROP_HARVEST)
				
				if bedwars.Client:Get('ConsumeTreeOrb'):CallServer({
					treeOrbSecret = v:GetAttribute('TreeOrbSecret')
				}) then
					v:Destroy()
				end
			end, r, false)
		end,
		star_collector = function()
			local r =  Legit.Enabled and 10 or 20
					if Legit.Enabled then
				r = 10
			else
				r = 20
			end
			kitCollection('stars', function(v)
				bedwars.StarCollectorController:collectEntity(lplr, v, v.Name)
			end, r, false)
		end,
		spirit_summoner = function()
			repeat
				if not entitylib.isAlive then
					task.wait(0.1)
					continue
				end
				
				local hasStaff = false
				for _, item in store.inventory.inventory.items do
					if item.itemType == 'spirit_staff' then
						hasStaff = true
						break
					end
				end
				
				if hasStaff then
					local spiritCount = lplr:GetAttribute('ReadySummonedAttackSpirits') or 0
					if spiritCount < 10 then
						local hasStone = false
						for _, item in store.inventory.inventory.items do
							if item.itemType == 'summon_stone' then
								hasStone = true
								break
							end
						end
						
						if hasStone and bedwars.AbilityController:canUseAbility('summon_attack_spirit') then
							bedwars.AbilityController:useAbility('summon_attack_spirit')
							task.wait(0.5)
						end
					end
				end
				
				task.wait(0.2)
			until not AutoKit.Enabled
		end,
		metal_detector = function()
			local r = 0
					if Legit.Enabled then
				r = 8
			else
				r = 10
			end
			kitCollection('hidden-metal', function(v)
				if Legit.Enabled then
					bedwars.GameAnimationUtil:playAnimation(lplr,bedwars.AnimationType.SHOVEL_DIG)
					bedwars.SoundManager:playSound(bedwars.SoundList.SNAP_TRAP_CONSUME_MARK)
					bedwars.Client:Get('CollectCollectableEntity'):SendToServer({
						id = v:GetAttribute('Id')
					})
				else
					bedwars.Client:Get('CollectCollectableEntity'):SendToServer({
						id = v:GetAttribute('Id')
					})
				end
			end, r, false)
		end,
		mage = function()
			kitCollection('ElementTome', function(v)
				local secret = v:GetAttribute('TomeSecret')
				if secret then
					bedwars.GameAnimationUtil:playAnimation(lplr, bedwars.AnimationType.PUNCH)
					bedwars.ViewmodelController:playAnimation(bedwars.AnimationType.FP_USE_ITEM)
					
					local result = replicatedStorage:WaitForChild("rbxts_include"):WaitForChild("node_modules"):WaitForChild("@rbxts"):WaitForChild("net"):WaitForChild("out"):WaitForChild("_NetManaged"):WaitForChild("LearnElementTome"):InvokeServer({
						secret = secret
					})
					
					if result and result.success then
						v:Destroy()
						task.wait(0.5)
					end
				end
			end, 10, false)
		end,
		warlock = function()
			local lastTarget
			repeat
				if not entitylib.isAlive then
					lastTarget = nil
					task.wait(0.1)
					continue
				end
				
				if store.hand.tool and store.hand.tool.Name == 'warlock_staff' then
					local plr = entitylib.EntityPosition({
						Range = 30,
						Part = 'RootPart',
						Players = true,
						NPCs = false
					})
	
					if plr and plr.Character ~= lastTarget then
						if not bedwars.Client:Get(remotes.WarlockTarget):CallServer({
							target = plr.Character
						}) then
							plr = nil
						end
					end
	
					lastTarget = plr and plr.Character
				else
					lastTarget = nil
				end
	
				task.wait(0.1)
			until not AutoKit.Enabled
		end
	}
	
	AutoKit = vape.Categories.Utility:CreateModule({
		Name = 'AutoKit',
		Function = function(callback)
			if callback then
				repeat task.wait() until store.equippedKit ~= '' and store.matchState ~= 0 or (not AutoKit.Enabled)
				if AutoKit.Enabled and AutoKitFunctions[store.equippedKit] and Toggles[store.equippedKit].Enabled then
					AutoKitFunctions[store.equippedKit]()
				end
			end
		end,
		Tooltip = 'Automatically uses kit abilities.'
	})
	Legit = AutoKit:CreateToggle({Name = 'Legit Range'})
	local sortTable = {}
	for i in AutoKitFunctions do
		table.insert(sortTable, i)
	end
	table.sort(sortTable, function(a, b)
		return bedwars.BedwarsKitMeta[a].name < bedwars.BedwarsKitMeta[b].name
	end)
	for _, v in sortTable do
		Toggles[v] = AutoKit:CreateToggle({
			Name = bedwars.BedwarsKitMeta[v].name,
			Default = true
		})
	end
end)

run(function()
	local CannonHandController = bedwars.CannonHandController
	local CannonController = bedwars.CannonController
	local oldLaunchSelf = CannonHandController.launchSelf
	local oldStopAiming = CannonController.stopAiming
	local oldStartAiming = CannonController.startAiming
	local BetterDavey
	local BetterDaveyAutojump
	local BetterDaveyAutoLaunch
	local BetterDaveyAutoBreak
	local BetterDaveyPickaxeCheck
	local BetterDaveyAutoSwitch
	local CannonESP
	local ESPBackground
	local ESPColor = {}
	local Folder = Instance.new('Folder')
	Folder.Parent = vape.gui
	local espCache = {}
	local isLaunching = false

	local function getPickaxeSlot()
		for i, v in pairs(store.inventory.hotbar) do
			if v.item and bedwars.ItemMeta[v.item.itemType] then
				local meta = bedwars.ItemMeta[v.item.itemType]
				if meta.breakBlock then
					return i - 1
				end
			end
		end
		return nil
	end

	local function isHoldingPickaxe()
		if not entitylib.isAlive then return false end
		local handItem = store.hand
		if not handItem or not handItem.tool then return false end
		local itemName = handItem.tool.Name:lower()
		return itemName:find("pickaxe") or
			   itemName:find("drill") or
			   itemName:find("gauntlet") or
			   itemName:find("hammer") or
			   itemName:find("axe")
	end

	local function isHoldingWoodPickaxe()
		if not entitylib.isAlive then return false end
		local handItem = store.hand
		if not handItem or not handItem.tool then return false end
		local itemName = handItem.tool.Name:lower()
		return itemName:find("wood") and itemName:find("pickaxe")
	end

	local function getNearestCannon()
		if not entitylib.isAlive then return nil end
		local nearest
		local nearestDist = math.huge
		for i, v in pairs(CannonController.getCannons()) do
			pcall(function()
				local dist = (v.Position - entitylib.character.RootPart.Position).Magnitude
				if dist < nearestDist and dist < 30 then
					nearestDist = dist
					nearest = v
				end
			end)
		end
		return nearest
	end

	local function createCannonESP(cannon)
		if not cannon or espCache[cannon] then return end
		local billboard = Instance.new('BillboardGui')
		billboard.Parent = Folder
		billboard.Name = 'CannonESP'
		billboard.StudsOffsetWorldSpace = Vector3.new(0, 3, 0)
		billboard.Size = UDim2.fromOffset(40, 40)
		billboard.AlwaysOnTop = true
		billboard.Adornee = cannon
		local blur = addBlur(billboard)
		blur.Visible = ESPBackground.Enabled
		local image = Instance.new('ImageLabel')
		image.Size = UDim2.fromOffset(40, 40)
		image.Position = UDim2.fromScale(0.5, 0.5)
		image.AnchorPoint = Vector2.new(0.5, 0.5)
		image.BackgroundColor3 = Color3.fromHSV(ESPColor.Hue, ESPColor.Sat, ESPColor.Value)
		image.BackgroundTransparency = 1 - (ESPBackground.Enabled and ESPColor.Opacity or 0)
		image.BorderSizePixel = 0
		image.Image = bedwars.getIcon({itemType = 'cannon'}, true) or ""
		image.Parent = billboard
		local uicorner = Instance.new('UICorner')
		uicorner.CornerRadius = UDim.new(0, 4)
		uicorner.Parent = image
		espCache[cannon] = billboard
	end

	local function removeCannonESP(cannon)
		if espCache[cannon] then
			espCache[cannon]:Destroy()
			espCache[cannon] = nil
		end
	end

	local function findExistingCannons()
		for _, obj in pairs(workspace:GetDescendants()) do
			if obj:IsA("BasePart") and obj.Name == "cannon" then
				if not espCache[obj] then
					createCannonESP(obj)
				end
			end
		end
	end

	BetterDavey = vape.Categories.Kits:CreateModule({
		Name = 'AutoDavey',
		Function = function(callback)
			if callback then
				local stopIndex = 0

				CannonHandController.launchSelf = function(...)
					if isLaunching then
						return oldLaunchSelf(...)
					end

					isLaunching = true
					local self, block = ...
					if BetterDaveyAutoBreak.Enabled then
						if BetterDaveyAutoSwitch.Enabled and not isHoldingPickaxe() then
							local pickaxeSlot = getPickaxeSlot()
							if pickaxeSlot then
								hotbarSwitch(pickaxeSlot)
								task.wait(0.05)
							end
						end

						if BetterDaveyPickaxeCheck.Enabled and not isHoldingPickaxe() then
							notif("AutoDavey", "Hold a pickaxe to break cannons!", 2)
							isLaunching = false
							return oldLaunchSelf(...)
						end

						if block and isHoldingWoodPickaxe() then
							pcall(function()
								bedwars.breakBlock(block, true, false)
							end)
							task.wait(0.1)
						end
					end

					local res = {oldLaunchSelf(...)}

					if BetterDaveyAutojump.Enabled then
						task.spawn(function()
							task.wait(0.05)
							if entitylib.isAlive and entitylib.character.Humanoid then
								entitylib.character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
							end
						end)
					end

					if BetterDaveyAutoBreak.Enabled and block then
						task.spawn(function()
							pcall(function()
								if block:GetAttribute('PlacedByUserId') == lplr.UserId and
								   (block.Position - entitylib.character.RootPart.Position).Magnitude < 30 then
									bedwars.breakBlock(block, false, nil, true)
								end
							end)
						end)
					end

					isLaunching = false
					return unpack(res)
				end

				CannonController.stopAiming = function(...)
					stopIndex += 1

					if BetterDaveyAutoLaunch.Enabled and stopIndex == 2 then
						local cannon = getNearestCannon()
						if cannon then
							if BetterDaveyAutoBreak.Enabled and BetterDaveyPickaxeCheck.Enabled then
								if not isHoldingPickaxe() and not BetterDaveyAutoSwitch.Enabled then
									notif("AutoDavey", "Hold a pickaxe to auto-break!", 2)
									return oldStopAiming(...)
								end
							end
							pcall(CannonHandController.launchSelf, CannonHandController, cannon)
						end
					end

					return oldStopAiming(...)
				end

				CannonController.startAiming = function(...)
					stopIndex = 0
					return oldStartAiming(...)
				end

				if CannonESP.Enabled then
					findExistingCannons()

					BetterDavey:Clean(workspace.DescendantAdded:Connect(function(obj)
						if obj:IsA("BasePart") and obj.Name == "cannon" then
							task.wait(0.1)
							createCannonESP(obj)
						end
					end))

					BetterDavey:Clean(workspace.DescendantRemoving:Connect(function(obj)
						if obj:IsA("BasePart") and obj.Name == "cannon" then
							removeCannonESP(obj)
						end
					end))
				end
			else
				CannonHandController.launchSelf = oldLaunchSelf
				CannonController.stopAiming = oldStopAiming
				CannonController.startAiming = oldStartAiming
				isLaunching = false

				Folder:ClearAllChildren()
				table.clear(espCache)
			end
		end,
		Tooltip = 'Advanced cannon automation with ESP'
	})

	BetterDaveyAutojump = BetterDavey:CreateToggle({
		Name = 'Auto Jump',
		Default = true,
		Tooltip = 'Automatically jumps when launching from a cannon'
	})

	BetterDaveyAutoLaunch = BetterDavey:CreateToggle({
		Name = 'Auto Launch',
		Default = true,
		Tooltip = 'Automatically launches you from a cannon when you finish aiming'
	})

	BetterDaveyAutoBreak = BetterDavey:CreateToggle({
		Name = 'Auto Break',
		Default = true,
		Tooltip = 'Automatically breaks a cannon when you launch from it'
	})

	BetterDaveyPickaxeCheck = BetterDavey:CreateToggle({
		Name = 'Pickaxe Check',
		Default = true,
		Tooltip = 'Must be holding a pickaxe to break cannons'
	})

	BetterDaveyAutoSwitch = BetterDavey:CreateToggle({
		Name = 'Auto-Switch Pickaxe',
		Default = false,
		Tooltip = 'Automatically switch to pickaxe when breaking cannon'
	})

	CannonESP = BetterDavey:CreateToggle({
		Name = 'Cannon ESP',
		Default = false,
		Function = function(callback)
			if ESPBackground and ESPBackground.Object then
				ESPBackground.Object.Visible = callback
			end
			if ESPColor and ESPColor.Object then
				ESPColor.Object.Visible = callback
			end

			if callback and BetterDavey.Enabled then
				findExistingCannons()
			else
				Folder:ClearAllChildren()
				table.clear(espCache)
			end
		end,
		Tooltip = 'Shows ESP on cannons'
	})

	ESPBackground = BetterDavey:CreateToggle({
		Name = 'ESP Background',
		Default = true,
		Visible = false,
		Function = function(callback)
			for _, billboard in pairs(espCache) do
				if billboard and billboard:FindFirstChild("ImageLabel") then
					billboard.ImageLabel.BackgroundTransparency = 1 - (callback and ESPColor.Opacity or 0)
					local blur = billboard:FindFirstChild("BlurEffect")
					if blur then blur.Visible = callback end
				end
			end
		end
	})

	ESPColor = BetterDavey:CreateColorSlider({
		Name = 'ESP Color',
		DefaultValue = 0,
		DefaultOpacity = 0.5,
		Visible = false,
		Function = function(hue, sat, val, opacity)
			ESPColor.Hue = hue
			ESPColor.Sat = sat
			ESPColor.Value = val
			ESPColor.Opacity = opacity
			for _, billboard in pairs(espCache) do
				if billboard and billboard:FindFirstChild("ImageLabel") then
					billboard.ImageLabel.BackgroundColor3 = Color3.fromHSV(hue, sat, val)
					billboard.ImageLabel.BackgroundTransparency = 1 - opacity
				end
			end
		end,
		Darker = true
	})
end)

run(function()
    local anim
    local asset
    local trackingConnection
    local lastPosition
    local NightmareEmote
    local cachedRootPart
    local cachedHumanoid
    local lastValidationCheck = 0
    
    NightmareEmote = vape.Categories.World:CreateModule({
        Name = "NightmareEmote",
        Function = function(call)
            if call then
                local l__GameQueryUtil__8
                if (not shared.CheatEngineMode) then 
                    l__GameQueryUtil__8 = require(game:GetService("ReplicatedStorage")['rbxts_include']['node_modules']['@easy-games']['game-core'].out).GameQueryUtil 
                else
                    local backup = {}; function backup:setQueryIgnored() end; l__GameQueryUtil__8 = backup;
                end
                local l__TweenService__9 = game:GetService("TweenService")
                local player = game:GetService("Players").LocalPlayer
                local character = player.Character
                
                if not character then 
                    NightmareEmote:Toggle() 
                    return 
                end
                
                local humanoid = character:WaitForChild("Humanoid")
                local rootPart = character.PrimaryPart or character:FindFirstChild("HumanoidRootPart")
                
                if not rootPart then 
                    NightmareEmote:Toggle() 
                    return 
                end
                
                cachedRootPart = rootPart
                cachedHumanoid = humanoid
                lastPosition = rootPart.Position
                lastValidationCheck = 0
                
                local v10 = game:GetService("ReplicatedStorage"):WaitForChild("Assets"):WaitForChild("Effects"):WaitForChild("NightmareEmote"):Clone()
                asset = v10
                v10.Parent = game.Workspace
                
                local descendants = v10:GetDescendants()
                for _, part in ipairs(descendants) do
                    if part:IsA("BasePart") then
                        l__GameQueryUtil__8:setQueryIgnored(part, true)
                        part.CanCollide = false
                        part.Anchored = true
                    end
                end
                
                local l__Outer__15 = v10:FindFirstChild("Outer")
                if l__Outer__15 then
                    l__TweenService__9:Create(l__Outer__15, TweenInfo.new(1.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, -1), {
                        Orientation = l__Outer__15.Orientation + Vector3.new(0, 360, 0)
                    }):Play()
                end
                
                local l__Middle__16 = v10:FindFirstChild("Middle")
                if l__Middle__16 then
                    l__TweenService__9:Create(l__Middle__16, TweenInfo.new(12.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, -1), {
                        Orientation = l__Middle__16.Orientation + Vector3.new(0, -360, 0)
                    }):Play()
                end
                
                anim = Instance.new("Animation")
                anim.AnimationId = "rbxassetid://9191822700"
                anim = humanoid:LoadAnimation(anim)
                anim:Play()
                
                local movementThresholdSq = 0.1 * 0.1
                
                trackingConnection = game:GetService("RunService").RenderStepped:Connect(function()
                    if not asset or not asset.Parent then 
                        if trackingConnection then
                            trackingConnection:Disconnect()
                        end
                        return 
                    end
                    
                    local currentTime = tick()
                    
                    if (currentTime - lastValidationCheck) > 0.5 then
                        if not character or not character.Parent then
                            asset:Destroy()
                            asset = nil
                            if trackingConnection then
                                trackingConnection:Disconnect()
                            end
                            NightmareEmote:Toggle()
                            return
                        end
                        
                        if not cachedRootPart or not cachedRootPart.Parent then
                            cachedRootPart = character.PrimaryPart or character:FindFirstChild("HumanoidRootPart")
                        end
                        
                        if not cachedHumanoid or not cachedHumanoid.Parent then
                            cachedHumanoid = character:FindFirstChildOfClass("Humanoid")
                        end
                        
                        if not cachedRootPart or not cachedHumanoid or cachedHumanoid.Health <= 0 then
                            asset:Destroy()
                            asset = nil
                            if trackingConnection then
                                trackingConnection:Disconnect()
                            end
                            NightmareEmote:Toggle()
                            return
                        end
                        
                        lastValidationCheck = currentTime
                    end
                    
                    if lastPosition and cachedRootPart then
                        local currentPosition = cachedRootPart.Position
                        local dx = currentPosition.X - lastPosition.X
                        local dy = currentPosition.Y - lastPosition.Y
                        local dz = currentPosition.Z - lastPosition.Z
                        local distanceMovedSq = dx * dx + dy * dy + dz * dz
                        
                        if distanceMovedSq > movementThresholdSq then
                            asset:Destroy()
                            asset = nil
                            if trackingConnection then
                                trackingConnection:Disconnect()
                            end
                            NightmareEmote:Toggle()
                            return
                        end
                        
                        lastPosition = currentPosition
                    end
                    
                    if cachedRootPart then
                        v10:SetPrimaryPartCFrame(cachedRootPart.CFrame * CFrame.new(0, -3, 0))
                    end
                end)
                
                NightmareEmote:Clean(trackingConnection)
                
            else 
                if trackingConnection then
                    trackingConnection:Disconnect()
                    trackingConnection = nil
                end
                
                if anim then 
                    anim:Stop()
                    anim = nil
                end
                
                if asset then
                    asset:Destroy() 
                    asset = nil
                end
                
                lastPosition = nil
                cachedRootPart = nil
                cachedHumanoid = nil
                lastValidationCheck = 0
            end
        end
    })
end)

run(function()
    local AutoCounter
    local TntCount
    local LimitItem

    local function fixPosition(pos)
        return bedwars.BlockController:getBlockPosition(pos) * 3
    end

    local allOurTnt = {}
    local ourTntPositions = {}
    local allTntBlocks = {} 
    local counteredTnt = {}

    local originalPlaceBlock = bedwars.placeBlock
    bedwars.placeBlock = function(pos, blockType, ...)
        local result = originalPlaceBlock(pos, blockType, ...)

        if blockType == "tnt" then
            local fixedPos = fixPosition(pos)
            local posKey = string.format("%.0f,%.0f,%.0f", fixedPos.X, fixedPos.Y, fixedPos.Z)
            ourTntPositions[posKey] = true
        end

        return result
    end

    local tntAddedConnection = workspace.DescendantAdded:Connect(function(obj)
        if obj.Name == "tnt" and obj:IsA("Part") then
            allTntBlocks[obj] = true
            
            task.defer(function()
                local fixedPos = fixPosition(obj.Position)
                local posKey = string.format("%.0f,%.0f,%.0f", fixedPos.X, fixedPos.Y, fixedPos.Z)
                
                local placerId = obj:GetAttribute("PlacedByUserId")
                if placerId and placerId == lplr.UserId then
                    allOurTnt[obj] = true
                    ourTntPositions[posKey] = true
                elseif ourTntPositions[posKey] then
                    allOurTnt[obj] = true
                end
            end)

            local ancestryConnection
            ancestryConnection = obj.AncestryChanged:Connect(function()
                if not obj.Parent then
                    allOurTnt[obj] = nil
                    allTntBlocks[obj] = nil
                    counteredTnt[obj] = nil
                    
                    local fixedPos = fixPosition(obj.Position)
                    local posKey = string.format("%.0f,%.0f,%.0f", fixedPos.X, fixedPos.Y, fixedPos.Z)
                    ourTntPositions[posKey] = nil
                    
                    if ancestryConnection then
                        ancestryConnection:Disconnect()
                    end
                end
            end)
        end
    end)

    local function isEnemyTnt(tntBlock)
        if not tntBlock or not tntBlock.Parent then return false end

        if allOurTnt[tntBlock] then
            return false
        end

        local fixedPos = fixPosition(tntBlock.Position)
        local posKey = string.format("%.0f,%.0f,%.0f", fixedPos.X, fixedPos.Y, fixedPos.Z)
        
        if ourTntPositions[posKey] then
            allOurTnt[tntBlock] = true
            return false
        end

        local placerId = tntBlock:GetAttribute("PlacedByUserId")
        if placerId and placerId == lplr.UserId then
            allOurTnt[tntBlock] = true
            ourTntPositions[posKey] = true
            return false
        end

        return true
    end

    local function isHoldingTnt()
        local currentTool = store.hand.tool
        return currentTool and currentTool.Name == "tnt"
    end

    AutoCounter = vape.Categories.World:CreateModule({
        Name = 'AutoCounter',
        Function = function(callback)
            
            if callback then
                table.clear(counteredTnt)
                
                for tntBlock in pairs(allTntBlocks) do
                    if tntBlock.Parent then
                        local placerId = tntBlock:GetAttribute("PlacedByUserId")
                        if placerId and placerId == lplr.UserId then
                            allOurTnt[tntBlock] = true
                            local fixedPos = fixPosition(tntBlock.Position)
                            local posKey = string.format("%.0f,%.0f,%.0f", fixedPos.X, fixedPos.Y, fixedPos.Z)
                            ourTntPositions[posKey] = true
                        end
                    end
                end

                local horizontalSides = {}
                for _, side in ipairs(Enum.NormalId:GetEnumItems()) do
                    local sideVec = Vector3.fromNormalId(side)
                    if sideVec.Y == 0 then
                        table.insert(horizontalSides, sideVec)
                    end
                end

                repeat
                    if not entitylib.isAlive then
                        task.wait(0.1)
                        continue
                    end

                    if LimitItem.Enabled and not isHoldingTnt() then
                        task.wait(0.1)
                        continue
                    end

                    if not getItem("tnt") then
                        task.wait(0.1)
                        continue
                    end

                    local myPosition = entitylib.character.RootPart.Position
                    local maxDistance = 30
                    local maxDistanceSq = maxDistance * maxDistance

                    for tntBlock in pairs(allTntBlocks) do
                        if tntBlock.Parent and not counteredTnt[tntBlock] then
                            if isEnemyTnt(tntBlock) then
                                local offset = tntBlock.Position - myPosition
                                local distanceSq = offset.X * offset.X + offset.Y * offset.Y + offset.Z * offset.Z

                                if distanceSq <= maxDistanceSq then
                                    local placedCount = 0
                                    local maxCount = TntCount.Value
                                    
                                    for _, sideVec in ipairs(horizontalSides) do
                                        if LimitItem.Enabled and not isHoldingTnt() then
                                            break
                                        end

                                        if placedCount >= maxCount then break end

                                        local placePos = fixPosition(tntBlock.Position + sideVec * 3.5)

                                        if not getPlacedBlock(placePos) and getItem("tnt") then
                                            if LimitItem.Enabled and not isHoldingTnt() then
                                                break
                                            end

                                            bedwars.placeBlock(placePos, "tnt")
                                            placedCount = placedCount + 1
                                            task.wait(0.05)
                                        end
                                    end

                                    counteredTnt[tntBlock] = true

                                    task.defer(function()
                                        if tntBlock.Parent then
                                            tntBlock.AncestryChanged:Wait()
                                        end
                                        counteredTnt[tntBlock] = nil
                                    end)
                                end
                            end
                        end
                    end

                    task.wait(0.1)
                until not AutoCounter.Enabled
            else
                table.clear(allOurTnt)
                table.clear(ourTntPositions)
                table.clear(counteredTnt)
            end
        end,
        Tooltip = 'Automatically places TNT around enemy TNT'
    })

    TntCount = AutoCounter:CreateSlider({
        Name = 'TNT Count',
        Min = 1,
        Max = 5,
        Default = 3
    })

    LimitItem = AutoCounter:CreateToggle({
        Name = 'Limit to TNT',
        Default = true,
        Tooltip = 'Only works when holding TNT'
    })
    
    task.spawn(function()
        repeat task.wait(1) until not AutoCounter
        if tntAddedConnection then
            tntAddedConnection:Disconnect()
        end
    end)
end)
	
run(function()
	local AutoPlay
	local Random
	local BypassAFK
	local queuedThisMatch = false
	local afkRemote
	local lastAFKBypass = 0
	
	local function isEveryoneDead()
		if not bedwars or not bedwars.Store then return false end
		
		local success, state = pcall(function()
			return bedwars.Store:getState()
		end)
		
		if success and state and state.Party and state.Party.members then
			return #state.Party.members <= 0
		end
		
		return false
	end
	
	local function canQueue()
		if not bedwars or not bedwars.Store then return false end
		
		local success, state = pcall(function()
			return bedwars.Store:getState()
		end)
		
		if not success or not state then return false end
		
		return state.Game 
			and not state.Game.customMatch 
			and state.Party 
			and state.Party.leader 
			and state.Party.leader.userId == lplr.UserId 
			and state.Party.queueState == 0
	end
	
	local function joinQueue()
		if not canQueue() or queuedThisMatch then return end
		
		if not bedwars or not bedwars.QueueController then 
			return 
		end
		
		local success = pcall(function()
			if Random.Enabled then
				local listofmodes = {}
				if bedwars.QueueMeta then
					for i, v in pairs(bedwars.QueueMeta) do
						if type(v) == 'table' and not v.disabled and not v.voiceChatOnly and not v.rankCategory then 
							table.insert(listofmodes, i) 
						end
					end
				end
				
				if #listofmodes > 0 then
					local selectedMode = listofmodes[math.random(1, #listofmodes)]
					bedwars.QueueController:joinQueue(selectedMode)
					notif('AutoPlay', 'Joined random queue: '..selectedMode, 3)
				else
					bedwars.QueueController:joinQueue('bedwars_test')
					notif('AutoPlay', 'Joined bedwars_test queue', 3)
				end
			else
				local queueType = store.queueType or 'bedwars_test'
				bedwars.QueueController:joinQueue(queueType)
				notif('AutoPlay', 'Joined '..queueType..' queue', 3)
			end
			
			queuedThisMatch = true
		end)
		
		if not success then
			queuedThisMatch = false
		end
	end
	
	local function findAFKRemote()
		if afkRemote and afkRemote.Parent then return afkRemote end
		
		if not afkRemote then
			local descendants = replicatedStorage:GetDescendants()
			for _, v in ipairs(descendants) do
				if v:IsA('RemoteEvent') and v.Name == 'AfkInfo' then
					afkRemote = v
					return afkRemote
				end
			end
		end
		
		return nil
	end
	
	local function bypassAFK()
		if not BypassAFK.Enabled then return end
		
		local currentTime = tick()
		
		if (currentTime - lastAFKBypass) < 25 then
			return
		end
		lastAFKBypass = currentTime
		
		local remote = findAFKRemote()
		if remote and remote.Parent then
			pcall(function()
				remote:FireServer({afk = false})
			end)
		else
			pcall(function()
				local cam = workspace.CurrentCamera
				if cam then
					cam.CFrame = cam.CFrame * CFrame.Angles(0, math.rad(0.001), 0)
				end
			end)
		end
	end
	
	local function checkInstantQueue()
		if entitylib.isAlive then return false end
		
		local hasBed = false
		if bedwars and bedwars.Store then
			local success, state = pcall(function()
				return bedwars.Store:getState()
			end)
			
			if success and state and state.Bed and lplr.Team then
				local teamName = lplr.Team.Name
				if state.Bed[teamName] then
					hasBed = true
				end
			end
		end
		
		return not hasBed and isEveryoneDead()
	end
	
	AutoPlay = vape.Categories.Utility:CreateModule({
		Name = 'AutoPlay',
		Function = function(callback)
			if callback then
				queuedThisMatch = false
				lastAFKBypass = 0
				afkRemote = nil 
				
				task.defer(findAFKRemote)
				
				task.spawn(function()
					repeat
						bypassAFK()
						task.wait(30)
					until not AutoPlay.Enabled
				end)
				
				AutoPlay:Clean(vapeEvents.EntityDeathEvent.Event:Connect(function(deathTable)
					if deathTable.entityInstance == lplr.Character then
						task.wait(0.5)
						
						if not queuedThisMatch and checkInstantQueue() then
							bypassAFK()
							task.wait(0.2)
							joinQueue()
						end
					end
				end))
				
				AutoPlay:Clean(vapeEvents.MatchEndEvent.Event:Connect(function()
					if not queuedThisMatch then
						bypassAFK()
						task.wait(0.5)
						joinQueue()
					end
					
					task.delay(3, function()
						queuedThisMatch = false
					end)
				end))
				
				AutoPlay:Clean(bedwars.Store.changed:connect(function(state, oldState)
					if state.Game and state.Game.matchState == 2 and 
					   oldState.Game and oldState.Game.matchState ~= 2 then
						if not queuedThisMatch then
							task.wait(1)
							bypassAFK()
							task.wait(0.3)
							joinQueue()
						end
					end
				end))
			else
				afkRemote = nil
			end
		end,
		Tooltip = 'Automatically queues after match ends and bypasses AFK'
	})
	
	Random = AutoPlay:CreateToggle({
		Name = 'Random',
		Tooltip = 'Chooses a random gamemode'
	})
	
	BypassAFK = AutoPlay:CreateToggle({
		Name = 'Bypass AFK',
		Default = true,
		Tooltip = 'Prevents AFK kick by sending fake activity'
	})
end)

run(function()
    local ProximityMaxDistance
    local MaxDistance
    local oldDistances = {}
    local addedConnection
    local removedConnection
    local trackedPrompts = {}
    
    ProximityMaxDistance = vape.Categories.Utility:CreateModule({
        Name = "ProximityExtender",
        Function = function(callback)
            
            if callback then
                table.clear(oldDistances)
                table.clear(trackedPrompts)
                
                local function applyToPrompt(prompt)
                    if not prompt:IsA("ProximityPrompt") then return end
                    if trackedPrompts[prompt] then return end 
                    
                    trackedPrompts[prompt] = true
                    oldDistances[prompt] = prompt.MaxActivationDistance
                    prompt.MaxActivationDistance = MaxDistance.Value
                end
                
                local function scanForPrompts(parent)
                    for _, obj in ipairs(parent:GetDescendants()) do
                        if obj:IsA("ProximityPrompt") then
                            applyToPrompt(obj)
                        end
                    end
                end
                
                scanForPrompts(workspace)
                
                addedConnection = workspace.DescendantAdded:Connect(function(obj)
                    if obj:IsA("ProximityPrompt") then
                        applyToPrompt(obj)
                    end
                end)
                
                removedConnection = workspace.DescendantRemoving:Connect(function(obj)
                    if obj:IsA("ProximityPrompt") then
                        oldDistances[obj] = nil
                        trackedPrompts[obj] = nil
                    end
                end)
                
                MaxDistance.Function = function(value)
                    for prompt in pairs(trackedPrompts) do
                        if prompt and prompt.Parent then
                            prompt.MaxActivationDistance = value
                        end
                    end
                end
            else
                if addedConnection then
                    addedConnection:Disconnect()
                    addedConnection = nil
                end
                
                if removedConnection then
                    removedConnection:Disconnect()
                    removedConnection = nil
                end
                
                for prompt, dist in pairs(oldDistances) do
                    if prompt and prompt.Parent then
                        pcall(function()
                            prompt.MaxActivationDistance = dist
                        end)
                    end
                end
                
                table.clear(oldDistances)
                table.clear(trackedPrompts)
                MaxDistance.Function = function() end
            end
        end,
        Tooltip = "Increases the MaxActivationDistance for all ProximityPrompts in the game"
    })
    
    MaxDistance = ProximityMaxDistance:CreateSlider({
        Name = 'Max Distance',
        Min = 10,
        Max = 20,
        Default = 20,
        Tooltip = 'Control the distance it extends'
    })
end)
	
run(function()
	local AutoToxic
	local GG
	local Toggles, Lists, said, dead, killStreak = {}, {}, {}, false, 0
	
	local function sendMessage(name, obj, default)
		local tab = Lists[name].ListEnabled
		if #tab == 0 then
			if default then
				tab = {default}
			else
				return
			end
		end
		
		local custommsg
		
		if #tab == 1 then
			custommsg = tab[1]
		else
			custommsg = tab[math.random(1, #tab)]
			local attempts = 0
			while custommsg == said[name] and attempts < 3 do
				custommsg = tab[math.random(1, #tab)]
				attempts = attempts + 1
			end
		end
		
		said[name] = custommsg
		custommsg = custommsg:gsub('<obj>', obj or '')
		
		if textChatService.ChatVersion == Enum.ChatVersion.TextChatService then
			pcall(function()
				textChatService.ChatInputBarConfiguration.TargetTextChannel:SendAsync(custommsg)
			end)
		elseif replicatedStorage:FindFirstChild('DefaultChatSystemChatEvents') then
			pcall(function()
				replicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(custommsg, 'All')
			end)
		end
	end
	
	AutoToxic = vape.Categories.Utility:CreateModule({
		Name = 'AutoToxic',
		Function = function(callback)
			if callback then
				if textChatService.ChatVersion ~= Enum.ChatVersion.TextChatService and not replicatedStorage:FindFirstChild('DefaultChatSystemChatEvents') then
					notif('AutoToxic', 'unsupported chat', 5, 'warning')
					AutoToxic:Toggle()
					return
				end
				
				AutoToxic:Clean(vapeEvents.BedwarsBedBreak.Event:Connect(function(bedTable)
					if Toggles.BedDestroyed.Enabled and bedTable.brokenBedTeam.id == lplr:GetAttribute('Team') then
						sendMessage('BedDestroyed', (bedTable.player.DisplayName or bedTable.player.Name), 'bro really thought he did sum | <obj>')
					elseif Toggles.Bed.Enabled and bedTable.player.UserId == lplr.UserId then
						local team = bedwars.QueueMeta[store.queueType].teams[tonumber(bedTable.brokenBedTeam.id)]
						sendMessage('Bed', team and team.displayName:lower() or 'white', 'yall sleeping on the floor now | <obj>')
					end
				end))
				
				AutoToxic:Clean(vapeEvents.EntityDeathEvent.Event:Connect(function(deathTable)
					if deathTable.finalKill then
						local killer = playersService:GetPlayerFromCharacter(deathTable.fromEntity)
						local killed = playersService:GetPlayerFromCharacter(deathTable.entityInstance)
						if not killed or not killer then return end
						
						if killed == lplr then
							if (not dead) and killer ~= lplr and Toggles.Death.Enabled then
								dead = true
								killStreak = 0
								sendMessage('Death', (killer.DisplayName or killer.Name), 'damn u got me this time | <obj>')
							end
						elseif killer == lplr and Toggles.Kill.Enabled then
							killStreak = killStreak + 1
							
							if Toggles.KillStreak.Enabled then
								if killStreak == 5 and Lists.KillStreak5 then
									sendMessage('KillStreak5', killStreak, 'im on a 5 streak rn')
								elseif killStreak == 10 and Lists.KillStreak10 then
									sendMessage('KillStreak10', killStreak, 'double digits baby')
								elseif killStreak >= 15 and Lists.KillStreak15 then
									sendMessage('KillStreak15', killStreak, 'yall should just ff')
								end
							end
							
							sendMessage('Kill', (killed.DisplayName or killed.Name), 'sit down lil bro | <obj>')
						end
					end
				end))
				
				AutoToxic:Clean(vapeEvents.MatchEndEvent.Event:Connect(function(winstuff)
					killStreak = 0
					dead = false
					
					if GG.Enabled then
						if textChatService.ChatVersion == Enum.ChatVersion.TextChatService then
							pcall(function()
								textChatService.ChatInputBarConfiguration.TargetTextChannel:SendAsync('gg')
							end)
						elseif replicatedStorage:FindFirstChild('DefaultChatSystemChatEvents') then
							pcall(function()
								replicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer('gg', 'All')
							end)
						end
					end
					
					local myTeam = bedwars.Store:getState().Game.myTeam
					if myTeam and myTeam.id == winstuff.winningTeamId or lplr.Neutral then
						if Toggles.Clutch.Enabled then
							local aliveTeammates = 0
							local myTeamId = lplr:GetAttribute('Team')
							
							for _, player in ipairs(playersService:GetPlayers()) do
								if player ~= lplr and player:GetAttribute('Team') == myTeamId then
									local char = player.Character
									if char then
										local humanoid = char:FindFirstChild('Humanoid')
										if humanoid and humanoid.Health > 0 then
											aliveTeammates = aliveTeammates + 1
										end
									end
								end
							end
							
							if aliveTeammates == 0 then
								sendMessage('Clutch', nil, '1v4 no problem')
								task.wait(1)
							end
						end
						
						if Toggles.Win.Enabled then 
							sendMessage('Win', nil, 'too ez') 
						end
					end
				end))
			else
				killStreak = 0
				dead = false
			end
		end,
		Tooltip = 'Says a message after a certain action'
	})
	
	GG = AutoToxic:CreateToggle({
		Name = 'AutoGG',
		Default = true
	})
	
	for _, v in ipairs({'Kill', 'Death', 'Bed', 'BedDestroyed', 'Win'}) do
		Toggles[v] = AutoToxic:CreateToggle({
			Name = v..' ',
			Function = function(callback)
				if Lists[v] then
					Lists[v].Object.Visible = callback
				end
			end
		})
		Lists[v] = AutoToxic:CreateTextList({
			Name = v,
			Darker = true,
			Visible = false
		})
	end
	
	Toggles.KillStreak = AutoToxic:CreateToggle({
		Name = 'Kill Streak',
		Function = function(callback)
			if Lists.KillStreak5 then
				Lists.KillStreak5.Object.Visible = callback
			end
			if Lists.KillStreak10 then
				Lists.KillStreak10.Object.Visible = callback
			end
			if Lists.KillStreak15 then
				Lists.KillStreak15.Object.Visible = callback
			end
		end
	})
	
	Lists.KillStreak5 = AutoToxic:CreateTextList({
		Name = '5 Streak',
		Darker = true,
		Visible = false
	})
	
	Lists.KillStreak10 = AutoToxic:CreateTextList({
		Name = '10 Streak',
		Darker = true,
		Visible = false
	})
	
	Lists.KillStreak15 = AutoToxic:CreateTextList({
		Name = '15+ Streak',
		Darker = true,
		Visible = false
	})
	
	Toggles.Clutch = AutoToxic:CreateToggle({
		Name = 'Clutch',
		Function = function(callback)
			if Lists.Clutch then
				Lists.Clutch.Object.Visible = callback
			end
		end
	})
	
	Lists.Clutch = AutoToxic:CreateTextList({
		Name = 'Clutch',
		Darker = true,
		Visible = false
	})
end)

run(function()
	local AutoDeathDrop
	local HealthThreshold
	local DropToggles = {
		iron = nil,
		diamond = nil,
		emerald = nil,
		gold = nil
	}
	local hasDropped = false
	local lastHealthCheck = 0
	
	AutoDeathDrop = vape.Categories.Utility:CreateModule({
		Name = 'AutoDeathDrop',
		Function = function(callback)
			if callback then
				hasDropped = false
				lastHealthCheck = 0
				
				local healthConnection = entitylib.character.Humanoid.HealthChanged:Connect(function(health)
					if not AutoDeathDrop.Enabled then return end
					if not entitylib.isAlive then
						hasDropped = false
						return
					end
					
					local currentTime = tick()
					if (currentTime - lastHealthCheck) < 0.1 then return end
					lastHealthCheck = currentTime
					
					local maxHealth = entitylib.character.Humanoid.MaxHealth
					local healthPercent = (health / maxHealth) * 100
					
					if healthPercent <= HealthThreshold.Value and not hasDropped then
						hasDropped = true
						
						for itemType, toggle in pairs(DropToggles) do
							if toggle.Enabled then
								local item = getItem(itemType)
								if item then
									local dropped = bedwars.Client:Get(remotes.DropItem):CallServer({
										item = item.tool,
										amount = item.amount
									})

									if dropped then
										dropped:SetAttribute('ClientDropTime', tick() + 100)
									end
								end
							end
						end
					elseif healthPercent > HealthThreshold.Value then
						hasDropped = false
					end
				end)
				
				AutoDeathDrop:Clean(healthConnection)
			else
				hasDropped = false
			end
		end,
		Tooltip = 'Drops resources when health is low to prevent enemies from getting them'
	})
	
	HealthThreshold = AutoDeathDrop:CreateSlider({
		Name = 'Health Threshold',
		Min = 1,
		Max = 50,
		Suffix = '%',
		Default = 20,
		Tooltip = 'Drop items when health reaches this percentage',
	})
	
	DropToggles.iron = AutoDeathDrop:CreateToggle({
		Name = 'Drop Iron',
		Tooltip = 'Drop iron when health is low',
		Default = true
	})
	DropToggles.diamond = AutoDeathDrop:CreateToggle({
		Name = 'Drop Diamond',
		Tooltip = 'Drop diamonds when health is low',
		Default = true
	})
	DropToggles.emerald = AutoDeathDrop:CreateToggle({
		Name = 'Drop Emerald',
		Tooltip = 'Drop emeralds when health is low',
		Default = true
	})
	DropToggles.gold = AutoDeathDrop:CreateToggle({
		Name = 'Drop Gold',
		Tooltip = 'Drop gold when health is low',
		Default = true
	})
end)
	
run(function()
	local AutoVoidDrop
	local OwlCheck
	local DropToggles = {
		iron = nil,
		diamond = nil,
		emerald = nil,
		gold = nil
	}
	local cachedLowestPoint
	
	AutoVoidDrop = vape.Categories.Utility:CreateModule({
		Name = 'AutoVoidDrop',
		Function = function(callback)
			if callback then
				repeat task.wait() until store.matchState ~= 0 or (not AutoVoidDrop.Enabled)
				if not AutoVoidDrop.Enabled then return end

				cachedLowestPoint = math.huge
				for _, v in pairs(store.blocks) do
					local point = (v.Position.Y - (v.Size.Y / 2)) - 50
					if point < cachedLowestPoint then
						cachedLowestPoint = point
					end
				end

				repeat
					if entitylib.isAlive then
						local root = entitylib.character.RootPart
						if root.Position.Y < cachedLowestPoint and (lplr.Character:GetAttribute('InflatedBalloons') or 0) <= 0 and not getItem('balloon') then
							if not OwlCheck.Enabled or not root:FindFirstChild('OwlLiftForce') then
								for itemType, toggle in pairs(DropToggles) do
									if toggle.Enabled then
										local item = getItem(itemType)
										if item then
											local dropped = bedwars.Client:Get(remotes.DropItem):CallServer({
												item = item.tool,
												amount = item.amount
											})
		
											if dropped then
												dropped:SetAttribute('ClientDropTime', tick() + 100)
											end
										end
									end
								end
								break
							end
						end
					end

					task.wait(0.1)
				until not AutoVoidDrop.Enabled
			end
		end,
		Tooltip = 'Drops resources when you fall into the void'
	})
	
	OwlCheck = AutoVoidDrop:CreateToggle({
		Name = 'Owl check',
		Default = true,
		Tooltip = 'Refuses to drop items if being picked up by an owl'
	})
	DropToggles.iron = AutoVoidDrop:CreateToggle({
		Name = 'Drop Iron',
		Tooltip = 'Drop iron when falling into void',
		Default = true
	})
	DropToggles.diamond = AutoVoidDrop:CreateToggle({
		Name = 'Drop Diamond',
		Tooltip = 'Drop diamonds when falling into void',
		Default = true
	})
	DropToggles.emerald = AutoVoidDrop:CreateToggle({
		Name = 'Drop Emerald',
		Tooltip = 'Drop emeralds when falling into void',
		Default = true
	})
	DropToggles.gold = AutoVoidDrop:CreateToggle({
		Name = 'Drop Gold',
		Tooltip = 'Drop gold when falling into void',
		Default = true
	})
end)
	
run(function()
	local PickupRange
	local Range
	local Lower
	local Network
	local PickupDelay
	local FastPickup
	local FastPickupDelay
	local lastPickupTime = 0
	
	PickupRange = vape.Categories.Utility:CreateModule({
		Name = 'PickupRange',
		Function = function(callback)
			if callback then
				local items = collection('ItemDrop', PickupRange)
				local rangeSquared = Range.Value * Range.Value
				
				if FastPickup.Enabled then
					task.spawn(function()
						repeat
							if entitylib.isAlive then
								local localPosition = entitylib.character.RootPart.Position
								for _, v in items do
									if tick() - (v:GetAttribute('ClientDropTime') or 0) < 0.1 then continue end
									task.spawn(function()
										task.wait(FastPickupDelay.Value)
										if bedwars and bedwars.Client and remotes.PickupItem then
											bedwars.Client:Get(remotes.PickupItem):CallServerAsync({
												itemDrop = v
											}):andThen(function(suc)
												if suc and bedwars.SoundList then
													bedwars.SoundManager:playSound(bedwars.SoundList.PICKUP_ITEM_DROP)
													local itemMeta = bedwars.ItemMeta[v.Name]
													if itemMeta then
														local sound = itemMeta.pickUpOverlaySound
														if sound then
															bedwars.SoundManager:playSound(sound, {
																position = v.Position,
																volumeMultiplier = 0.9
															})
														end
													end
												end
											end)
										end
									end)
								end
							end
							task.wait(0.05)
						until not PickupRange.Enabled or not FastPickup.Enabled
					end)
				end

				repeat
					if entitylib.isAlive then
						local localPosition = entitylib.character.RootPart.Position
						local humanoidHealth = entitylib.character.Humanoid.Health
						local currentTime = tick()
						local pickupDelaySeconds = PickupDelay.Value / 1000
						rangeSquared = Range.Value * Range.Value

						for _, v in pairs(items) do
							if (currentTime - (v:GetAttribute('ClientDropTime') or 0)) < 2 then continue end
							if (currentTime - lastPickupTime) < pickupDelaySeconds then continue end

							if isnetworkowner(v) and Network.Enabled and humanoidHealth > 0 then
								v.CFrame = CFrame.new(localPosition - Vector3.new(0, 3, 0))
							end

							local offset = v.Position - localPosition
							local distanceSquared = offset.X * offset.X + offset.Y * offset.Y + offset.Z * offset.Z

							if distanceSquared <= rangeSquared then
								if Lower.Enabled and (localPosition.Y - v.Position.Y) < (entitylib.character.HipHeight - 1) then continue end

								bedwars.Client:Get(remotes.PickupItem):CallServerAsync({
									itemDrop = v
								}):andThen(function(suc)
									if suc then
										lastPickupTime = tick()
										if bedwars.SoundList then
											bedwars.SoundManager:playSound(bedwars.SoundList.PICKUP_ITEM_DROP)
											local itemMeta = bedwars.ItemMeta[v.Name]
											if itemMeta then
												local sound = itemMeta.pickUpOverlaySound
												if sound then
													bedwars.SoundManager:playSound(sound, {
														position = v.Position,
														volumeMultiplier = 0.9
													})
												end
											end
										end
									end
								end)
							end
						end
					end
					task.wait(0.1)
				until not PickupRange.Enabled
			else
				lastPickupTime = 0
			end
		end,
		Tooltip = 'Picks up items from a farther distance'
	})

	Range = PickupRange:CreateSlider({
		Name = 'Range',
		Min = 1,
		Max = 10,
		Default = 10,
		Suffix = function(val)
			return val == 1 and 'stud' or 'studs'
		end
	})
	Network = PickupRange:CreateToggle({
		Name = 'Network TP',
		Default = true
	})
	PickupDelay = PickupRange:CreateSlider({
		Name = 'Pickup Delay',
		Min = 0,
		Max = 500,
		Default = 0,
		Tooltip = 'Delay between picking up items (milliseconds)',
		Suffix = 'ms'
	})
	Lower = PickupRange:CreateToggle({
		Name = 'Feet Check'
	})
	FastPickup = PickupRange:CreateToggle({
		Name = 'Fast Pickup',
		Default = false,
		Tooltip = 'Instantly picks up all loot in range',
		Function = function(callback)
			if FastPickupDelay and FastPickupDelay.Object then
				FastPickupDelay.Object.Visible = callback
			end
		end
	})
	FastPickupDelay = PickupRange:CreateSlider({
		Name = 'Fast Pickup Delay',
		Min = 0,
		Max = 0.5,
		Default = 0.05,
		Decimal = 100,
		Suffix = 's',
		Tooltip = 'Delay before fast picking up items',
		Visible = false
	})
end)
	
run(function()
	local Scaffold
	local Expand
	local Tower
	local Downwards
	local Diagonal
	local LimitItem
	local Mouse
	local PlaceDelay
	local adjacent, lastpos = {}, Vector3.zero
	local lastPlaceTime = 0
	
	for x = -3, 3, 3 do
		for y = -3, 3, 3 do
			for z = -3, 3, 3 do
				local vec = Vector3.new(x, y, z)
				if vec ~= Vector3.zero then
					table.insert(adjacent, vec)
				end
			end
		end
	end
	
	local function nearCorner(poscheck, pos)
		local startpos = poscheck - Vector3.new(3, 3, 3)
		local endpos = poscheck + Vector3.new(3, 3, 3)
		local check = poscheck + (pos - poscheck).Unit * 100
		return Vector3.new(math.clamp(check.X, startpos.X, endpos.X), math.clamp(check.Y, startpos.Y, endpos.Y), math.clamp(check.Z, startpos.Z, endpos.Z))
	end
	
	local function blockProximity(pos)
		local mag, returned = 60
		local tab = getBlocksInPoints(bedwars.BlockController:getBlockPosition(pos - Vector3.new(21, 21, 21)), bedwars.BlockController:getBlockPosition(pos + Vector3.new(21, 21, 21)))
		for _, v in tab do
			local blockpos = nearCorner(v, pos)
			local newmag = (pos - blockpos).Magnitude
			if newmag < mag then
				mag, returned = newmag, blockpos
			end
		end
		table.clear(tab)
		return returned
	end
	
	local function checkAdjacent(pos)
		for _, v in adjacent do
			if getPlacedBlock(pos + v) then
				return true
			end
		end
		return false
	end
	
	local function getScaffoldBlock()
		if store.hand.toolType == 'block' then
			return store.hand.tool.Name, store.hand.amount
		elseif (not LimitItem.Enabled) then
			local isHoldingSwordOrTool = store.hand.toolType == 'sword' or (store.hand.tool and bedwars.ItemMeta[store.hand.tool.Name].sword)
			if not isHoldingSwordOrTool then
				local wool, amount = getWool()
				if wool then
					return wool, amount
				else
					for _, item in store.inventory.inventory.items do
						if bedwars.ItemMeta[item.itemType].block then
							return item.itemType, item.amount
						end
					end
				end
			end
		end
	
		return nil, 0
	end
	
	Scaffold = vape.Categories.Utility:CreateModule({
		Name = 'Scaffold',
		Function = function(callback)
			if callback then
				lastPlaceTime = 0
				repeat
					if entitylib.isAlive then
						local wool, amount = getScaffoldBlock()

						if Mouse.Enabled then
							if not inputService:IsMouseButtonPressed(0) then
								wool = nil
							end
						end

						if wool then
							local root = entitylib.character.RootPart
							if Tower.Enabled and inputService:IsKeyDown(Enum.KeyCode.Space) and (not inputService:GetFocusedTextBox()) then
								root.Velocity = Vector3.new(root.Velocity.X, 38, root.Velocity.Z)
							end

							for i = Expand.Value, 1, -1 do
								local currentpos = roundPos(root.Position - Vector3.new(0, entitylib.character.HipHeight + (Downwards.Enabled and inputService:IsKeyDown(Enum.KeyCode.LeftShift) and 4.5 or 1.5), 0) + entitylib.character.Humanoid.MoveDirection * (i * 3))
								if Diagonal.Enabled then
									if math.abs(math.round(math.deg(math.atan2(-entitylib.character.Humanoid.MoveDirection.X, -entitylib.character.Humanoid.MoveDirection.Z)) / 45) * 45) % 90 == 45 then
										local dt = (lastpos - currentpos)
										if ((dt.X == 0 and dt.Z ~= 0) or (dt.X ~= 0 and dt.Z == 0)) and ((lastpos - root.Position) * Vector3.new(1, 0, 1)).Magnitude < 2.5 then
											currentpos = lastpos
										end
									end
								end

								local block, blockpos = getPlacedBlock(currentpos)
								if not block then
									if tick() - lastPlaceTime >= (PlaceDelay.Value / 1000) then
										blockpos = checkAdjacent(blockpos * 3) and blockpos * 3 or blockProximity(currentpos)
										if blockpos then
											task.spawn(bedwars.placeBlock, blockpos, wool, false)
											lastPlaceTime = tick()
										end
									end
								end
								lastpos = currentpos
							end
						end
					end

					task.wait(0.03)
				until not Scaffold.Enabled
			else
				lastPlaceTime = 0
			end
		end,
		Tooltip = 'Helps you make bridges/scaffold walk.'
	})
	Expand = Scaffold:CreateSlider({
		Name = 'Expand',
		Min = 1,
		Max = 6
	})
	Tower = Scaffold:CreateToggle({
		Name = 'Tower',
		Default = true
	})
	Downwards = Scaffold:CreateToggle({
		Name = 'Downwards',
		Default = true
	})
	Diagonal = Scaffold:CreateToggle({
		Name = 'Diagonal',
		Default = true
	})
	LimitItem = Scaffold:CreateToggle({Name = 'Limit to items'})
	Mouse = Scaffold:CreateToggle({Name = 'Require mouse down'})
	PlaceDelay = Scaffold:CreateSlider({
		Name = 'Place Delay',
		Min = 0,
		Max = 200,
		Default = 0,
		Tooltip = 'Delay between block placements (milliseconds)',
		Suffix = "ms"
	})
end)
	
run(function()
    local ShopTierBypass
    local tiered, nexttier = {}, {}
    local originalGetShop
    local shopItemsTracked = {}
    local bypassApplied = false
    
    local function applyBypassToItem(item)
        if item and type(item) == "table" and not shopItemsTracked[item] then
            tiered[item] = item.tiered 
            nexttier[item] = item.nextTier 
            item.nextTier = nil
            item.tiered = nil
            shopItemsTracked[item] = true
        end
    end
    
    local function applyBypassToTable(tbl)
        if tbl and type(tbl) == "table" then
            for _, item in pairs(tbl) do
                if type(item) == "table" then
                    applyBypassToItem(item)
                end
            end
        end
    end
    
    ShopTierBypass = vape.Categories.Utility:CreateModule({
        Name = 'Shop Tier Bypass',
        Function = function(callback)
            if callback then
                repeat task.wait() until store.shopLoaded or not ShopTierBypass.Enabled
                if ShopTierBypass.Enabled and not bypassApplied then
                    bypassApplied = true
                    
                    for _, v in pairs(bedwars.Shop.ShopItems) do
                        applyBypassToItem(v)
                    end
                    
                    if bedwars.Shop.getShop and not originalGetShop then
                        originalGetShop = bedwars.Shop.getShop
                        bedwars.Shop.getShop = function(...)
                            local result = originalGetShop(...)
                            if type(result) == "table" then
                                applyBypassToTable(result)
                            end
                            return result
                        end
                    end
                end
            else
                bypassApplied = false
                
                for item, _ in pairs(shopItemsTracked) do
                    if item and type(item) == "table" then
                        if tiered[item] ~= nil then
                            item.tiered = tiered[item]
                        end
                        if nexttier[item] ~= nil then
                            item.nextTier = nexttier[item]
                        end
                    end
                end
                
                if originalGetShop then
                    bedwars.Shop.getShop = originalGetShop
                    originalGetShop = nil
                end
                
                table.clear(tiered)
                table.clear(nexttier)
                table.clear(shopItemsTracked)
            end
        end,
        Tooltip = 'Lets you buy things like armor and tools early.'
    })
end)
	
run(function()
	vape.Categories.World:CreateModule({
		Name = 'Anti-AFK',
		Function = function(callback)
			if callback then
				pcall(function()
					for _, v in getconnections(lplr.Idled) do
						v:Disconnect()
					end
				end)

				pcall(function()
					for _, v in getconnections(runService.Heartbeat) do
						if type(v.Function) == 'function' then
							local constants = debug.getconstants(v.Function)
							if constants and table.find(constants, remotes.AfkStatus) then
								v:Disconnect()
							end
						end
					end
				end)

				pcall(function()
					local afkRemote = bedwars.Client:Get(remotes.AfkStatus)
					if afkRemote then
						afkRemote:SendToServer({
							afk = false
						})
					end
				end)
			end
		end,
		Tooltip = 'Lets you stay ingame without getting kicked'
	})
end)

run(function()
    local AutoBuildUp
    local LimitItem
    local facesOnly = {
        Vector3.new(3, 0, 0),   
        Vector3.new(-3, 0, 0), 
        Vector3.new(0, 3, 0),   
        Vector3.new(0, -3, 0),  
        Vector3.new(0, 0, 3),   
        Vector3.new(0, 0, -3) 
    }
    
    local function checkFaceAdjacent(pos)
        for _, v in facesOnly do
            if getPlacedBlock(pos + v) then
                return true
            end
        end
        return false
    end
    
    local function hasFaceBelowOrSide(pos)
        if getPlacedBlock(pos - Vector3.new(0, 3, 0)) then
            return true
        end
        
        for _, v in facesOnly do
            if v.Y == 0 and getPlacedBlock(pos + v) then
                return true
            end
        end
        
        return false
    end
    
    local function nearCorner(poscheck, pos)
        local startpos = poscheck - Vector3.new(3, 3, 3)
        local endpos = poscheck + Vector3.new(3, 3, 3)
        local check = poscheck + (pos - poscheck).Unit * 100
        return Vector3.new(math.clamp(check.X, startpos.X, endpos.X), math.clamp(check.Y, startpos.Y, endpos.Y), math.clamp(check.Z, startpos.Z, endpos.Z))
    end
    
    local function blockProximity(pos)
        local mag, returned = 60
        local tab = getBlocksInPoints(
            bedwars.BlockController:getBlockPosition(pos - Vector3.new(21, 21, 21)), 
            bedwars.BlockController:getBlockPosition(pos + Vector3.new(21, 21, 21))
        )
        
        for _, v in tab do
            local blockpos = nearCorner(v, pos)
            local newmag = (pos - blockpos).Magnitude
            
            if hasFaceBelowOrSide(blockpos) and newmag < mag then
                mag, returned = newmag, blockpos
            end
        end
        
        table.clear(tab)
        return returned
    end
    
    local function getScaffoldBlock()
        if LimitItem.Enabled then
            if store.hand.toolType == 'block' then
                return store.hand.tool.Name
            end
            return nil
        else
            local wool = getWool()
            if wool then
                return wool
            else
                for _, item in store.inventory.inventory.items do
                    if bedwars.ItemMeta[item.itemType].block then
                        return item.itemType
                    end
                end
            end
        end
        return nil
    end
    
    local function canPlaceAtPosition(blockpos)
        if not checkFaceAdjacent(blockpos) then
            return false
        end
        
        local checkBelow = blockpos - Vector3.new(0, 3, 0)
        local hasSupport = false
        
        for i = 1, 10 do
            if getPlacedBlock(checkBelow) then
                hasSupport = true
                break
            end
            checkBelow = checkBelow - Vector3.new(0, 3, 0)
        end
        
        return hasSupport or hasFaceBelowOrSide(blockpos)
    end
    
    AutoBuildUp = vape.Categories.World:CreateModule({
        Name = 'AutoBuildUp',
        Function = function(callback)
            
            if callback then
                repeat
                    if entitylib.isAlive then
                        local wool = getScaffoldBlock()
                        
                        if wool then
                            local root = entitylib.character.RootPart
                            
                            if inputService:IsKeyDown(Enum.KeyCode.Space) and (not inputService:GetFocusedTextBox()) then
                                local currentpos = roundPos(root.Position - Vector3.new(0, entitylib.character.HipHeight + 1.5, 0))
                                
                                local block, blockpos = getPlacedBlock(currentpos)
                                if not block then
                                    blockpos = blockpos * 3
                                    
                                    if hasFaceBelowOrSide(blockpos) then
                                        if canPlaceAtPosition(blockpos) then
                                            task.spawn(bedwars.placeBlock, blockpos, wool, false)
                                        end
                                    else
                                        local nearestBlock = blockProximity(currentpos)
                                        if nearestBlock and canPlaceAtPosition(nearestBlock) then
                                            task.spawn(bedwars.placeBlock, nearestBlock, wool, false)
                                        end
                                    end
                                end
                            end
                        end
                    end
                    
                    task.wait(0.03)
                until not AutoBuildUp.Enabled
            end
        end,
        Tooltip = 'Automatically places blocks under you ONLY when jumping (no corner connections)'
    })
    
    LimitItem = AutoBuildUp:CreateToggle({
        Name = 'Limit to items',
        Default = false,
        Tooltip = 'Only place blocks when holding a block item'
    })
end)

run(function()
    local AutoBuildStraight
    local LimitItem
    local Range
    
    local facesOnly = {
        Vector3.new(3, 0, 0),   
        Vector3.new(-3, 0, 0), 
        Vector3.new(0, 3, 0),   
        Vector3.new(0, -3, 0),  
        Vector3.new(0, 0, 3),   
        Vector3.new(0, 0, -3) 
    }
    
    local function checkFaceAdjacent(pos)
        for _, v in facesOnly do
            if getPlacedBlock(pos + v) then
                return true
            end
        end
        return false
    end
    
    local function getScaffoldBlock()
        if LimitItem.Enabled then
            if store.hand.toolType == 'block' then
                return store.hand.tool.Name
            end
            return nil
        else
            local wool = getWool()
            if wool then
                return wool
            else
                for _, item in store.inventory.inventory.items do
                    if bedwars.ItemMeta[item.itemType].block then
                        return item.itemType
                    end
                end
            end
        end
        return nil
    end
    
    AutoBuildStraight = vape.Categories.World:CreateModule({
        Name = 'AutoBuildStraight',
        Function = function(callback)
            if callback then
                repeat
                    if entitylib.isAlive then
                        local wool = getScaffoldBlock()
                        
                        if wool then
                            local root = entitylib.character.RootPart
                            local humanoid = entitylib.character.Humanoid
                            
                            if humanoid.MoveDirection.Magnitude > 0.1 then
                                local lookDir = gameCamera.CFrame.LookVector
                                local horizontalLook = Vector3.new(lookDir.X, 0, lookDir.Z).Unit
                                
                                local playerFeetPos = root.Position - Vector3.new(0, entitylib.character.HipHeight + 1.5, 0)
                                
                                for distance = 3, Range.Value, 3 do
                                    local checkPos = playerFeetPos + (horizontalLook * distance)
                                    local currentpos = roundPos(checkPos)
                                    
                                    local block, blockpos = getPlacedBlock(currentpos)
                                    
                                    if not block then
                                        blockpos = blockpos * 3
                                        
                                        if checkFaceAdjacent(blockpos) then
                                            task.spawn(bedwars.placeBlock, blockpos, wool, false)
                                            break
                                        end
                                    end
                                end
                            end
                        end
                    end
                    
                    task.wait(0.05)
                until not AutoBuildStraight.Enabled
            end
        end,
        Tooltip = 'Automatically extends blocks straight ahead when moving'
    })
    
    Range = AutoBuildStraight:CreateSlider({
        Name = 'Range',
        Min = 3,
        Max = 30,
        Default = 12,
        Tooltip = 'Maximum distance ahead to place blocks'
    })
    
    LimitItem = AutoBuildStraight:CreateToggle({
        Name = 'Limit to items',
        Default = false,
        Tooltip = 'Only place blocks when holding a block item'
    })
end)
	
run(function()
	local AutoTool
	local old, event
	
	local function hotbarSwitchItem(block)
		if block and not block:GetAttribute('NoBreak') and not block:GetAttribute('Team'..(lplr:GetAttribute('Team') or 0)..'NoBreak') then
			local itemMeta = bedwars.ItemMeta[block.Name]
			if not itemMeta or not itemMeta.block then return false end
			local tool, slot = store.tools[itemMeta.block.breakType], nil
			local tool, slot = store.tools[bedwars.ItemMeta[block.Name].block.breakType], nil
			if tool then
				for i, v in store.inventory.hotbar do
					if v.item and v.item.itemType == tool.itemType then slot = i - 1 break end
				end
	
				if hotbarSwitch(slot) then
					if event and inputService:IsMouseButtonPressed(0) then 
						event:Fire() 
					end
					return true
				end
			end
		end
	end

	AutoTool = vape.Categories.World:CreateModule({
		Name = 'AutoTool',
		Function = function(callback)
			if callback then
				event = Instance.new('BindableEvent')
				AutoTool:Clean(event)
				AutoTool:Clean(event.Event:Connect(function()
					pcall(function()
						contextActionService:CallFunction('block-break', Enum.UserInputState.Begin, newproxy(true))
					end)
				end))
				old = bedwars.BlockBreaker.hitBlock
				bedwars.BlockBreaker.hitBlock = function(self, maid, raycastparams, ...)
					local block
					pcall(function()
						local info = self.clientManager:getBlockSelector():getMouseInfo(1, {ray = raycastparams})
						block = info and info.target and info.target.blockInstance or nil
					end)
					local switched = false
					pcall(function()
						switched = hotbarSwitchItem(block)
					end)
					if switched then return end
					return old(self, maid, raycastparams, ...)
				end
			else
				bedwars.BlockBreaker.hitBlock = old
				old = nil
			end
		end,
		Tooltip = 'Automatically selects the correct tool'
	})
end)
	
run(function()
    local BedProtector
    local SpeedMode
    local Layers
    local HandCheck
    local AutoSwitch
    local StrongestFirst
    
    local CpsConstants = nil
    local originalCPS = 12
    local isProtecting = false
    local protectionThread = nil
    local trackedPositions = {}
    
    local function initCPS()
        pcall(function()
            CpsConstants = require(replicatedStorage.TS['shared-constants']).CpsConstants
        end)
        
        if not CpsConstants then
            pcall(function()
                CpsConstants = bedwars.CpsConstants
            end)
        end
        
        if CpsConstants then
            originalCPS = CpsConstants.BLOCK_PLACE_CPS
        end
    end
    
    local function setCPS(value)
        if CpsConstants then
            CpsConstants.BLOCK_PLACE_CPS = value
        end
    end
    
    local function getSpeedCPS()
        if SpeedMode.Value == "Fast" then
            return 50
        elseif SpeedMode.Value == "Medium" then
            return 35
        else
            return 75
        end
    end
    
    local function getBedNear()
        if not entitylib.isAlive then return nil end
        local localPosition = entitylib.character.RootPart.Position
        
        for _, v in collectionService:GetTagged('bed') do
            local teamAttr = 'Team'..(lplr:GetAttribute('Team') or -1)..'NoBreak'
            if (localPosition - v.Position).Magnitude < 30 and v:GetAttribute(teamAttr) then
                return v
            end
        end
        return nil
    end
    
    local function getHotbarSlotForBlock(tool)
        if not tool then return nil end
        for i, v in pairs(store.inventory.hotbar) do
            if v.item and v.item.tool == tool then
                return i - 1
            end
        end
        return nil
    end
    
    local function isValidBlock(itemType)
        if not itemType then return false end
        local itemLower = itemType:lower()
        
        if itemLower:find("tnt") or itemLower:find("explosive") or 
           itemLower:find("spawn") or itemLower:find("egg") or
           itemLower:find("bed") or itemLower:find("potion") then
            return false
        end
        
        local validBlocks = {
            "wool", "stone", "plank", "wood", "brick", 
            "ceramic", "obsidian", "glass", "sandstone"
        }
        
        for _, valid in ipairs(validBlocks) do
            if itemLower:find(valid) then
                return true
            end
        end
        
        return false
    end
    
    local function getBlocks()
        local blocks = {}
        
        for _, item in pairs(store.inventory.inventory.items) do
            if bedwars.ItemMeta[item.itemType] and bedwars.ItemMeta[item.itemType].block then
                if isValidBlock(item.itemType) then
                    local meta = bedwars.ItemMeta[item.itemType]
                    local inHotbar = getHotbarSlotForBlock(item.tool) ~= nil
                    
                    table.insert(blocks, {
                        itemType = item.itemType,
                        health = meta.block.health or 0,
                        tool = item.tool,
                        inHotbar = inHotbar
                    })
                end
            end
        end
        
        table.sort(blocks, function(a, b)
            return a.health > b.health
        end)
        
        if AutoSwitch.Enabled then
            local hotbarBlocks = {}
            for _, block in ipairs(blocks) do
                if block.inHotbar then
                    table.insert(hotbarBlocks, block)
                end
            end
            return hotbarBlocks
        end
        
        return blocks
    end
    
    local function switchToBlock(blockTool)
        if not AutoSwitch.Enabled or not blockTool then return false end
        
        local slot = getHotbarSlotForBlock(blockTool)
        if slot then
            local success = pcall(function()
                hotbarSwitch(slot)
            end)
            if success then
                task.wait(0.05)
                return true
            end
        end
        return false
    end
    
    local function detectBedOrientation(bed)
        if not bed then return nil end
        
        local bedPos = bed.Position
        local teamAttr = 'Team'..(lplr:GetAttribute('Team') or -1)..'NoBreak'
        
        local checkOffsets = {
            Vector3.new(3, 0, 0),
            Vector3.new(-3, 0, 0),
            Vector3.new(0, 0, 3),
            Vector3.new(0, 0, -3)
        }
        
        for _, offset in ipairs(checkOffsets) do
            local checkPos = bedPos + offset
            local block = getPlacedBlock(checkPos)
            
            if block and block:GetAttribute(teamAttr) and block.Name == "bed" then
                if math.abs(offset.X) > 0 then
                    return {axis = "X", direction = offset}
                else
                    return {axis = "Z", direction = offset}
                end
            end
        end
        
        return {axis = "X", direction = Vector3.new(3, 0, 0)}
    end
    
    local function getBedPositions(bed, orientation)
        local bedPos = bed.Position
        local secondBedPos = bedPos + orientation.direction
        return {bedPos, secondBedPos}
    end
    
    local function getPyramidPositions(layer)
        local positions = {}
        local radius = layer + 1
        
        for x = -radius, radius do
            for y = 0, layer do
                for z = -radius, radius do
                    if y <= layer then
                        local dist = math.abs(x) + math.abs(z) + math.abs(y)
                        if dist <= radius and y <= layer then
                            table.insert(positions, Vector3.new(x, y, z) * 3)
                        end
                    end
                end
            end
        end
        
        return positions
    end
    
    local function placeBlockAt(pos, blockType, blockTool)
        if not pos or not blockType then return false end
        
        if getPlacedBlock(pos) then
            return false
        end
        
        if AutoSwitch.Enabled and HandCheck.Enabled then
            switchToBlock(blockTool)
        end
        
        local success = pcall(function()
            bedwars.placeBlock(pos, blockType, false)
        end)
        
        if success then
            trackedPositions[pos] = {
                blockType = blockType,
                placed = tick()
            }
        end
        
        return success
    end
    
    local function executeProtection()
        if isProtecting then return end
        isProtecting = true
        
        protectionThread = task.spawn(function()
            local bed = getBedNear()
            if not bed then
                notif('bedprotector', 'cannot find your bed', 3)
                isProtecting = false
                BedProtector:Toggle()
                return
            end
            
            if HandCheck.Enabled and not AutoSwitch.Enabled then
                if not (store.hand and store.hand.toolType == 'block') then
                    notif('bedprotector', 'hold a block to use hand check', 3)
                    isProtecting = false
                    BedProtector:Toggle()
                    return
                end
            end
            
            local orientation = detectBedOrientation(bed)
            local bedPositions = getBedPositions(bed, orientation)
            local cps = getSpeedCPS()
            local delay = 1 / cps
            
            setCPS(cps)
            
            trackedPositions = {}
            
            notif('bedprotector', 'bed orientation: '..orientation.axis, 2)
            
            local totalPlaced = 0
            
            for layer = 0, Layers.Value - 1 do
                if not BedProtector.Enabled then break end
                
                local blocks = getBlocks()
                if #blocks == 0 then
                    notif('bedprotector', 'no valid blocks in inventory', 3)
                    break
                end
                
                local blockIndex
                if StrongestFirst.Enabled then
                    blockIndex = 1
                else
                    blockIndex = #blocks
                end
                
                if layer > 0 and StrongestFirst.Enabled then
                    blockIndex = math.min(layer + 1, #blocks)
                elseif layer > 0 and not StrongestFirst.Enabled then
                    blockIndex = math.max(#blocks - layer, 1)
                end
                
                local blockToUse = blocks[blockIndex]
                
                local blockName = bedwars.ItemMeta[blockToUse.itemType].displayName or blockToUse.itemType
                notif('bedprotector', 'layer '..(layer + 1)..': '..blockName, 1.5)
                
                local pyramidPositions = getPyramidPositions(layer)
                
                local layerPlaced = 0
                
                for _, bedPos in ipairs(bedPositions) do
                    if not BedProtector.Enabled then break end
                    
                    for _, offset in ipairs(pyramidPositions) do
                        if not BedProtector.Enabled then break end
                        
                        local pos = bedPos + offset
                        
                        if not getPlacedBlock(pos) then
                            local placed = placeBlockAt(pos, blockToUse.itemType, blockToUse.tool)
                            if placed then
                                layerPlaced = layerPlaced + 1
                                totalPlaced = totalPlaced + 1
                            end
                            task.wait(delay)
                        end
                    end
                end
                
                if layerPlaced > 0 then
                    notif('bedprotector', 'layer '..(layer + 1)..': '..layerPlaced..' blocks', 1.5)
                end
            end
            
            setCPS(originalCPS)
            isProtecting = false
            
            if BedProtector.Enabled and totalPlaced > 0 then
                notif('bedprotector', 'placed '..totalPlaced..' blocks around bed', 3)
                BedProtector:Toggle()
            elseif BedProtector.Enabled then
                notif('bedprotector', 'no blocks placed - check inventory', 3)
                BedProtector:Toggle()
            end
        end)
    end
    
    BedProtector = vape.Categories.World:CreateModule({
        Name = 'BedProtector',
        Function = function(callback)
            if callback then
                initCPS()
                executeProtection()
            else
                isProtecting = false
                
                if protectionThread then
                    pcall(function()
                        task.cancel(protectionThread)
                    end)
                    protectionThread = nil
                end
                
                setCPS(originalCPS)
                trackedPositions = {}
            end
        end,
        Tooltip = 'Automatically protects your bed with pyramid layers'
    })
    
    SpeedMode = BedProtector:CreateDropdown({
        Name = 'Speed',
        List = {'Medium', 'Fast', 'Super Fast'},
        Default = 'Fast',
        Tooltip = 'Block placement speed\nMedium: 35 CPS\nFast: 50 CPS\nSuper Fast: 75 CPS',
        Function = function(val)
            if BedProtector.Enabled then
                setCPS(getSpeedCPS())
            end
        end
    })
    
    Layers = BedProtector:CreateSlider({
        Name = 'Layers',
        Min = 1,
        Max = 5,
        Default = 3,
        Tooltip = 'Number of pyramid layers around bed',
        Function = function() end
    })
    
    StrongestFirst = BedProtector:CreateToggle({
        Name = 'Strongest First',
        Default = true,
        Tooltip = 'Layer 1: Strongest block\nLayer 2: 2nd strongest\nLayer 3: 3rd strongest\netc.',
        Function = function() end
    })
    
    HandCheck = BedProtector:CreateToggle({
        Name = 'Hand Check',
        Default = false,
        Tooltip = 'Only place blocks when holding a block',
        Function = function(callback)
            if AutoSwitch and AutoSwitch.Object then
                AutoSwitch.Object.Visible = callback
            end
        end
    })
    
    AutoSwitch = BedProtector:CreateToggle({
        Name = 'Auto Switch',
        Default = true,
        Visible = false,
        Tooltip = 'Automatically switch to blocks in hotbar',
        Function = function() end
    })
end)
	
run(function()
	local ChestSteal
	local Range
	local Open
	local Skywars
	local DelayToggle
	local DelaySlider
	local TeamFilter
	local Delays = {}
	
	local function isTeamChest(chest)
		if not TeamFilter.Enabled then return false end
		
		local chestTeam = chest:GetAttribute('Team')
		local myTeam = lplr:GetAttribute('Team')
		
		return chestTeam and myTeam and chestTeam == myTeam
	end
	
	local function lootChest(chest)
		chest = chest and chest.Value or nil
		if not chest then return end
		
		if isTeamChest(chest) then return end
		
		local chestitems = chest and chest:GetChildren() or {}
		if #chestitems > 1 and (Delays[chest] or 0) < tick() then
			Delays[chest] = tick() + (DelayToggle.Enabled and DelaySlider.Value or 0.2)
			bedwars.Client:GetNamespace('Inventory'):Get('SetObservedChest'):SendToServer(chest)
	
			for _, v in chestitems do
				if v:IsA('Accessory') then
					if DelayToggle.Enabled then
						task.wait(DelaySlider.Value / #chestitems) 
					end
					
					task.spawn(function()
						pcall(function()
							bedwars.Client:GetNamespace('Inventory'):Get('ChestGetItem'):CallServer(chest, v)
						end)
					end)
				end
			end
	
			bedwars.Client:GetNamespace('Inventory'):Get('SetObservedChest'):SendToServer(nil)
		end
	end
	
	ChestSteal = vape.Categories.World:CreateModule({
		Name = 'ChestSteal',
		Function = function(callback)
			if callback then
				local chests = collection('chest', ChestSteal)
				repeat task.wait() until store.queueType ~= 'bedwars_test'
				if (not Skywars.Enabled) or store.queueType:find('skywars') then
					repeat
						if entitylib.isAlive and store.matchState ~= 2 then
							if Open.Enabled then
								if bedwars.AppController:isAppOpen('ChestApp') then
									lootChest(lplr.Character:FindFirstChild('ObservedChestFolder'))
								end
							else
								local localPosition = entitylib.character.RootPart.Position
								for _, v in chests do
									if (localPosition - v.Position).Magnitude <= Range.Value then
										lootChest(v:FindFirstChild('ChestFolderValue'))
									end
								end
							end
						end
						task.wait(0.1)
					until not ChestSteal.Enabled
				end
			end
		end,
		Tooltip = 'Grabs items from near chests.'
	})
	Range = ChestSteal:CreateSlider({
		Name = 'Range',
		Min = 0,
		Max = 18,
		Default = 18,
		Suffix = function(val)
			return val == 1 and 'stud' or 'studs'
		end
	})
	Open = ChestSteal:CreateToggle({Name = 'GUI Check'})
	Skywars = ChestSteal:CreateToggle({
		Name = 'Only Skywars',
		Function = function()
			if ChestSteal.Enabled then
				ChestSteal:Toggle()
				ChestSteal:Toggle()
			end
		end,
		Default = true
	})
	TeamFilter = ChestSteal:CreateToggle({
		Name = 'Team Chest Filter',
		Tooltip = 'Avoid stealing from your own team\'s chests',
		Default = false
	})
	DelayToggle = ChestSteal:CreateToggle({
		Name = 'Delay',
		Function = function(callback)
			DelaySlider.Object.Visible = callback
			if ChestSteal.Enabled then
				ChestSteal:Toggle()
				ChestSteal:Toggle()
			end
		end
	})
	DelaySlider = ChestSteal:CreateSlider({
		Name = 'Delay Time',
		Min = 0.1,
		Max = 5,
		Default = 1,
		Decimal = 10,
		Suffix = 's',
		Visible = false
	})
end)
	
run(function()
	local AutoBank
	local UIToggle
	local GUICheck
	local UI
	local Chests
	local Items = {}
	local BankToggles = {
		iron = nil,
		diamond = nil,
		emerald = nil
	}
	local cachedChest
	local lastChestCheck = 0
	local lastHotbarUpdate = 0
	
	local function addItem(itemType, shop)
		local item = Instance.new('ImageLabel')
		item.Image = bedwars.getIcon({itemType = itemType}, true)
		item.Size = UDim2.fromOffset(32, 32)
		item.Name = itemType
		item.BackgroundTransparency = 1
		item.LayoutOrder = #UI:GetChildren()
		item.Parent = UI
		local itemtext = Instance.new('TextLabel')
		itemtext.Name = 'Amount'
		itemtext.Size = UDim2.fromScale(1, 1)
		itemtext.BackgroundTransparency = 1
		itemtext.Text = ''
		itemtext.TextColor3 = Color3.new(1, 1, 1)
		itemtext.TextSize = 16
		itemtext.TextStrokeTransparency = 0.3
		itemtext.Font = Enum.Font.Arial
		itemtext.Parent = item
		Items[itemType] = {Object = itemtext, Type = shop}
	end
	
	local function refreshBank(echest)
		for i, v in pairs(Items) do
			local item = echest:FindFirstChild(i)
			v.Object.Text = item and item:GetAttribute('Amount') or ''
		end
	end
	
	local function nearChest()
		if not entitylib.isAlive then return false end
		
		local pos = entitylib.character.RootPart.Position
		local maxDistanceSq = 22 * 22 
		
		for _, chest in pairs(Chests) do
			if chest.Parent then
				local offset = chest.Position - pos
				local distanceSq = offset.X * offset.X + offset.Y * offset.Y + offset.Z * offset.Z
				if distanceSq < maxDistanceSq then
					return true
				end
			end
		end
		
		return false
	end
	
	local function handleState()
		local currentTime = tick()
		
		if not cachedChest or not cachedChest.Parent or (currentTime - lastChestCheck) > 1 then
			cachedChest = replicatedStorage.Inventories:FindFirstChild(lplr.Name..'_personal')
			lastChestCheck = currentTime
		end
		
		if not cachedChest then return end
		
		if not nearChest() and not GUICheck.Enabled then 
			return 
		end
		
		local itemsToDeposit = {}
		for _, v in ipairs(store.inventory.inventory.items) do
			local itemInfo = Items[v.itemType]
			if itemInfo and BankToggles[v.itemType] and BankToggles[v.itemType].Enabled then
				table.insert(itemsToDeposit, v)
			end
		end
		
		if #itemsToDeposit > 0 then
			for _, v in ipairs(itemsToDeposit) do
				bedwars.Client:GetNamespace('Inventory'):Get('ChestGiveItem'):CallServer(cachedChest, v.tool)
			end
			task.defer(function()
				if cachedChest and cachedChest.Parent then
					refreshBank(cachedChest)
				end
			end)
		end
	end
	
	AutoBank = vape.Categories.Inventory:CreateModule({
		Name = 'AutoBank',
		Function = function(callback)
			if callback then
				Chests = collection('personal-chest', AutoBank)
				cachedChest = nil
				lastChestCheck = 0
				lastHotbarUpdate = 0
				
				UI = Instance.new('Frame')
				UI.Size = UDim2.new(1, 0, 0, 32)
				UI.Position = UDim2.fromOffset(0, -240)
				UI.BackgroundTransparency = 1
				UI.Visible = UIToggle.Enabled
				UI.Parent = vape.gui
				AutoBank:Clean(UI)
				
				local Sort = Instance.new('UIListLayout')
				Sort.FillDirection = Enum.FillDirection.Horizontal
				Sort.HorizontalAlignment = Enum.HorizontalAlignment.Center
				Sort.SortOrder = Enum.SortOrder.LayoutOrder
				Sort.Parent = UI
				
				addItem('iron', true)
				addItem('diamond', false)
				addItem('emerald', true)
				
				local cachedHotbar
				local guiInset = guiService:GetGuiInset().Y

				repeat
					local currentTime = tick()
					
					if (currentTime - lastHotbarUpdate) > 0.5 then
						local playerGui = lplr.PlayerGui
						if playerGui then
							local hotbar = playerGui:FindFirstChild('hotbar')
							if hotbar then
								local container = hotbar['1']:FindFirstChild('HotbarHealthbarContainer')
								if container then
									cachedHotbar = container
									UI.Position = UDim2.fromOffset(0, (container.AbsolutePosition.Y + guiInset) - 40)
									lastHotbarUpdate = currentTime
								end
							end
						end
					end

					local shouldBank = false
					
					if GUICheck.Enabled then
						shouldBank = bedwars.AppController:isAppOpen('ChestApp') or 
						             bedwars.AppController:isAppOpen('BedwarsAppIds.CHEST_INVENTORY')
					else
						shouldBank = nearChest()
					end
					
					if shouldBank then
						handleState()
					end

					task.wait(0.1)
				until (not AutoBank.Enabled)
			else
				table.clear(Items)
				cachedChest = nil
			end
		end,
		Tooltip = 'Automatically puts resources in ender chest'
	})
	
	UIToggle = AutoBank:CreateToggle({
		Name = 'UI',
		Function = function(callback)
			if AutoBank.Enabled and UI then
				UI.Visible = callback
			end
		end,
		Default = true
	})
	
	GUICheck = AutoBank:CreateToggle({
		Name = 'GUI Check',
		Tooltip = 'Only banks items when chest is open (bypasses distance limit)'
	})
	
	BankToggles.iron = AutoBank:CreateToggle({
		Name = 'Bank Iron',
		Tooltip = 'Automatically bank iron',
		Default = true
	})
	
	BankToggles.diamond = AutoBank:CreateToggle({
		Name = 'Bank Diamond',
		Tooltip = 'Automatically bank diamonds',
		Default = true
	})
	
	BankToggles.emerald = AutoBank:CreateToggle({
		Name = 'Bank Emerald',
		Tooltip = 'Automatically bank emeralds',
		Default = true
	})
end)
	
run(function()
	local AutoBuy
	local Sword
	local Armor
	local Upgrades
	local TierCheck
	local BedwarsCheck
	local GUI
	local SmartCheck
	local Custom = {}
	local CustomPost = {}
	local UpgradeToggles = {}
	local Functions, id = {}
	local Callbacks = {Custom, Functions, CustomPost}
	local npctick = tick()
	
	local swords = {
		'wood_sword',
		'stone_sword',
		'iron_sword',
		'diamond_sword',
		'emerald_sword'
	}
	
	local armors = {
		'none',
		'leather_chestplate',
		'iron_chestplate',
		'diamond_chestplate',
		'emerald_chestplate'
	}
	
	local axes = {
		'none',
		'wood_axe',
		'stone_axe',
		'iron_axe',
		'diamond_axe'
	}
	
	local pickaxes = {
		'none',
		'wood_pickaxe',
		'stone_pickaxe',
		'iron_pickaxe',
		'diamond_pickaxe'
	}
	
	local function getShopNPC()
		local shop, items, upgrades, newid = nil, false, false, nil
		if entitylib.isAlive then
			local localPosition = entitylib.character.RootPart.Position
			for _, v in store.shop do
				if (v.RootPart.Position - localPosition).Magnitude <= 20 then
					shop = v.Upgrades or v.Shop or nil
					upgrades = upgrades or v.Upgrades
					items = items or v.Shop
					newid = v.Shop and v.Id or newid
				end
			end
		end
		return shop, items, upgrades, newid
	end
	
	local function canBuy(item, currencytable, amount)
		amount = amount or 1
		if not currencytable[item.currency] then
			local currency = getItem(item.currency)
			currencytable[item.currency] = currency and currency.amount or 0
		end
		if item.ignoredByKit and table.find(item.ignoredByKit, store.equippedKit or '') then return false end
		if item.lockedByForge or item.disabled then return false end
		if item.require and item.require.teamUpgrade then
			if (bedwars.Store:getState().Bedwars.teamUpgrades[item.require.teamUpgrade.upgradeId] or -1) < item.require.teamUpgrade.lowestTierIndex then
				return false
			end
		end
		return currencytable[item.currency] >= (item.price * amount)
	end
	
	local function buyItem(item, currencytable)
		if not id then return end
		notif('AutoBuy', 'Bought '..bedwars.ItemMeta[item.itemType].displayName, 3)
		bedwars.Client:Get('BedwarsPurchaseItem'):CallServerAsync({
			shopItem = item,
			shopId = id
		}):andThen(function(suc)
			if suc then
				bedwars.SoundManager:playSound(bedwars.SoundList.BEDWARS_PURCHASE_ITEM)
				bedwars.Store:dispatch({
					type = 'BedwarsAddItemPurchased',
					itemType = item.itemType
				})
			end
		end)
		currencytable[item.currency] -= item.price
	end
	
	local function buyUpgrade(upgradeType, currencytable)
		if not Upgrades.Enabled then return end
		local upgrade = bedwars.TeamUpgradeMeta[upgradeType]
		local currentUpgrades = bedwars.Store:getState().Bedwars.teamUpgrades[lplr:GetAttribute('Team')] or {}
		local currentTier = (currentUpgrades[upgradeType] or 0) + 1
		local bought = false
	
		for i = currentTier, #upgrade.tiers do
			local tier = upgrade.tiers[i]
			if tier.availableOnlyInQueue and not table.find(tier.availableOnlyInQueue, store.queueType) then continue end
	
			if canBuy({currency = 'diamond', price = tier.cost}, currencytable) then
				notif('AutoBuy', 'Bought '..(upgrade.name == 'Armor' and 'Protection' or upgrade.name)..' '..i, 3)
				bedwars.Client:Get('RequestPurchaseTeamUpgrade'):CallServerAsync(upgradeType)
				currencytable.diamond -= tier.cost
				bought = true
			else
				break
			end
		end
	
		return bought
	end
	
	local function buyTool(tool, tools, currencytable)
		local bought, buyable = false
		tool = tool and table.find(tools, tool.itemType) and table.find(tools, tool.itemType) + 1 or math.huge
	
		for i = tool, #tools do
			local v = bedwars.Shop.getShopItem(tools[i], lplr)
			if canBuy(v, currencytable) then
				if SmartCheck.Enabled and bedwars.ItemMeta[tools[i]].breakBlock and i > 2 then
					if Armor.Enabled then
						local currentarmor = store.inventory.inventory.armor[2]
						currentarmor = currentarmor and currentarmor ~= 'empty' and currentarmor.itemType or 'none'
						if (table.find(armors, currentarmor) or 3) < 3 then break end
					end
					if Sword.Enabled then
						if store.tools.sword and (table.find(swords, store.tools.sword.itemType) or 2) < 2 then break end
					end
				end
				bought = true
				buyable = v
			end
			if TierCheck.Enabled and v.nextTier then break end
		end
	
		if buyable then
			buyItem(buyable, currencytable)
		end
	
		return bought
	end
	
	AutoBuy = vape.Categories.Inventory:CreateModule({
		Name = 'AutoBuy',
		Function = function(callback)
			if callback then
				repeat task.wait() until store.queueType ~= 'bedwars_test'
				if BedwarsCheck.Enabled and not store.queueType:find('bedwars') then return end
	
				local lastupgrades
				AutoBuy:Clean(vapeEvents.InventoryAmountChanged.Event:Connect(function()
					if (npctick - tick()) > 1 then npctick = tick() end
				end))
	
				repeat
					local npc, shop, upgrades, newid = getShopNPC()
					id = newid
					if GUI.Enabled then
						if not (bedwars.AppController:isAppOpen('BedwarsItemShopApp') or bedwars.AppController:isAppOpen('TeamUpgradeApp')) then
							npc = nil
						end
					end
	
					if npc and lastupgrades ~= upgrades then
						if (npctick - tick()) > 1 then npctick = tick() end
						lastupgrades = upgrades
					end
	
					if npc and npctick <= tick() and store.matchState ~= 2 and store.shopLoaded then
						local currencytable = {}
						local waitcheck
						for _, tab in Callbacks do
							for _, callback in tab do
								if callback(currencytable, shop, upgrades) then
									waitcheck = true
								end
							end
						end
						npctick = tick() + (waitcheck and 0.4 or math.huge)
					end
	
					task.wait(0.1)
				until not AutoBuy.Enabled
			else
				npctick = tick()
			end
		end,
		Tooltip = 'Automatically buys items when you go near the shop'
	})
	Sword = AutoBuy:CreateToggle({
		Name = 'Buy Sword',
		Function = function(callback)
			npctick = tick()
			Functions[2] = callback and function(currencytable, shop)
				if not shop then return end
	
				if store.equippedKit == 'dasher' then
					swords = {
						[1] = 'wood_dao',
						[2] = 'stone_dao',
						[3] = 'iron_dao',
						[4] = 'diamond_dao',
						[5] = 'emerald_dao'
					}
				elseif store.equippedKit == 'ice_queen' then
					swords[5] = 'ice_sword'
				elseif store.equippedKit == 'ember' then
					swords[5] = 'infernal_saber'
				elseif store.equippedKit == 'lumen' then
					swords[5] = 'light_sword'
				end
	
				return buyTool(store.tools.sword, swords, currencytable)
			end or nil
		end
	})
	Armor = AutoBuy:CreateToggle({
		Name = 'Buy Armor',
		Function = function(callback)
			npctick = tick()
			Functions[1] = callback and function(currencytable, shop)
				if not shop then return end
				local currentarmor = store.inventory.inventory.armor[2] ~= 'empty' and store.inventory.inventory.armor[2] or getBestArmor(1)
				currentarmor = currentarmor and currentarmor.itemType or 'none'
				return buyTool({itemType = currentarmor}, armors, currencytable)
			end or nil
		end,
		Default = true
	})
	AutoBuy:CreateToggle({
		Name = 'Buy Axe',
		Function = function(callback)
			npctick = tick()
			Functions[3] = callback and function(currencytable, shop)
				if not shop then return end
				return buyTool(store.tools.wood or {itemType = 'none'}, axes, currencytable)
			end or nil
		end
	})
	AutoBuy:CreateToggle({
		Name = 'Buy Pickaxe',
		Function = function(callback)
			npctick = tick()
			Functions[4] = callback and function(currencytable, shop)
				if not shop then return end
				return buyTool(store.tools.stone, pickaxes, currencytable)
			end or nil
		end
	})
	Upgrades = AutoBuy:CreateToggle({
		Name = 'Buy Upgrades',
		Function = function(callback)
			for _, v in UpgradeToggles do
				v.Object.Visible = callback
			end
		end,
		Default = true
	})
	local count = 0
	for i, v in bedwars.TeamUpgradeMeta do
		local toggleCount = count
		table.insert(UpgradeToggles, AutoBuy:CreateToggle({
			Name = 'Buy '..(v.name == 'Armor' and 'Protection' or v.name),
			Function = function(callback)
				npctick = tick()
				Functions[5 + toggleCount + (v.name == 'Armor' and 20 or 0)] = callback and function(currencytable, shop, upgrades)
					if not upgrades then return end
					if v.disabledInQueue and table.find(v.disabledInQueue, store.queueType) then return end
					return buyUpgrade(i, currencytable)
				end or nil
			end,
			Darker = true,
			Default = (i == 'ARMOR' or i == 'DAMAGE')
		}))
		count += 1
	end
	TierCheck = AutoBuy:CreateToggle({Name = 'Tier Check'})
	BedwarsCheck = AutoBuy:CreateToggle({
		Name = 'Only Bedwars',
		Function = function()
			if AutoBuy.Enabled then
				AutoBuy:Toggle()
				AutoBuy:Toggle()
			end
		end,
		Default = true
	})
	GUI = AutoBuy:CreateToggle({Name = 'GUI check'})
	SmartCheck = AutoBuy:CreateToggle({
		Name = 'Smart check',
		Default = true,
		Tooltip = 'Buys iron armor before iron axe'
	})
	local KeepBuying = AutoBuy:CreateToggle({
		Name = 'Keep Buying',
		Tooltip = 'Always buys the set amount from item list, ignoring current inventory',
		Function = function(callback)
			if callback then
				npctick = tick()
			end
		end
	})
	AutoBuy:CreateTextList({
		Name = 'Item',
		Placeholder = 'priority/item/amount/skip50',
		Function = function(list)
			table.clear(Custom)
			table.clear(CustomPost)
			for _, entry in list do
				local tab = entry:split('/')
				local ind = tonumber(tab[1])
				if ind then
					local isPost = tab[4] and tab[4]:lower():find('after')
					local skipAmount = tab[4] and tonumber(tab[4]:match('%d+')) or nil
					
					(isPost and CustomPost or Custom)[ind] = function(currencytable, shop)
						if not shop then return end
						if not store.shopLoaded then return end
						
						local success, v = pcall(function()
							return bedwars.Shop.getShopItem(tab[2], lplr)
						end)
						
						if not success or not v then
							return false
						end
						
						local item = getItem(tab[2] == 'wool_white' and bedwars.Shop.getTeamWool(lplr:GetAttribute('Team')) or tab[2])
						local currentAmount = item and item.amount or 0
						local targetAmount = tonumber(tab[3])
						
						if tab[2] == 'arrow' and skipAmount then
							local hasBow = getBow()
							local hasCrossbow = getItem('crossbow')
							local hasHeadhunter = getItem('headhunter_bow')
							if not (hasBow or hasCrossbow or hasHeadhunter) then
								return false
							end
						end
						
						if KeepBuying.Enabled then
							local purchasesNeeded = math.ceil(targetAmount / v.amount)
							
							if purchasesNeeded > 0 and canBuy(v, currencytable, purchasesNeeded) then
								for _ = 1, purchasesNeeded do
									buyItem(v, currencytable)
								end
								return true
							end
						else
							local needToBuy = math.max(0, targetAmount - currentAmount)
							
							if needToBuy <= 0 then
								return false
							end

							if skipAmount and currentAmount >= skipAmount then
								return false
							end
							
							local purchasesNeeded = math.ceil(needToBuy / v.amount)
							
							if canBuy(v, currencytable, purchasesNeeded) then
								for _ = 1, purchasesNeeded do
									buyItem(v, currencytable)
								end
								return true
							end
						end
						
						return false
					end
				end
			end
		end
	})
end)

run(function()
    local BuyBlocksModule
    local GUICheck
    local DelaySlider
    local MaxAmount
    local LowBlocksToggle
    local LowBlocksThreshold
    local running = false

    local function getShopNPC()
        local shopFound = false
        if entitylib.isAlive then
            local localPosition = entitylib.character.RootPart.Position
            for _, v in store.shop do
                if (v.RootPart.Position - localPosition).Magnitude <= 20 then
                    shopFound = true
                    break
                end
            end
        end
        return shopFound
    end

    local function getBlockCount()
        local count = 0
        for _, item in store.inventory.inventory.items do
            if bedwars.ItemMeta[item.itemType].block then
                count = count + item.amount
            end
        end
        return count
    end

    BuyBlocksModule = vape.Categories.Inventory:CreateModule({
        Name = "BuyBlocks",
        Function = function(enabled)
            running = enabled

            if enabled then
                task.spawn(function()
                    while running do
                        local currentBlocks = getBlockCount()
                        local shouldBuy = true

                        if currentBlocks >= MaxAmount.Value then
                            shouldBuy = false
                        end

                        if LowBlocksToggle.Enabled then
                            if currentBlocks >= LowBlocksThreshold.Value then
                                shouldBuy = false
                            end
                        end

                        if shouldBuy then
                            local canBuy = true
                            
                            if GUICheck.Enabled then
                                if bedwars.AppController:isAppOpen('BedwarsItemShopApp') then
                                    canBuy = true
                                else
                                    canBuy = false
                                end
                            else
                                canBuy = getShopNPC()
                            end

                            if canBuy then
                                local args = {
                                    {
                                        shopItem = {
                                            currency = "iron",
                                            itemType = "wool_white",
                                            amount = 16,
                                            price = 8,
                                            disabledInQueue = {
                                                "mine_wars"
                                            },
                                            category = "Blocks"
                                        },
                                        shopId = "1_item_shop"
                                    }
                                }

                                pcall(function()
                                    game:GetService("ReplicatedStorage")
                                    :WaitForChild("rbxts_include")
                                    :WaitForChild("node_modules")
                                    :WaitForChild("@rbxts")
                                    :WaitForChild("net")
                                    :WaitForChild("out")
                                    :WaitForChild("_NetManaged")
                                    :WaitForChild("BedwarsPurchaseItem")
                                    :InvokeServer(unpack(args))
                                end)
                            end
                        end

                        task.wait(DelaySlider.Value)
                    end
                end)
            end
        end,
        Tooltip = "Automatically buys wool blocks"
    })

    GUICheck = BuyBlocksModule:CreateToggle({
        Name = "GUI Check",
        Tooltip = "Only buy when shop GUI is open",
        Default = false
    })

    MaxAmount = BuyBlocksModule:CreateSlider({
        Name = "Max Amount",
        Min = 16,
        Max = 256,
        Default = 128,
        Tooltip = "Stop buying when you have this many blocks",
        Suffix = function(val)
            return val == 1 and " block" or " blocks"
        end
    })

    LowBlocksToggle = BuyBlocksModule:CreateToggle({
        Name = "Buy on Low Blocks",
        Tooltip = "Only buy blocks when below threshold",
        Default = false,
        Function = function(callback)
            LowBlocksThreshold.Object.Visible = callback
        end
    })

    LowBlocksThreshold = BuyBlocksModule:CreateSlider({
        Name = "Low Blocks Threshold",
        Min = 0,
        Max = 128,
        Default = 32,
        Tooltip = "Buy blocks when you have less than this amount",
        Visible = false,
        Suffix = function(val)
            return val == 1 and " block" or " blocks"
        end
    })

    DelaySlider = BuyBlocksModule:CreateSlider({
        Name = "Delay",
        Min = 0.1,
        Max = 2,
        Default = 0.1,
        Decimal = 10,
        Tooltip = "Delay between purchases (seconds)",
        Suffix = "s"
    })
end)
	
run(function()
	local AutoConsume
	local Health
	local SpeedPotion
	local Apple
	local ShieldPotion
	
	local function consumeCheck(attribute)
		if entitylib.isAlive then
			if SpeedPotion.Enabled and (not attribute or attribute == 'StatusEffect_speed') then
				local speedpotion = getItem('speed_potion')
				if speedpotion and (not lplr.Character:GetAttribute('StatusEffect_speed')) then
					for _ = 1, 4 do
						if bedwars.Client:Get(remotes.ConsumeItem):CallServer({item = speedpotion.tool}) then break end
					end
				end
			end
	
			if Apple.Enabled and (not attribute or attribute:find('Health')) then
				if (lplr.Character:GetAttribute('Health') / lplr.Character:GetAttribute('MaxHealth')) <= (Health.Value / 100) then
					local apple = getItem('orange') or (not lplr.Character:GetAttribute('StatusEffect_golden_apple') and getItem('golden_apple')) or getItem('apple')
					
					if apple then
						bedwars.Client:Get(remotes.ConsumeItem):CallServerAsync({
							item = apple.tool
						})
					end
				end
			end
	
			if ShieldPotion.Enabled and (not attribute or attribute:find('Shield')) then
				if (lplr.Character:GetAttribute('Shield_POTION') or 0) == 0 then
					local shield = getItem('big_shield') or getItem('mini_shield')
	
					if shield then
						bedwars.Client:Get(remotes.ConsumeItem):CallServerAsync({
							item = shield.tool
						})
					end
				end
			end
		end
	end
	
	AutoConsume = vape.Categories.Inventory:CreateModule({
		Name = 'AutoConsume',
		Function = function(callback)
			if callback then
				AutoConsume:Clean(vapeEvents.InventoryAmountChanged.Event:Connect(consumeCheck))
				AutoConsume:Clean(vapeEvents.AttributeChanged.Event:Connect(function(attribute)
					if attribute:find('Shield') or attribute:find('Health') or attribute == 'StatusEffect_speed' then
						consumeCheck(attribute)
					end
				end))
				consumeCheck()
			end
		end,
		Tooltip = 'Automatically heals for you when health or shield is under threshold.'
	})
	Health = AutoConsume:CreateSlider({
		Name = 'Health Percent',
		Min = 1,
		Max = 99,
		Default = 70,
		Suffix = '%'
	})
	SpeedPotion = AutoConsume:CreateToggle({
		Name = 'Speed Potions',
		Default = true
	})
	Apple = AutoConsume:CreateToggle({
		Name = 'Apple',
		Default = true
	})
	ShieldPotion = AutoConsume:CreateToggle({
		Name = 'Shield Potions',
		Default = true
	})
end)
	
run(function()
	local AutoHotbar
	local Mode
	local Clear
	local List
	local Active
	
	local function CreateWindow(self)
		local selectedslot = 1
		local window = Instance.new('Frame')
		window.Name = 'HotbarGUI'
		window.Size = UDim2.fromOffset(660, 465)
		window.Position = UDim2.fromScale(0.5, 0.5)
		window.BackgroundColor3 = uipallet.Main
		window.AnchorPoint = Vector2.new(0.5, 0.5)
		window.Visible = false
		window.Parent = vape.gui.ScaledGui
		local title = Instance.new('TextLabel')
		title.Name = 'Title'
		title.Size = UDim2.new(1, -10, 0, 20)
		title.Position = UDim2.fromOffset(math.abs(title.Size.X.Offset), 12)
		title.BackgroundTransparency = 1
		title.Text = 'AutoHotbar'
		title.TextXAlignment = Enum.TextXAlignment.Left
		title.TextColor3 = uipallet.Text
		title.TextSize = 13
		title.FontFace = uipallet.Font
		title.Parent = window
		local divider = Instance.new('Frame')
		divider.Name = 'Divider'
		divider.Size = UDim2.new(1, 0, 0, 1)
		divider.Position = UDim2.fromOffset(0, 40)
		divider.BackgroundColor3 = color.Light(uipallet.Main, 0.04)
		divider.BorderSizePixel = 0
		divider.Parent = window
		addBlur(window)
		local modal = Instance.new('TextButton')
		modal.Text = ''
		modal.BackgroundTransparency = 1
		modal.Modal = true
		modal.Parent = window
		local corner = Instance.new('UICorner')
		corner.CornerRadius = UDim.new(0, 5)
		corner.Parent = window
		local close = Instance.new('ImageButton')
		close.Name = 'Close'
		close.Size = UDim2.fromOffset(24, 24)
		close.Position = UDim2.new(1, -35, 0, 9)
		close.BackgroundColor3 = Color3.new(1, 1, 1)
		close.BackgroundTransparency = 1
		close.Image = getcustomasset('newvape/assets/new/close.png')
		close.ImageColor3 = color.Light(uipallet.Text, 0.2)
		close.ImageTransparency = 0.5
		close.AutoButtonColor = false
		close.Parent = window
		close.MouseEnter:Connect(function()
			close.ImageTransparency = 0.3
			tween:Tween(close, TweenInfo.new(0.2), {
				BackgroundTransparency = 0.6
			})
		end)
		close.MouseLeave:Connect(function()
			close.ImageTransparency = 0.5
			tween:Tween(close, TweenInfo.new(0.2), {
				BackgroundTransparency = 1
			})
		end)
		close.MouseButton1Click:Connect(function()
			window.Visible = false
			vape.gui.ScaledGui.ClickGui.Visible = true
		end)
		local closecorner = Instance.new('UICorner')
		closecorner.CornerRadius = UDim.new(1, 0)
		closecorner.Parent = close
		local bigslot = Instance.new('Frame')
		bigslot.Size = UDim2.fromOffset(110, 111)
		bigslot.Position = UDim2.fromOffset(11, 71)
		bigslot.BackgroundColor3 = color.Dark(uipallet.Main, 0.02)
		bigslot.Parent = window
		local bigslotcorner = Instance.new('UICorner')
		bigslotcorner.CornerRadius = UDim.new(0, 4)
		bigslotcorner.Parent = bigslot
		local bigslotstroke = Instance.new('UIStroke')
		bigslotstroke.Color = color.Light(uipallet.Main, 0.034)
		bigslotstroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
		bigslotstroke.Parent = bigslot
		local slotnum = Instance.new('TextLabel')
		slotnum.Size = UDim2.fromOffset(80, 20)
		slotnum.Position = UDim2.fromOffset(25, 200)
		slotnum.BackgroundTransparency = 1
		slotnum.Text = 'SLOT 1'
		slotnum.TextColor3 = color.Dark(uipallet.Text, 0.1)
		slotnum.TextSize = 12
		slotnum.FontFace = uipallet.Font
		slotnum.Parent = window
		for i = 1, 9 do
			local slotbkg = Instance.new('TextButton')
			slotbkg.Name = 'Slot'..i
			slotbkg.Size = UDim2.fromOffset(51, 52)
			slotbkg.Position = UDim2.fromOffset(89 + (i * 55), 382)
			slotbkg.BackgroundColor3 = color.Dark(uipallet.Main, 0.02)
			slotbkg.Text = ''
			slotbkg.AutoButtonColor = false
			slotbkg.Parent = window
			local slotimage = Instance.new('ImageLabel')
			slotimage.Size = UDim2.fromOffset(32, 32)
			slotimage.Position = UDim2.new(0.5, -16, 0.5, -16)
			slotimage.BackgroundTransparency = 1
			slotimage.Image = ''
			slotimage.Parent = slotbkg
			local slotcorner = Instance.new('UICorner')
			slotcorner.CornerRadius = UDim.new(0, 4)
			slotcorner.Parent = slotbkg
			local slotstroke = Instance.new('UIStroke')
			slotstroke.Color = color.Light(uipallet.Main, 0.04)
			slotstroke.Thickness = 2
			slotstroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
			slotstroke.Enabled = i == selectedslot
			slotstroke.Parent = slotbkg
			slotbkg.MouseEnter:Connect(function()
				slotbkg.BackgroundColor3 = color.Light(uipallet.Main, 0.034)
			end)
			slotbkg.MouseLeave:Connect(function()
				slotbkg.BackgroundColor3 = color.Dark(uipallet.Main, 0.02)
			end)
			slotbkg.MouseButton1Click:Connect(function()
				window['Slot'..selectedslot].UIStroke.Enabled = false
				selectedslot = i
				slotstroke.Enabled = true
				slotnum.Text = 'SLOT '..selectedslot
			end)
			slotbkg.MouseButton2Click:Connect(function()
				local obj = self.Hotbars[self.Selected]
				if obj then
					window['Slot'..i].ImageLabel.Image = ''
					obj.Hotbar[tostring(i)] = nil
					obj.Object['Slot'..i].Image = '	'
				end
			end)
		end
		local searchbkg = Instance.new('Frame')
		searchbkg.Size = UDim2.fromOffset(496, 31)
		searchbkg.Position = UDim2.fromOffset(142, 80)
		searchbkg.BackgroundColor3 = color.Light(uipallet.Main, 0.034)
		searchbkg.Parent = window
		local search = Instance.new('TextBox')
		search.Size = UDim2.new(1, -10, 0, 31)
		search.Position = UDim2.fromOffset(10, 0)
		search.BackgroundTransparency = 1
		search.Text = ''
		search.PlaceholderText = ''
		search.TextXAlignment = Enum.TextXAlignment.Left
		search.TextColor3 = uipallet.Text
		search.TextSize = 12
		search.FontFace = uipallet.Font
		search.ClearTextOnFocus = false
		search.Parent = searchbkg
		local searchcorner = Instance.new('UICorner')
		searchcorner.CornerRadius = UDim.new(0, 4)
		searchcorner.Parent = searchbkg
		local searchicon = Instance.new('ImageLabel')
		searchicon.Size = UDim2.fromOffset(14, 14)
		searchicon.Position = UDim2.new(1, -26, 0, 8)
		searchicon.BackgroundTransparency = 1
		searchicon.Image = getcustomasset('newvape/assets/new/search.png')
		searchicon.ImageColor3 = color.Light(uipallet.Main, 0.37)
		searchicon.Parent = searchbkg
		local children = Instance.new('ScrollingFrame')
		children.Name = 'Children'
		children.Size = UDim2.fromOffset(500, 240)
		children.Position = UDim2.fromOffset(144, 122)
		children.BackgroundTransparency = 1
		children.BorderSizePixel = 0
		children.ScrollBarThickness = 2
		children.ScrollBarImageTransparency = 0.75
		children.CanvasSize = UDim2.new()
		children.Parent = window
		local windowlist = Instance.new('UIGridLayout')
		windowlist.SortOrder = Enum.SortOrder.LayoutOrder
		windowlist.FillDirectionMaxCells = 9
		windowlist.CellSize = UDim2.fromOffset(51, 52)
		windowlist.CellPadding = UDim2.fromOffset(4, 3)
		windowlist.Parent = children
		windowlist:GetPropertyChangedSignal('AbsoluteContentSize'):Connect(function()
			if vape.ThreadFix then
				setthreadidentity(8)
			end
			children.CanvasSize = UDim2.fromOffset(0, windowlist.AbsoluteContentSize.Y / vape.guiscale.Scale)
		end)
		table.insert(vape.Windows, window)
	
		local function createitem(id, image)
			local slotbkg = Instance.new('TextButton')
			slotbkg.BackgroundColor3 = color.Light(uipallet.Main, 0.02)
			slotbkg.Text = ''
			slotbkg.AutoButtonColor = false
			slotbkg.Parent = children
			local slotimage = Instance.new('ImageLabel')
			slotimage.Size = UDim2.fromOffset(32, 32)
			slotimage.Position = UDim2.new(0.5, -16, 0.5, -16)
			slotimage.BackgroundTransparency = 1
			slotimage.Image = image
			slotimage.Parent = slotbkg
			local slotcorner = Instance.new('UICorner')
			slotcorner.CornerRadius = UDim.new(0, 4)
			slotcorner.Parent = slotbkg
			slotbkg.MouseEnter:Connect(function()
				slotbkg.BackgroundColor3 = color.Light(uipallet.Main, 0.04)
			end)
			slotbkg.MouseLeave:Connect(function()
				slotbkg.BackgroundColor3 = color.Light(uipallet.Main, 0.02)
			end)
			slotbkg.MouseButton1Click:Connect(function()
				local obj = self.Hotbars[self.Selected]
				if obj then
					window['Slot'..selectedslot].ImageLabel.Image = image
					obj.Hotbar[tostring(selectedslot)] = id
					obj.Object['Slot'..selectedslot].Image = image
				end
			end)
		end
	
		local function indexSearch(text)
			for _, v in children:GetChildren() do
				if v:IsA('TextButton') then
					v:ClearAllChildren()
					v:Destroy()
				end
			end
	
			if text == '' then
				for _, v in {'diamond_sword', 'diamond_pickaxe', 'diamond_axe', 'shears', 'wood_bow', 'wool_white', 'fireball', 'apple', 'iron', 'gold', 'diamond', 'emerald'} do
					createitem(v, bedwars.ItemMeta[v].image)
				end
				return
			end
	
			for i, v in bedwars.ItemMeta do
				if text:lower() == i:lower():sub(1, text:len()) then
					if not v.image then continue end
					createitem(i, v.image)
				end
			end
		end
	
		search:GetPropertyChangedSignal('Text'):Connect(function()
			indexSearch(search.Text)
		end)
		indexSearch('')
	
		return window
	end
	
	vape.Components.HotbarList = function(optionsettings, children, api)
		if vape.ThreadFix then
			setthreadidentity(8)
		end
		local optionapi = {
			Type = 'HotbarList',
			Hotbars = {},
			Selected = 1
		}
		local hotbarlist = Instance.new('TextButton')
		hotbarlist.Name = 'HotbarList'
		hotbarlist.Size = UDim2.fromOffset(220, 40)
		hotbarlist.BackgroundColor3 = optionsettings.Darker and (children.BackgroundColor3 == color.Dark(uipallet.Main, 0.02) and color.Dark(uipallet.Main, 0.04) or color.Dark(uipallet.Main, 0.02)) or children.BackgroundColor3
		hotbarlist.Text = ''
		hotbarlist.BorderSizePixel = 0
		hotbarlist.AutoButtonColor = false
		hotbarlist.Parent = children
		local textbkg = Instance.new('Frame')
		textbkg.Name = 'BKG'
		textbkg.Size = UDim2.new(1, -20, 0, 31)
		textbkg.Position = UDim2.fromOffset(10, 4)
		textbkg.BackgroundColor3 = color.Light(uipallet.Main, 0.034)
		textbkg.Parent = hotbarlist
		local textbkgcorner = Instance.new('UICorner')
		textbkgcorner.CornerRadius = UDim.new(0, 4)
		textbkgcorner.Parent = textbkg
		local textbutton = Instance.new('TextButton')
		textbutton.Name = 'HotbarList'
		textbutton.Size = UDim2.new(1, -2, 1, -2)
		textbutton.Position = UDim2.fromOffset(1, 1)
		textbutton.BackgroundColor3 = uipallet.Main
		textbutton.Text = ''
		textbutton.AutoButtonColor = false
		textbutton.Parent = textbkg
		textbutton.MouseEnter:Connect(function()
			tween:Tween(textbkg, TweenInfo.new(0.2), {
				BackgroundColor3 = color.Light(uipallet.Main, 0.14)
			})
		end)
		textbutton.MouseLeave:Connect(function()
			tween:Tween(textbkg, TweenInfo.new(0.2), {
				BackgroundColor3 = color.Light(uipallet.Main, 0.034)
			})
		end)
		local textbuttoncorner = Instance.new('UICorner')
		textbuttoncorner.CornerRadius = UDim.new(0, 4)
		textbuttoncorner.Parent = textbutton
		local textbuttonicon = Instance.new('ImageLabel')
		textbuttonicon.Size = UDim2.fromOffset(12, 12)
		textbuttonicon.Position = UDim2.fromScale(0.5, 0.5)
		textbuttonicon.AnchorPoint = Vector2.new(0.5, 0.5)
		textbuttonicon.BackgroundTransparency = 1
		textbuttonicon.Image = getcustomasset('newvape/assets/new/add.png')
		textbuttonicon.ImageColor3 = Color3.fromHSV(0.46, 0.96, 0.52)
		textbuttonicon.Parent = textbutton
		local childrenlist = Instance.new('Frame')
		childrenlist.Size = UDim2.new(1, 0, 1, -40)
		childrenlist.Position = UDim2.fromOffset(0, 40)
		childrenlist.BackgroundTransparency = 1
		childrenlist.Parent = hotbarlist
		local windowlist = Instance.new('UIListLayout')
		windowlist.SortOrder = Enum.SortOrder.LayoutOrder
		windowlist.HorizontalAlignment = Enum.HorizontalAlignment.Center
		windowlist.Padding = UDim.new(0, 3)
		windowlist.Parent = childrenlist
		windowlist:GetPropertyChangedSignal('AbsoluteContentSize'):Connect(function()
			if vape.ThreadFix then
				setthreadidentity(8)
			end
			hotbarlist.Size = UDim2.fromOffset(220, math.min(43 + windowlist.AbsoluteContentSize.Y / vape.guiscale.Scale, 603))
		end)
		textbutton.MouseButton1Click:Connect(function()
			optionapi:AddHotbar()
		end)
		optionapi.Window = CreateWindow(optionapi)
	
		function optionapi:Save(savetab)
			local hotbars = {}
			for _, v in self.Hotbars do
				table.insert(hotbars, v.Hotbar)
			end
			savetab.HotbarList = {
				Selected = self.Selected,
				Hotbars = hotbars
			}
		end
	
		function optionapi:Load(savetab)
			for _, v in self.Hotbars do
				v.Object:ClearAllChildren()
				v.Object:Destroy()
				table.clear(v.Hotbar)
			end
			table.clear(self.Hotbars)
			for _, v in savetab.Hotbars do
				self:AddHotbar(v)
			end
			self.Selected = savetab.Selected or 1
		end
	
		function optionapi:AddHotbar(data)
			local hotbardata = {Hotbar = data or {}}
			table.insert(self.Hotbars, hotbardata)
			local hotbar = Instance.new('TextButton')
			hotbar.Size = UDim2.fromOffset(200, 27)
			hotbar.BackgroundColor3 = table.find(self.Hotbars, hotbardata) == self.Selected and color.Light(uipallet.Main, 0.034) or uipallet.Main
			hotbar.Text = ''
			hotbar.AutoButtonColor = false
			hotbar.Parent = childrenlist
			hotbardata.Object = hotbar
			local hotbarcorner = Instance.new('UICorner')
			hotbarcorner.CornerRadius = UDim.new(0, 4)
			hotbarcorner.Parent = hotbar
			for i = 1, 9 do
				local slot = Instance.new('ImageLabel')
				slot.Name = 'Slot'..i
				slot.Size = UDim2.fromOffset(17, 18)
				slot.Position = UDim2.fromOffset(-7 + (i * 18), 5)
				slot.BackgroundColor3 = color.Dark(uipallet.Main, 0.02)
				slot.Image = hotbardata.Hotbar[tostring(i)] and bedwars.getIcon({itemType = hotbardata.Hotbar[tostring(i)]}, true) or ''
				slot.BorderSizePixel = 0
				slot.Parent = hotbar
			end
			hotbar.MouseButton1Click:Connect(function()
				local ind = table.find(optionapi.Hotbars, hotbardata)
				if ind == optionapi.Selected then
					vape.gui.ScaledGui.ClickGui.Visible = false
					optionapi.Window.Visible = true
					for i = 1, 9 do
						optionapi.Window['Slot'..i].ImageLabel.Image = hotbardata.Hotbar[tostring(i)] and bedwars.getIcon({itemType = hotbardata.Hotbar[tostring(i)]}, true) or ''
					end
				else
					if optionapi.Hotbars[optionapi.Selected] then
						optionapi.Hotbars[optionapi.Selected].Object.BackgroundColor3 = uipallet.Main
					end
					hotbar.BackgroundColor3 = color.Light(uipallet.Main, 0.034)
					optionapi.Selected = ind
				end
			end)
			local close = Instance.new('ImageButton')
			close.Name = 'Close'
			close.Size = UDim2.fromOffset(16, 16)
			close.Position = UDim2.new(1, -23, 0, 6)
			close.BackgroundColor3 = Color3.new(1, 1, 1)
			close.BackgroundTransparency = 1
			close.Image = getcustomasset('newvape/assets/new/closemini.png')
			close.ImageColor3 = color.Light(uipallet.Text, 0.2)
			close.ImageTransparency = 0.5
			close.AutoButtonColor = false
			close.Parent = hotbar
			local closecorner = Instance.new('UICorner')
			closecorner.CornerRadius = UDim.new(1, 0)
			closecorner.Parent = close
			close.MouseEnter:Connect(function()
				close.ImageTransparency = 0.3
				tween:Tween(close, TweenInfo.new(0.2), {
					BackgroundTransparency = 0.6
				})
			end)
			close.MouseLeave:Connect(function()
				close.ImageTransparency = 0.5
				tween:Tween(close, TweenInfo.new(0.2), {
					BackgroundTransparency = 1
				})
			end)
			close.MouseButton1Click:Connect(function()
				local ind = table.find(self.Hotbars, hotbardata)
				local obj = self.Hotbars[self.Selected]
				local obj2 = self.Hotbars[ind]
				if obj and obj2 then
					obj2.Object:ClearAllChildren()
					obj2.Object:Destroy()
					table.remove(self.Hotbars, ind)
					ind = table.find(self.Hotbars, obj)
					self.Selected = table.find(self.Hotbars, obj) or 1
				end
			end)
		end
	
		api.Options.HotbarList = optionapi
	
		return optionapi
	end
	
	local function getBlock()
		local clone = table.clone(store.inventory.inventory.items)
		table.sort(clone, function(a, b)
			return a.amount < b.amount
		end)
	
		for _, item in clone do
			local block = bedwars.ItemMeta[item.itemType].block
			if block and not block.seeThrough then
				return item
			end
		end
	end
	
	local function getCustomItem(v)
		if v == 'diamond_sword' then
			local sword = store.tools.sword
			v = sword and sword.itemType or 'wood_sword'
		elseif v == 'diamond_pickaxe' then
			local pickaxe = store.tools.stone
			v = pickaxe and pickaxe.itemType or 'wood_pickaxe'
		elseif v == 'diamond_axe' then
			local axe = store.tools.wood
			v = axe and axe.itemType or 'wood_axe'
		elseif v == 'wood_bow' then
			local bow = getBow()
			v = bow and bow.itemType or 'wood_bow'
		elseif v == 'wool_white' then
			local block = getBlock()
			v = block and block.itemType or 'wool_white'
		end
	
		return v
	end
	
	local function findItemInTable(tab, item)
		for slot, v in tab do
			if item.itemType == getCustomItem(v) then
				return tonumber(slot)
			end
		end
	end
	
	local function findInHotbar(item)
		for i, v in store.inventory.hotbar do
			if v.item and v.item.itemType == item.itemType then
				return i - 1, v.item
			end
		end
	end
	
	local function findInInventory(item)
		for _, v in store.inventory.inventory.items do
			if v.itemType == item.itemType then
				return v
			end
		end
	end
	
	local function dispatch(...)
		bedwars.Store:dispatch(...)
		vapeEvents.InventoryChanged.Event:Wait()
	end
	
	local function sortCallback()
		if Active then return end
		Active = true
		local items = (List.Hotbars[List.Selected] and List.Hotbars[List.Selected].Hotbar or {})
	
		for _, v in store.inventory.inventory.items do
			local slot = findItemInTable(items, v)
			if slot then
				local olditem = store.inventory.hotbar[slot]
				if olditem.item and olditem.item.itemType == v.itemType then continue end
				if olditem.item then
					dispatch({
						type = 'InventoryRemoveFromHotbar',
						slot = slot - 1
					})
				end
	
				local newslot = findInHotbar(v)
				if newslot then
					dispatch({
						type = 'InventoryRemoveFromHotbar',
						slot = newslot
					})
					if olditem.item then
						dispatch({
							type = 'InventoryAddToHotbar',
							item = findInInventory(olditem.item),
							slot = newslot
						})
					end
				end
	
				dispatch({
					type = 'InventoryAddToHotbar',
					item = findInInventory(v),
					slot = slot - 1
				})
			elseif Clear.Enabled then
				local newslot = findInHotbar(v)
				if newslot then
				   	dispatch({
						type = 'InventoryRemoveFromHotbar',
						slot = newslot
					})
				end
			end
		end
	
		Active = false
	end
	
	AutoHotbar = vape.Categories.Inventory:CreateModule({
		Name = 'AutoHotbar',
		Function = function(callback)
			if callback then
				task.spawn(sortCallback)
				if Mode.Value == 'On Key' then
					AutoHotbar:Toggle()
					return
				end
	
				AutoHotbar:Clean(vapeEvents.InventoryAmountChanged.Event:Connect(sortCallback))
			end
		end,
		Tooltip = 'Automatically arranges hotbar to your liking.'
	})
	Mode = AutoHotbar:CreateDropdown({
		Name = 'Activation',
		List = {'Toggle', 'On Key'},
		Function = function()
			if AutoHotbar.Enabled then
				AutoHotbar:Toggle()
				AutoHotbar:Toggle()
			end
		end
	})
	Clear = AutoHotbar:CreateToggle({Name = 'Clear Hotbar'})
	List = AutoHotbar:CreateHotbarList({})
end)
	
run(function()
    local CollectionService = game:GetService('CollectionService')
    
    local antiweb = vape.Categories.Inventory:CreateModule({
        Name = 'AntiCobweb',
        Function = function(call: boolean): ()
            if call then
                repeat
                    for _, v: Part in CollectionService:GetTagged('spider-queen-web-block') do
                        local interest: TouchTransmitter? = v:FindFirstChildWhichIsA('TouchTransmitter')
                        if interest then
                            interest:Destroy()
                        end
                    end
                    task.wait(0.1)
                until not antiweb.Enabled
            end
        end,
        Tooltip = 'Prevents you from getting cobwebbed'
    })
end)

run(function()
	local Value
	local oldclickhold, oldshowprogress
	
	local FastConsume = vape.Categories.Inventory:CreateModule({
		Name = 'FastConsume',
		Function = function(callback)
			if callback then
				oldclickhold = bedwars.ClickHold.startClick
				oldshowprogress = bedwars.ClickHold.showProgress
				bedwars.ClickHold.startClick = function(self)
					self.startedClickTime = tick()
					local handle = self:showProgress()
					local clicktime = self.startedClickTime
					bedwars.RuntimeLib.Promise.defer(function()
						task.wait(self.durationSeconds * (Value.Value / 40))
						if handle == self.handle and clicktime == self.startedClickTime and self.closeOnComplete then
							self:hideProgress()
							if self.onComplete then self.onComplete() end
							if self.onPartialComplete then self.onPartialComplete(1) end
							self.startedClickTime = -1
						end
					end)
				end
	
				bedwars.ClickHold.showProgress = function(self)
					local roact = debug.getupvalue(oldshowprogress, 1)
					local countdown = roact.mount(roact.createElement('ScreenGui', {}, { roact.createElement('Frame', {
						[roact.Ref] = self.wrapperRef,
						Size = UDim2.new(),
						Position = UDim2.fromScale(0.5, 0.55),
						AnchorPoint = Vector2.new(0.5, 0),
						BackgroundColor3 = Color3.fromRGB(0, 0, 0),
						BackgroundTransparency = 0.8
					}, { roact.createElement('Frame', {
						[roact.Ref] = self.progressRef,
						Size = UDim2.fromScale(0, 1),
						BackgroundColor3 = Color3.new(1, 1, 1),
						BackgroundTransparency = 0.5
					}) }) }), lplr:FindFirstChild('PlayerGui'))
	
					self.handle = countdown
					local sizetween = tweenService:Create(self.wrapperRef:getValue(), TweenInfo.new(0.1), {
						Size = UDim2.fromScale(0.11, 0.005)
					})
					local countdowntween = tweenService:Create(self.progressRef:getValue(), TweenInfo.new(self.durationSeconds * (Value.Value / 100), Enum.EasingStyle.Linear), {
						Size = UDim2.fromScale(1, 1)
					})
	
					sizetween:Play()
					countdowntween:Play()
					table.insert(self.tweens, countdowntween)
					table.insert(self.tweens, sizetween)
					
					return countdown
				end
			else
				bedwars.ClickHold.startClick = oldclickhold
				bedwars.ClickHold.showProgress = oldshowprogress
				oldclickhold = nil
				oldshowprogress = nil
			end
		end,
		Tooltip = 'Use/Consume items quicker.'
	})
	Value = FastConsume:CreateSlider({
		Name = 'Multiplier',
		Min = 0,
		Max = 100
	})
end)
	
run(function()
	local FastDrop
	local DropDelay
	local ItemList
	local lastDropTime = 0
	
	FastDrop = vape.Categories.Inventory:CreateModule({
		Name = 'FastDrop',
		Function = function(callback)
			if callback then
				lastDropTime = 0
				repeat
					if entitylib.isAlive and (not store.inventory.opened) and (inputService:IsKeyDown(Enum.KeyCode.H) or inputService:IsKeyDown(Enum.KeyCode.Backspace)) and inputService:GetFocusedTextBox() == nil then
						if tick() - lastDropTime >= (DropDelay.Value / 1000) then
							local handItem = store.hand and store.hand.tool
							if handItem then
								local itemType = handItem.Name
								local listEnabled = ItemList.ListEnabled
								
								local shouldDrop = true
								if #listEnabled > 0 then
									shouldDrop = table.find(listEnabled, itemType) ~= nil
								end
								
								if shouldDrop then
									task.spawn(bedwars.ItemDropController.dropItemInHand)
									lastDropTime = tick()
								end
							end
							task.wait()
						else
							task.wait(0.01)
						end
					else
						task.wait(0.1)
					end
				until not FastDrop.Enabled
			else
				lastDropTime = 0
			end
		end,
		Tooltip = 'Drops items fast'
	})
	
	DropDelay = FastDrop:CreateSlider({
		Name = 'Drop Delay',
		Min = 0,
		Max = 500,
		Default = 0,
		Tooltip = 'Delay between drops (milliseconds)',
		Suffix = 'ms'
	})
	
	ItemList = FastDrop:CreateTextList({
		Name = 'Item Whitelist',
		Placeholder = 'Item name (e.g., wool_blue)',
		Tooltip = 'Only drop these items (leave empty to drop all)\nUse item meta names like: wool_blue, iron, diamond'
	})
end)
	
run(function()
    local BedPlates
    local Background
    local TeamColor
    local Color = {}
    local Reference = {}
    local BlockCache = {} 
    local Folder = Instance.new('Folder')
    Folder.Parent = vape.gui
    
	local teamColors = {
		[1] = {name = "Blue",   color = Color3.fromRGB(85, 150, 255)},
		[2] = {name = "Orange", color = Color3.fromRGB(255, 150, 50)},
		[3] = {name = "Pink",   color = Color3.fromRGB(255, 100, 200)},
		[4] = {name = "Yellow", color = Color3.fromRGB(255, 255, 50)}
	}
    
    local function getBedTeamColor(bed)
        local teamId = bed:GetAttribute('TeamID')
        if teamId and teamColors[teamId] then
            return teamColors[teamId]
        end
        return Color3.new(1, 1, 1)
    end
    
    local function scanSide(self, start, tab)
        for _, side in ipairs(sides) do
            for i = 1, 15 do
                local block = getPlacedBlock(start + (side * i))
                if not block or block == self then break end
                if not block:GetAttribute('NoBreak') and not table.find(tab, block.Name) then
                    table.insert(tab, block.Name)
                end
            end
        end
    end
    
    local function refreshAdornee(v)
        local start = v.Adornee.Position
        
        local newBlocks = {}
        scanSide(v.Adornee, start, newBlocks)
        scanSide(v.Adornee, start + Vector3.new(0, 0, 3), newBlocks)
        
        table.sort(newBlocks, function(a, b)
            local aMeta = bedwars.ItemMeta[a]
            local bMeta = bedwars.ItemMeta[b]
            local aHealth = aMeta and aMeta.block and aMeta.block.health or 0
            local bHealth = bMeta and bMeta.block and bMeta.block.health or 0
            return aHealth > bHealth
        end)
        
        local blockKey = table.concat(newBlocks, ",")
        
        if BlockCache[v] == blockKey then
            v.Enabled = #newBlocks > 0
            return
        end
        BlockCache[v] = blockKey
        
        local children = v.Frame:GetChildren()
        for _, obj in ipairs(children) do
            if obj:IsA('ImageLabel') and obj.Name ~= 'Blur' then
                obj:Destroy()
            end
        end
        
        v.Enabled = #newBlocks > 0
        
        for _, block in ipairs(newBlocks) do
            local blockimage = Instance.new('ImageLabel')
            blockimage.Size = UDim2.fromOffset(32, 32)
            blockimage.BackgroundTransparency = 1
            blockimage.Image = bedwars.getIcon({itemType = block}, true)
            blockimage.Parent = v.Frame
        end
    end
    
    local function Added(v)
        if Reference[v] then return end
        
        local billboard = Instance.new('BillboardGui')
        billboard.Parent = Folder
        billboard.Name = 'bed'
        billboard.StudsOffsetWorldSpace = Vector3.new(0, 3, 0)
        billboard.Size = UDim2.fromOffset(36, 36)
        billboard.AlwaysOnTop = true
        billboard.ClipsDescendants = false
        billboard.Adornee = v
        
        local blur = addBlur(billboard)
        blur.Visible = Background.Enabled
        
        local frame = Instance.new('Frame')
        frame.Size = UDim2.fromScale(1, 1)
        frame.BackgroundColor3 = TeamColor.Enabled and getBedTeamColor(v) or Color3.fromHSV(Color.Hue, Color.Sat, Color.Value)
        frame.BackgroundTransparency = 1 - (Background.Enabled and (TeamColor.Enabled and 0.5 or Color.Opacity) or 0)
        frame.Parent = billboard
        
        local layout = Instance.new('UIListLayout')
        layout.FillDirection = Enum.FillDirection.Horizontal
        layout.Padding = UDim.new(0, 4)
        layout.VerticalAlignment = Enum.VerticalAlignment.Center
        layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
        layout:GetPropertyChangedSignal('AbsoluteContentSize'):Connect(function()
            billboard.Size = UDim2.fromOffset(math.max(layout.AbsoluteContentSize.X + 4, 36), 36)
        end)
        layout.Parent = frame
        
        local corner = Instance.new('UICorner')
        corner.CornerRadius = UDim.new(0, 4)
        corner.Parent = frame
        
        Reference[v] = billboard
        BlockCache[v] = ""
        refreshAdornee(billboard)
    end
    
    local function refreshNear(data)
        local blockPos = data.blockRef.blockPosition * 3
        local maxDistanceSq = 30 * 30 
        
        for bed, billboard in pairs(Reference) do
            if bed.Parent then
                local offset = blockPos - bed.Position
                local distanceSq = offset.X * offset.X + offset.Y * offset.Y + offset.Z * offset.Z
                
                if distanceSq <= maxDistanceSq then
                    refreshAdornee(billboard)
                end
            end
        end
    end
    
    BedPlates = vape.Categories.Minigames:CreateModule({
        Name = 'BedPlates',
        Function = function(callback)
            if callback then
                table.clear(BlockCache)
                
                local tagged = collectionService:GetTagged('bed')
                for _, v in ipairs(tagged) do 
                    Added(v)
                end
                
                BedPlates:Clean(vapeEvents.PlaceBlockEvent.Event:Connect(refreshNear))
                BedPlates:Clean(vapeEvents.BreakBlockEvent.Event:Connect(refreshNear))
                BedPlates:Clean(collectionService:GetInstanceAddedSignal('bed'):Connect(Added))
                BedPlates:Clean(collectionService:GetInstanceRemovedSignal('bed'):Connect(function(v)
                    if Reference[v] then
                        Reference[v]:Destroy()
                        Reference[v] = nil
                        BlockCache[v] = nil
                    end
                end))
            else
                for _, v in pairs(Reference) do
                    v:Destroy()
                end
                table.clear(Reference)
                table.clear(BlockCache)
            end
        end,
        Tooltip = 'Displays blocks over the bed'
    })
    
    Background = BedPlates:CreateToggle({
        Name = 'Background',
        Function = function(callback)
            if Color.Object then 
                Color.Object.Visible = callback and not TeamColor.Enabled
            end
            for _, v in pairs(Reference) do
                v.Frame.BackgroundTransparency = 1 - (callback and (TeamColor.Enabled and 0.5 or Color.Opacity) or 0)
                local blur = v:FindFirstChild('Blur')
                if blur then
                    blur.Visible = callback
                end
            end
        end,
        Default = true
    })
    
    TeamColor = BedPlates:CreateToggle({
        Name = 'Team Color',
        Tooltip = 'Use bed team color instead of custom color',
        Default = true,
        Function = function(callback)
            if Color.Object then
                Color.Object.Visible = Background.Enabled and not callback
            end
            for bed, billboard in pairs(Reference) do
                billboard.Frame.BackgroundColor3 = callback and getBedTeamColor(bed) or Color3.fromHSV(Color.Hue, Color.Sat, Color.Value)
                billboard.Frame.BackgroundTransparency = 1 - (Background.Enabled and (callback and 0.5 or Color.Opacity) or 0)
            end
        end
    })
    
    Color = BedPlates:CreateColorSlider({
        Name = 'Background Color',
        DefaultValue = 0,
        DefaultOpacity = 0.5,
        Function = function(hue, sat, val, opacity)
            for bed, v in pairs(Reference) do
                if not TeamColor.Enabled then
                    v.Frame.BackgroundColor3 = Color3.fromHSV(hue, sat, val)
                end
                if Background.Enabled and not TeamColor.Enabled then
                    v.Frame.BackgroundTransparency = 1 - opacity
                end
            end
        end,
        Visible = false,
        Darker = true
    })
end)

run(function()
	local char = lplr.Character or lplr.CharacterAdded:wait()
	local Headless = {Enabled = false}
	local faceTransparencyBackup = nil
	
	Headless = vape.Categories.Utility:CreateModule({
		PerformanceModeBlacklisted = true,
		Name = 'Headless',
		Tooltip = 'free headless 2026',
		Function = function(callback)
			if callback then
				task.spawn(function()
					repeat 
						task.wait()
						if entitylib.isAlive and entitylib.character.Character and entitylib.character.Head then
							entitylib.character.Head.Transparency = 1
							
							local face = entitylib.character.Head:FindFirstChild('face')
							if face and face:IsA("Decal") and faceTransparencyBackup == nil then
								faceTransparencyBackup = face.Transparency
								face.Transparency = 1
							end
						end
					until not Headless.Enabled
				end)
			else
				if entitylib.isAlive and entitylib.character.Character and entitylib.character.Head then
					entitylib.character.Head.Transparency = 0
					
					local face = entitylib.character.Head:FindFirstChild('face')
					if face and face:IsA("Decal") and faceTransparencyBackup ~= nil then
						face.Transparency = faceTransparencyBackup
						faceTransparencyBackup = nil
					end
				end
			end
		end,
		Default = false
	})
end)

local function safeIsBreakable(pos)
    if not bedwars.BlockController then return false end
    local ok, result = pcall(function()
        return bedwars.BlockController:isBlockBreakable({blockPosition = pos / 3}, lplr)
    end)
    return ok and result
end
	
run(function()
	local Breaker
	local Delay
	local Range
	local UpdateRate
	local TargetList
	local TargetBlocks
	local Bed
	local LuckyBlock
	local AutoTool
	local Effect
	local CustomHealth = {}
	local Animation
	local SelfBreak
	local LimitItem
	local BreakClosestBlock
	local PathToBed
	local MouseDown
	local parts = {}
	local lastPlayerPosition = nil
	local currentTargetBlock = nil
	local cachedTargetBlocks = {}
	local lastCacheUpdate = 0
	local CACHE_INTERVAL = 0.5
	
	local tempSortTable = {}
	local vectorToNormalId = {
		[Vector3.new(1, 0, 0)] = Enum.NormalId.Right,
		[Vector3.new(-1, 0, 0)] = Enum.NormalId.Left,
		[Vector3.new(0, 1, 0)] = Enum.NormalId.Top,
		[Vector3.new(0, -1, 0)] = Enum.NormalId.Bottom,
		[Vector3.new(0, 0, 1)] = Enum.NormalId.Front,
		[Vector3.new(0, 0, -1)] = Enum.NormalId.Back
	}

	local function isSameTeam(userId)
		if not userId then return false end
		local localTeam = lplr.Team
		if not localTeam then return false end
		for _, player in game:GetService("Players"):GetPlayers() do
			if player.UserId == userId and player.Team == localTeam then
				return true
			end
		end
		return false
	end

	local function getSwordSlot()
		for i, v in store.inventory.hotbar do
			if v.item and bedwars.ItemMeta[v.item.itemType] then
				local meta = bedwars.ItemMeta[v.item.itemType]
				if meta.sword then
					return i - 1
				end
			end
		end
		return nil
	end

	local function getPickaxeSlot()
		for i, v in store.inventory.hotbar do
			if v.item and bedwars.ItemMeta[v.item.itemType] then
				local meta = bedwars.ItemMeta[v.item.itemType]
				if meta.breakBlock then
					return i - 1
				end
			end
		end
		return nil
	end

	local function customHealthbar(self, blockRef, health, maxHealth, changeHealth, block)
		if block:GetAttribute('NoHealthbar') then return end
		if not self.healthbarPart or not self.healthbarBlockRef or self.healthbarBlockRef.blockPosition ~= blockRef.blockPosition then
			self.healthbarMaid:DoCleaning()
			self.healthbarBlockRef = blockRef
			local create = bedwars.Roact.createElement
			local percent = math.clamp(health / maxHealth, 0, 1)
			local cleanCheck = true
			local part = Instance.new('Part')
			part.Size = Vector3.one
			part.CFrame = CFrame.new(bedwars.BlockController:getWorldPosition(blockRef.blockPosition))
			part.Transparency = 1
			part.Anchored = true
			part.CanCollide = false
			part.Parent = workspace
			self.healthbarPart = part
			bedwars.QueryUtil:setQueryIgnored(self.healthbarPart, true)
	
			local mounted = bedwars.Roact.mount(create('BillboardGui', {
				Size = UDim2.fromOffset(249, 102),
				StudsOffset = Vector3.new(0, 2.5, 0),
				Adornee = part,
				MaxDistance = 40,
				AlwaysOnTop = true
			}, {
				create('Frame', {
					Size = UDim2.fromOffset(160, 50),
					Position = UDim2.fromOffset(44, 32),
					BackgroundColor3 = Color3.new(),
					BackgroundTransparency = 0.5
				}, {
					create('UICorner', {CornerRadius = UDim.new(0, 5)}),
					create('ImageLabel', {
						Size = UDim2.new(1, 89, 1, 52),
						Position = UDim2.fromOffset(-48, -31),
						BackgroundTransparency = 1,
						Image = getcustomasset('newvape/assets/new/blur.png'),
						ScaleType = Enum.ScaleType.Slice,
						SliceCenter = Rect.new(52, 31, 261, 502)
					}),
					create('TextLabel', {
						Size = UDim2.fromOffset(145, 14),
						Position = UDim2.fromOffset(13, 12),
						BackgroundTransparency = 1,
						Text = bedwars.ItemMeta[block.Name].displayName or block.Name,
						TextXAlignment = Enum.TextXAlignment.Left,
						TextYAlignment = Enum.TextYAlignment.Top,
						TextColor3 = Color3.new(),
						TextScaled = true,
						Font = Enum.Font.Arial
					}),
					create('TextLabel', {
						Size = UDim2.fromOffset(145, 14),
						Position = UDim2.fromOffset(12, 11),
						BackgroundTransparency = 1,
						Text = bedwars.ItemMeta[block.Name].displayName or block.Name,
						TextXAlignment = Enum.TextXAlignment.Left,
						TextYAlignment = Enum.TextYAlignment.Top,
						TextColor3 = color.Dark(uipallet.Text, 0.16),
						TextScaled = true,
						Font = Enum.Font.Arial
					}),
					create('Frame', {
						Size = UDim2.fromOffset(138, 4),
						Position = UDim2.fromOffset(12, 32),
						BackgroundColor3 = uipallet.Main
					}, {
						create('UICorner', {CornerRadius = UDim.new(1, 0)}),
						create('Frame', {
							[bedwars.Roact.Ref] = self.healthbarProgressRef,
							Size = UDim2.fromScale(percent, 1),
							BackgroundColor3 = Color3.fromHSV(math.clamp(percent / 2.5, 0, 1), 0.89, 0.75)
						}, {create('UICorner', {CornerRadius = UDim.new(1, 0)})})
					})
				})
			}), part)
	
			self.healthbarMaid:GiveTask(function()
				cleanCheck = false
				self.healthbarBlockRef = nil
				bedwars.Roact.unmount(mounted)
				if self.healthbarPart then
					self.healthbarPart:Destroy()
				end
				self.healthbarPart = nil
			end)
	
			bedwars.RuntimeLib.Promise.delay(5):andThen(function()
				if cleanCheck then
					self.healthbarMaid:DoCleaning()
				end
			end)
		end
	
		local newpercent = math.clamp((health - changeHealth) / maxHealth, 0, 1)
		tweenService:Create(self.healthbarProgressRef:getValue(), TweenInfo.new(0.3), {
			Size = UDim2.fromScale(newpercent, 1), BackgroundColor3 = Color3.fromHSV(math.clamp(newpercent / 2.5, 0, 1), 0.89, 0.75)
		}):Play()
	end
	
	local hit = 0
	
	local sides = {}
	for _, v in Enum.NormalId:GetEnumItems() do
		if v.Name == "Bottom" then continue end
		table.insert(sides, Vector3.FromNormalId(v) * 3)
	end

	local function hasDirectPathToBed(bedPos, playerPos)
		local direction = (bedPos - playerPos).Unit
		local distanceSq = (bedPos - playerPos).Magnitude
		local distance = distanceSq
		
		local stepSize = math.max(3, Range.Value / 10)
		
		for i = stepSize, distance, stepSize do
			local checkPos = playerPos + (direction * i)
			
			if (checkPos - bedPos).Magnitude <= 3 then
				continue
			end
			
			local block = getPlacedBlock(checkPos)
			
			if block then
				if bedwars.BlockController:isBlockBreakable({blockPosition = checkPos / 3}, lplr) then
					return false, checkPos 
				end
			end
		end
		
		return true, nil
	end

	local function findClosestBlockInPath(bedPos, playerPos)
		local closestBlock = nil
		local closestDistanceSq = math.huge
		local closestPos = nil
		local closestNormal = nil
		local maxRange = Range.Value

		local maxIterations = math.min(15, math.ceil(maxRange / 3))

		for _, side in sides do
			for i = 1, maxIterations do
				local blockPos = bedPos + (side * i)
				
				local distSq = (playerPos - blockPos).Magnitude
				if distSq > maxRange then 
					break 
				end
				
				local block = getPlacedBlock(blockPos)
				if not block or block:GetAttribute("NoBreak") then break end
				
				if bedwars.BlockController:isBlockBreakable({blockPosition = blockPos / 3}, lplr) then
					local distToPlayerSq = (playerPos - blockPos).Magnitude
					
					if distToPlayerSq < closestDistanceSq then
						closestDistanceSq = distToPlayerSq
						closestBlock = block
						closestPos = blockPos
						local normalizedSide = side.Unit 
						for vector, normalId in pairs(vectorToNormalId) do
							if (normalizedSide - vector).Magnitude < 0.01 then 
								closestNormal = normalId
								break
							end
						end
					end
				end
			end
		end

		return closestBlock, closestPos, closestNormal
	end

	local function hasPlayerMoved(currentPos, threshold)
		if not lastPlayerPosition then
			lastPlayerPosition = currentPos
			return true
		end
		
		local thresholdSq = (threshold or 2) ^ 2
		local distSq = (currentPos - lastPlayerPosition).Magnitude
		local moved = distSq > thresholdSq
		
		if moved then
			lastPlayerPosition = currentPos
		end
		return moved
	end

	local function doBreak(block)
		hit += 1
		local success, result = pcall(function()
			return bedwars.breakBlock(block, Effect.Enabled, Animation.Enabled, CustomHealth.Enabled and customHealthbar or nil, AutoTool.Enabled)
		end)
		if success then
			local target, path, endpos = result, nil, nil
			if type(result) == "table" then
				target, path, endpos = unpack(result)
			end
			if path then
				local currentnode = target
				for _, part in parts do
					part.Position = currentnode or Vector3.zero
					if currentnode then
						part.BoxHandleAdornment.Color3 = currentnode == endpos and Color3.new(1, 0.2, 0.2) or currentnode == target and Color3.new(0.2, 0.2, 1) or Color3.new(0.2, 1, 0.2)
					end
					currentnode = path[currentnode]
				end
			end
		else
			warn("failed to break block:", result)
		end
		task.wait(Delay.Value)
		return true
	end
	
	local function passesChecks(v)
		local placedBy = v:GetAttribute('PlacedByUserId')
		if not SelfBreak.Enabled then
			if placedBy == lplr.UserId then return false end
			if isSameTeam(placedBy) then return false end
		end
		if (v:GetAttribute('BedShieldEndTime') or 0) > workspace:GetServerTimeNow() then return false end
		if LimitItem.Enabled and not (store.hand.tool and bedwars.ItemMeta[store.hand.tool.Name].breakBlock) then return false end
		return true
	end

	local function updateTargetBlockCache(localPosition)
		local currentTime = tick()
		
		if currentTime - lastCacheUpdate < CACHE_INTERVAL then
			return
		end
		
		lastCacheUpdate = currentTime
		table.clear(cachedTargetBlocks)
		
		if not TargetBlocks.Enabled then return end
		if not TargetList.ListEnabled or #TargetList.ListEnabled == 0 then return end
		
		local rangeSq = Range.Value ^ 2
		
		for _, obj in store.blocks do
			if obj and obj:IsA("BasePart") and table.find(TargetList.ListEnabled, obj.Name) then
				local distSq = (obj.Position - localPosition).Magnitude
				if distSq <= rangeSq then
					table.insert(cachedTargetBlocks, obj)
				end
			end
		end
	end

	local function attemptBreakTargets(localPosition)
		if not TargetBlocks.Enabled then return false end
		if not TargetList.ListEnabled or #TargetList.ListEnabled == 0 then return false end
		if MouseDown.Enabled and not inputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then return false end

		updateTargetBlockCache(localPosition)
		
		if #cachedTargetBlocks == 0 then return false end

		table.clear(tempSortTable)
		for _, v in cachedTargetBlocks do
			table.insert(tempSortTable, v)
		end

		table.sort(tempSortTable, function(a, b)
			return (a.Position - localPosition).Magnitude < (b.Position - localPosition).Magnitude
		end)

		for _, v in tempSortTable do
			if v.Name == 'iron_ore_mesh_block' then
				return doBreak(v)
			end
			if not bedwars.BlockController:isBlockBreakable({blockPosition = v.Position / 3}, lplr) then continue end
			if not passesChecks(v) then continue end
			return doBreak(v)
		end

		return false
	end

	local function attemptBreak(tab, localPosition, isBed)
		if not tab then return false end
		if MouseDown.Enabled and not inputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
			return false
		end
		
		table.clear(tempSortTable)
		local rangeSq = Range.Value ^ 2
		
		for _, v in tab do
			local distSq = (v.Position - localPosition).Magnitude
			if distSq <= rangeSq then
				table.insert(tempSortTable, v)
			end
		end
		
		if #tempSortTable == 0 then return false end
		
		table.sort(tempSortTable, function(a, b)
			return (a.Position - localPosition).Magnitude < (b.Position - localPosition).Magnitude
		end)
		
		for _, v in tempSortTable do
			if bedwars.BlockController:isBlockBreakable({blockPosition = v.Position / 3}, lplr) then
				if not passesChecks(v) then continue end
				if SelfBreak.Enabled and v:GetAttribute('PlacedByUserId') == lplr.UserId then
					if v:GetAttribute('NoBreak') or v.Name == 'bed' or v.Name == 'team_chest' then
						continue
					end
				end

				if isBed and (BreakClosestBlock.Enabled or PathToBed.Enabled) then
					hit += 1
					
					local hasPath, blockingPos = hasDirectPathToBed(v.Position, localPosition)
					
					if hasPath then
						if PathToBed.Enabled then
							return false
						end
						return doBreak(v)
					else
						local playerMoved = hasPlayerMoved(localPosition, 2)
						local targetChanged = currentTargetBlock ~= v
						
						if playerMoved or targetChanged or not currentTargetBlock then
							currentTargetBlock = v
						end
						
						local closestBlock, closestPos, closestNormal = findClosestBlockInPath(v.Position, localPosition)
						
						if closestBlock and closestPos then
							return doBreak(closestBlock)
						end
					end
				else
					return doBreak(v)
				end
			end
		end

		return false
	end
	
	Breaker = vape.Categories.Minigames:CreateModule({
		Name = 'Breaker',
		Function = function(callback)
			if callback then
				if #parts == 0 then
					for _ = 1, 30 do
						local part = Instance.new('Part')
						part.Anchored = true
						part.CanQuery = false
						part.CanCollide = false
						part.Transparency = 1
						part.Parent = gameCamera
						local highlight = Instance.new('BoxHandleAdornment')
						highlight.Size = Vector3.one
						highlight.AlwaysOnTop = true
						highlight.ZIndex = 1
						highlight.Transparency = 0.5
						highlight.Adornee = part
						highlight.Parent = part
						table.insert(parts, part)
					end
				end
	
				local beds = collection('bed', Breaker)
				local luckyblock = collection('LuckyBlock', Breaker)

				repeat
					task.wait(1 / UpdateRate.Value)
					if not Breaker.Enabled then break end
					
					if entitylib.isAlive then
						local localPosition = entitylib.character.RootPart.Position

						if attemptBreak(Bed.Enabled and beds, localPosition, true) then continue end
						if attemptBreakTargets(localPosition) then continue end
						if attemptBreak(LuckyBlock.Enabled and luckyblock, localPosition, false) then continue end

						for _, v in parts do
							v.Position = Vector3.zero
						end
					end
				until not Breaker.Enabled
			else
				for _, v in parts do
					v.Parent = nil
				end
				table.clear(cachedTargetBlocks)
				lastCacheUpdate = 0
				lastPlayerPosition = nil
				currentTargetBlock = nil
			end
		end,
		Tooltip = 'Break blocks around you automatically'
	})
	Range = Breaker:CreateSlider({
		Name = 'Break range',
		Min = 1,
		Max = 30,
		Default = 30,
		Suffix = function(val)
			return val == 1 and 'stud' or 'studs'
		end
	})
	Delay = Breaker:CreateSlider({
		Name = 'Break Delay',
		Min = 0,
		Max = 0.3,
		Default = 0.25,
		Decimal = 100,
		Suffix = "s" 
	})
	UpdateRate = Breaker:CreateSlider({
		Name = 'Update rate',
		Min = 1,
		Max = 120,
		Default = 60,
		Suffix = 'hz'
	})
	TargetBlocks = Breaker:CreateToggle({
		Name = 'Target Blocks',
		Default = false,
		Tooltip = 'Enable to break blocks from the Target List. Skips own/teammate blocks unless Self Break is on.',
		Function = function(callback)
			if TargetList and TargetList.Object then
				TargetList.Object.Visible = callback
			end
			lastCacheUpdate = 0
		end
	})

	TargetList = Breaker:CreateTextList({
		Name = 'Target List',
		Tooltip = 'Block names to break (enemies only). Iron ore included by default.',
		Default = {'tesla_trap', 'beehive', 'pinata', 'iron_ore_mesh_block'},
		Function = function() 
			lastCacheUpdate = 0
		end
	})
	Bed = Breaker:CreateToggle({
		Name = 'Break Bed',
		Default = true
	})
	LuckyBlock = Breaker:CreateToggle({
		Name = 'Break Lucky Block',
		Default = true
	})
	Effect = Breaker:CreateToggle({
		Name = 'Show Healthbar & Effects',
		Function = function(callback)
			if CustomHealth.Object then
				CustomHealth.Object.Visible = callback
			end
		end,
		Default = true
	})
	CustomHealth = Breaker:CreateToggle({
		Name = 'Custom Healthbar',
		Default = true,
		Darker = true
	})
	Animation = Breaker:CreateToggle({Name = 'Animation'})
	SelfBreak = Breaker:CreateToggle({
		Name = 'Self Break',
		Tooltip = 'When OFF: never breaks your own or any teammate\'s blocks. When ON: can break your own placed blocks (still skips beds/chests).'
	})
	AutoTool = Breaker:CreateToggle({
		Name = 'Auto Tool',
		Tooltip = 'Automatically switches to the best tool for breaking blocks'
	})
	LimitItem = Breaker:CreateToggle({
		Name = 'Limit to items',
		Tooltip = 'Only breaks when tools are held'
	})
	BreakClosestBlock = Breaker:CreateToggle({
		Name = 'Break Closest Block',
		Tooltip = 'Only breaks blocks if they block the path to bed. Breaks bed directly if path is clear.',
		Default = false,
		Function = function(callback)
			if callback and PathToBed.Enabled then
				PathToBed:Toggle()
			end
		end
	})
	PathToBed = Breaker:CreateToggle({
		Name = 'Path to Bed Only',
		Tooltip = 'Breaks blocks to create path to bed, but does NOT break the bed itself',
		Default = false,
		Function = function(callback)
			if callback and BreakClosestBlock.Enabled then
				BreakClosestBlock:Toggle()
			end
		end
	})
	MouseDown = Breaker:CreateToggle({
		Name = 'Require Mouse Down',
		Tooltip = 'Only breaks blocks when holding left click'
	})
	
	if TargetList and TargetList.Object then
		TargetList.Object.Visible = TargetBlocks.Enabled
	end
end)
	
run(function()
	local BedBreakEffect
	local Mode
	local List
	local NameToId = {}
	
	BedBreakEffect = vape.Categories.Legit:CreateModule({
		Name = 'Bed Break Effect',
		Function = function(callback)
			if callback then
	            BedBreakEffect:Clean(vapeEvents.BedwarsBedBreak.Event:Connect(function(data)
	                firesignal(bedwars.Client:Get('BedBreakEffectTriggered').instance.OnClientEvent, {
	                    player = data.player,
	                    position = data.bedBlockPosition * 3,
	                    effectType = NameToId[List.Value],
	                    teamId = data.brokenBedTeam.id,
	                    centerBedPosition = data.bedBlockPosition * 3
	                })
	            end))
	        end
		end,
		Tooltip = 'Custom bed break effects'
	})
	local BreakEffectName = {}
	for i, v in bedwars.BedBreakEffectMeta do
		table.insert(BreakEffectName, v.name)
		NameToId[v.name] = i
	end
	table.sort(BreakEffectName)
	List = BedBreakEffect:CreateDropdown({
		Name = 'Effect',
		List = BreakEffectName
	})
end)
	
run(function()
	vape.Categories.BoostFPS:CreateModule({
		Name = 'Clean Kit',
		Function = function(callback)
			if callback then
				bedwars.WindWalkerController.spawnOrb = function() end
				local zephyreffect = lplr.PlayerGui:FindFirstChild('WindWalkerEffect', true)
				if zephyreffect then 
					zephyreffect.Visible = false 
				end
			end
		end,
		Tooltip = 'Removes zephyr status indicator'
	})
end)
	
run(function()
	local old
	local Image
	
	local Crosshair = vape.Categories.Legit:CreateModule({
		Name = 'Crosshair',
		Function = function(callback)
			if callback then
				if not Image.Value or Image.Value == "" then
					notif('crosshair', 'please enter a valid image ID before enabling gng', 2)
					Crosshair:Toggle() 
					return
				end
				
				local imageId = Image.Value
				if not imageId:find("rbxassetid://") then
					imageId = "rbxassetid://" .. imageId
				end
				
				old = debug.getconstant(bedwars.ViewmodelController.showCrosshair, 25)
				debug.setconstant(bedwars.ViewmodelController.showCrosshair, 25, imageId)
				debug.setconstant(bedwars.ViewmodelController.showCrosshair, 37, imageId)
			else
				if old then
					debug.setconstant(bedwars.ViewmodelController.showCrosshair, 25, old)
					debug.setconstant(bedwars.ViewmodelController.showCrosshair, 37, old)
					old = nil
				end
			end
	
			if bedwars.ViewmodelController.crosshair then
				bedwars.ViewmodelController:hideCrosshair()
				bedwars.ViewmodelController:showCrosshair()
			end
		end,
		Tooltip = 'Custom first person crosshair depending on the image chosen.'
	})
	
	Image = Crosshair:CreateTextBox({
		Name = 'Image',
		Placeholder = 'image id (roblox)',
		Function = function(enter)
			if enter and Crosshair.Enabled then
				Crosshair:Toggle()
				Crosshair:Toggle()
			end
		end
	})
end)
	
run(function()
	local DamageIndicator
	local FontOption
	local Color
	local Size
	local Anchor
	local Stroke
	local suc, tab = pcall(function()
		return debug.getupvalue(bedwars.DamageIndicator, 2)
	end)
	tab = suc and tab or {}
	local oldvalues, oldfont = {}
	
	DamageIndicator = vape.Categories.Legit:CreateModule({
		Name = 'Damage Indicator',
		Function = function(callback)
			if callback then
				oldvalues = table.clone(tab)
				oldfont = debug.getconstant(bedwars.DamageIndicator, 86)
				debug.setconstant(bedwars.DamageIndicator, 86, Enum.Font[FontOption.Value])
				debug.setconstant(bedwars.DamageIndicator, 119, Stroke.Enabled and 'Thickness' or 'Enabled')
				tab.strokeThickness = Stroke.Enabled and 1 or false
				tab.textSize = Size.Value
				tab.blowUpSize = Size.Value
				tab.blowUpDuration = 0
				tab.baseColor = Color3.fromHSV(Color.Hue, Color.Sat, Color.Value)
				tab.blowUpCompleteDuration = 0
				tab.anchoredDuration = Anchor.Value
			else
				for i, v in oldvalues do
					tab[i] = v
				end
				debug.setconstant(bedwars.DamageIndicator, 86, oldfont)
				debug.setconstant(bedwars.DamageIndicator, 119, 'Thickness')
			end
		end,
		Tooltip = 'Customize the damage indicator'
	})
	local fontitems = {'GothamBlack'}
	for _, v in Enum.Font:GetEnumItems() do
		if v.Name ~= 'GothamBlack' then
			table.insert(fontitems, v.Name)
		end
	end
	FontOption = DamageIndicator:CreateDropdown({
		Name = 'Font',
		List = fontitems,
		Function = function(val)
			if DamageIndicator.Enabled then
				debug.setconstant(bedwars.DamageIndicator, 86, Enum.Font[val])
			end
		end
	})
	Color = DamageIndicator:CreateColorSlider({
		Name = 'Color',
		DefaultHue = 0,
		Function = function(hue, sat, val)
			if DamageIndicator.Enabled then
				tab.baseColor = Color3.fromHSV(hue, sat, val)
			end
		end
	})
	Size = DamageIndicator:CreateSlider({
		Name = 'Size',
		Min = 1,
		Max = 32,
		Default = 32,
		Function = function(val)
			if DamageIndicator.Enabled then
				tab.textSize = val
				tab.blowUpSize = val
			end
		end
	})
	Anchor = DamageIndicator:CreateSlider({
		Name = 'Anchor',
		Min = 0,
		Max = 1,
		Decimal = 10,
		Function = function(val)
			if DamageIndicator.Enabled then
				tab.anchoredDuration = val
			end
		end
	})
	Stroke = DamageIndicator:CreateToggle({
		Name = 'Stroke',
		Function = function(callback)
			if DamageIndicator.Enabled then
				debug.setconstant(bedwars.DamageIndicator, 119, callback and 'Thickness' or 'Enabled')
				tab.strokeThickness = callback and 1 or false
			end
		end
	})
end)
	
run(function()
	local FOV
	local Value
	local old, old2
	
	FOV = vape.Categories.Legit:CreateModule({
		Name = 'FOV',
		Function = function(callback)
			if callback then
				old = bedwars.FovController.setFOV
				old2 = bedwars.FovController.getFOV
				bedwars.FovController.setFOV = function(self) 
					return old(self, Value.Value) 
				end
				bedwars.FovController.getFOV = function() 
					return Value.Value 
				end
			else
				bedwars.FovController.setFOV = old
				bedwars.FovController.getFOV = old2
			end
			
			bedwars.FovController:setFOV(bedwars.Store:getState().Settings.fov)
		end,
		Tooltip = 'Adjusts camera vision'
	})
	Value = FOV:CreateSlider({
		Name = 'FOV',
		Min = 30,
		Max = 120
	})
end)
	
run(function()
	local FPSBoost
	local Kill
	local Visualizer
	local effects, util = {}, {}
	local originalAddGameNametag
	local nametagHooked = false
	
	FPSBoost = vape.Categories.BoostFPS:CreateModule({
		Name = 'FPS Boost',
		Function = function(callback)
			if callback then
				if Kill.Enabled then
					for i, v in bedwars.KillEffectController.killEffects do
						if not i:find('Custom') then
							effects[i] = v
							bedwars.KillEffectController.killEffects[i] = {
								new = function() 
									return {
										onKill = function() end, 
										isPlayDefaultKillEffect = function() 
											return true 
										end
									} 
								end
							}
						end
					end
				end

				if Visualizer.Enabled then
					for i, v in bedwars.VisualizerUtils do
						util[i] = v
						bedwars.VisualizerUtils[i] = function() end
					end
				end

				-- REMOVED NAMETAG 
				--[[
				if not nametagHooked then
					originalAddGameNametag = bedwars.NametagController.addGameNametag
					bedwars.NametagController.addGameNametag = function(player, ...)
						if player == lplr then
							return originalAddGameNametag(player, ...)
						end
						return
					end
					nametagHooked = true
				end
				
				if bedwars.AppController then
					for _, v in bedwars.AppController:getOpenApps() do
						if v and v.app then
							local appName = tostring(v.app)
							if appName:find('Nametag') or (v.getDisplayName and tostring(v.getDisplayName()):find('Nametag')) then
								local isLocalPlayer = false
								
								if v.player and v.player == lplr then
									isLocalPlayer = true
								elseif appName:find(lplr.Name) or appName:find('LocalPlayer') then
									isLocalPlayer = true
								elseif v.getPlayer and v.getPlayer() == lplr then
									isLocalPlayer = true
								end
								
								if not isLocalPlayer then
									bedwars.AppController:closeApp(v)
								end
							end
						end
					end
				end
				]]--
			else
				for i, v in effects do 
					bedwars.KillEffectController.killEffects[i] = v 
				end
				
				for i, v in util do 
					bedwars.VisualizerUtils[i] = v 
				end
				
				if nametagHooked and originalAddGameNametag then
					bedwars.NametagController.addGameNametag = originalAddGameNametag
					nametagHooked = false
				end
				
				table.clear(effects)
				table.clear(util)
			end
		end,
		Tooltip = 'Improves the framerate by turning off certain effects'
	})
	
	Kill = FPSBoost:CreateToggle({
		Name = 'Kill Effects',
		Function = function()
			if FPSBoost.Enabled then
				FPSBoost:Toggle()
				FPSBoost:Toggle()
			end
		end,
		Default = true
	})
	
	Visualizer = FPSBoost:CreateToggle({
		Name = 'Visualizer',
		Function = function()
			if FPSBoost.Enabled then
				FPSBoost:Toggle()
				FPSBoost:Toggle()
			end
		end,
		Default = true
	})
end)
	
run(function()
	local HitColor
	local Color
	local done = {}
	
	HitColor = vape.Categories.Legit:CreateModule({
		Name = 'Hit Color',
		Function = function(callback)
			if callback then 
				repeat
					for i, v in entitylib.List do 
						local highlight = v.Character and v.Character:FindFirstChild('_DamageHighlight_')
						if highlight then 
							if not table.find(done, highlight) then 
								table.insert(done, highlight) 
							end
							highlight.FillColor = Color3.fromHSV(Color.Hue, Color.Sat, Color.Value)
							highlight.FillTransparency = Color.Opacity
						end
					end
					task.wait(0.1)
				until not HitColor.Enabled
			else
				for i, v in done do 
					v.FillColor = Color3.new(1, 0, 0)
					v.FillTransparency = 0.4
				end
				table.clear(done)
			end
		end,
		Tooltip = 'Customize the hit highlight options'
	})
	Color = HitColor:CreateColorSlider({
		Name = 'Color',
		DefaultOpacity = 0.4
	})
end)

run(function()
    HitFix = vape.Categories.Legit:CreateModule({
        Name = 'HitFix',
		Function = function(callback)
			debug.setconstant(bedwars.SwordController.swingSwordAtMouse, 23, callback and 'raycast' or 'Raycast')
			debug.setupvalue(bedwars.SwordController.swingSwordAtMouse, 4, callback and bedwars.QueryUtil or workspace)
		end,
		Tooltip = 'Changes the raycast function to the correct one'
	})
end)

run(function()
	local Interface
	local HotbarOpenInventory = require(lplr.PlayerScripts.TS.controllers.global.hotbar.ui['hotbar-open-inventory']).HotbarOpenInventory
	local HotbarHealthbar = require(lplr.PlayerScripts.TS.controllers.global.hotbar.ui.healthbar['hotbar-healthbar']).HotbarHealthbar
	local HotbarApp = getRoactRender(require(lplr.PlayerScripts.TS.controllers.global.hotbar.ui['hotbar-app']).HotbarApp.render)
	local old, new = {}, {}
	
	vape:Clean(function()
		for _, v in new do
			table.clear(v)
		end
		for _, v in old do
			table.clear(v)
		end
		table.clear(new)
		table.clear(old)
	end)
	
	local function modifyconstant(func, ind, val)
		if not func then return end
		if not old[func] then old[func] = {} end
		if not new[func] then new[func] = {} end
		if not old[func][ind] then
			old[func][ind] = debug.getconstant(func, ind)
		end
		if typeof(old[func][ind]) ~= typeof(val) then return end
		new[func][ind] = val
	
		if Interface.Enabled then
			if val then
				debug.setconstant(func, ind, val)
			else
				debug.setconstant(func, ind, old[func][ind])
				old[func][ind] = nil
			end
		end
	end
	
	Interface = vape.Categories.Legit:CreateModule({
		Name = 'Interface',
		Function = function(callback)
			for i, v in (callback and new or old) do
				for i2, v2 in v do
					debug.setconstant(i, i2, v2)
				end
			end
		end,
		Tooltip = 'Customize bedwars UI'
	})
	local fontitems = {'LuckiestGuy'}
	for _, v in Enum.Font:GetEnumItems() do
		if v.Name ~= 'LuckiestGuy' then
			table.insert(fontitems, v.Name)
		end
	end
	Interface:CreateDropdown({
		Name = 'Health Font',
		List = fontitems,
		Function = function(val)
			modifyconstant(HotbarHealthbar.render, 77, val)
		end
	})
	Interface:CreateColorSlider({
		Name = 'Health Color',
		Function = function(hue, sat, val)
			modifyconstant(HotbarHealthbar.render, 16, tonumber(Color3.fromHSV(hue, sat, val):ToHex(), 16))
			if Interface.Enabled then
				local hotbar = lplr.PlayerGui:FindFirstChild('hotbar')
				hotbar = hotbar and hotbar:FindFirstChild('HealthbarProgressWrapper', true)
				if hotbar then
					hotbar['1'].BackgroundColor3 = Color3.fromHSV(hue, sat, val)
				end
			end
		end
	})
	Interface:CreateColorSlider({
		Name = 'Hotbar Color',
		DefaultOpacity = 0.8,
		Function = function(hue, sat, val, opacity)
			local func = oldinvrender or HotbarOpenInventory.render
			modifyconstant(debug.getupvalue(HotbarApp, 23).render, 51, tonumber(Color3.fromHSV(hue, sat, val):ToHex(), 16))
			modifyconstant(debug.getupvalue(HotbarApp, 23).render, 58, tonumber(Color3.fromHSV(hue, sat, math.clamp(val > 0.5 and val - 0.2 or val + 0.2, 0, 1)):ToHex(), 16))
			modifyconstant(debug.getupvalue(HotbarApp, 23).render, 54, 1 - opacity)
			modifyconstant(debug.getupvalue(HotbarApp, 23).render, 55, math.clamp(1.2 - opacity, 0, 1))
			modifyconstant(func, 31, tonumber(Color3.fromHSV(hue, sat, val):ToHex(), 16))
			modifyconstant(func, 32, math.clamp(1.2 - opacity, 0, 1))
			modifyconstant(func, 34, tonumber(Color3.fromHSV(hue, sat, math.clamp(val > 0.5 and val - 0.2 or val + 0.2, 0, 1)):ToHex(), 16))
		end
	})
end)
	
run(function()
	local KillEffect
	local Mode
	local List
	local NameToId = {}
	
	local killeffects = {
		Gravity = function(_, _, char, _)
			char:BreakJoints()
			local highlight = char:FindFirstChildWhichIsA('Highlight')
			local nametag = char:FindFirstChild('Nametag', true)
			if highlight then
				highlight:Destroy()
			end
			if nametag then
				nametag:Destroy()
			end
	
			task.spawn(function()
				local partvelo = {}
				for _, v in char:GetDescendants() do
					if v:IsA('BasePart') then
						partvelo[v.Name] = v.Velocity
					end
				end
				char.Archivable = true
				local clone = char:Clone()
				clone.Humanoid.Health = 100
				clone.Parent = workspace
				game:GetService('Debris'):AddItem(clone, 30)
				char:Destroy()
				task.wait(0.01)
				clone.Humanoid:ChangeState(Enum.HumanoidStateType.Dead)
				clone:BreakJoints()
				task.wait(0.01)
				for _, v in clone:GetDescendants() do
					if v:IsA('BasePart') then
						local bodyforce = Instance.new('BodyForce')
						bodyforce.Force = Vector3.new(0, (workspace.Gravity - 10) * v:GetMass(), 0)
						bodyforce.Parent = v
						v.CanCollide = true
						v.Velocity = partvelo[v.Name] or Vector3.zero
					end
				end
			end)
		end,
		Lightning = function(_, _, char, _)
			char:BreakJoints()
			local highlight = char:FindFirstChildWhichIsA('Highlight')
			if highlight then
				highlight:Destroy()
			end
			local startpos = 1125
			local startcf = char.PrimaryPart.CFrame.p - Vector3.new(0, 8, 0)
			local newpos = Vector3.new((math.random(1, 10) - 5) * 2, startpos, (math.random(1, 10) - 5) * 2)
	
			for i = startpos - 75, 0, -75 do
				local newpos2 = Vector3.new((math.random(1, 10) - 5) * 2, i, (math.random(1, 10) - 5) * 2)
				if i == 0 then
					newpos2 = Vector3.zero
				end
				local part = Instance.new('Part')
				part.Size = Vector3.new(1.5, 1.5, 77)
				part.Material = Enum.Material.SmoothPlastic
				part.Anchored = true
				part.Material = Enum.Material.Neon
				part.CanCollide = false
				part.CFrame = CFrame.new(startcf + newpos + ((newpos2 - newpos) * 0.5), startcf + newpos2)
				part.Parent = workspace
				local part2 = part:Clone()
				part2.Size = Vector3.new(3, 3, 78)
				part2.Color = Color3.new(0.7, 0.7, 0.7)
				part2.Transparency = 0.7
				part2.Material = Enum.Material.SmoothPlastic
				part2.Parent = workspace
				game:GetService('Debris'):AddItem(part, 0.5)
				game:GetService('Debris'):AddItem(part2, 0.5)
				bedwars.QueryUtil:setQueryIgnored(part, true)
				bedwars.QueryUtil:setQueryIgnored(part2, true)
				if i == 0 then
					local soundpart = Instance.new('Part')
					soundpart.Transparency = 1
					soundpart.Anchored = true
					soundpart.Size = Vector3.zero
					soundpart.Position = startcf
					soundpart.Parent = workspace
					bedwars.QueryUtil:setQueryIgnored(soundpart, true)
					local sound = Instance.new('Sound')
					sound.SoundId = 'rbxassetid://6993372814'
					sound.Volume = 2
					sound.Pitch = 0.5 + (math.random(1, 3) / 10)
					sound.Parent = soundpart
					sound:Play()
					sound.Ended:Connect(function()
						soundpart:Destroy()
					end)
				end
				newpos = newpos2
			end
		end,
		Delete = function(_, _, char, _)
			char:Destroy()
		end
	}
	
	KillEffect = vape.Categories.Legit:CreateModule({
		Name = 'Kill Effect',
		Function = function(callback)
			if callback then
				for i, v in killeffects do
					bedwars.KillEffectController.killEffects['Custom'..i] = {
						new = function()
							return {
								onKill = v,
								isPlayDefaultKillEffect = function()
									return false
								end
							}
						end
					}
				end
				KillEffect:Clean(lplr:GetAttributeChangedSignal('KillEffectType'):Connect(function()
					lplr:SetAttribute('KillEffectType', Mode.Value == 'Bedwars' and NameToId[List.Value] or 'Custom'..Mode.Value)
				end))
				lplr:SetAttribute('KillEffectType', Mode.Value == 'Bedwars' and NameToId[List.Value] or 'Custom'..Mode.Value)
			else
				for i in killeffects do
					bedwars.KillEffectController.killEffects['Custom'..i] = nil
				end
				lplr:SetAttribute('KillEffectType', 'default')
			end
		end,
		Tooltip = 'Custom final kill effects'
	})
	local modes = {'Bedwars'}
	for i in killeffects do
		table.insert(modes, i)
	end
	Mode = KillEffect:CreateDropdown({
		Name = 'Mode',
		List = modes,
		Function = function(val)
			List.Object.Visible = val == 'Bedwars'
			if KillEffect.Enabled then
				lplr:SetAttribute('KillEffectType', val == 'Bedwars' and NameToId[List.Value] or 'Custom'..val)
			end
		end
	})
	local KillEffectName = {}
	for i, v in bedwars.KillEffectMeta do
		table.insert(KillEffectName, v.name)
		NameToId[v.name] = i
	end
	table.sort(KillEffectName)
	List = KillEffect:CreateDropdown({
		Name = 'Bedwars',
		List = KillEffectName,
		Function = function(val)
			if KillEffect.Enabled then
				lplr:SetAttribute('KillEffectType', NameToId[val])
			end
		end,
		Darker = true
	})
end)
	
run(function()
	local ReachDisplay
	local label
	
	ReachDisplay = vape.Categories.Legit:CreateModule({
		Name = 'Reach Display',
		Function = function(callback)
			if callback then
				repeat
					label.Text = (store.attackReachUpdate > tick() and store.attackReach or '0.00')..' studs'
					task.wait(0.4)
				until not ReachDisplay.Enabled
			end
		end,
		Size = UDim2.fromOffset(100, 41)
	})
	ReachDisplay:CreateFont({
		Name = 'Font',
		Blacklist = 'Gotham',
		Function = function(val)
			label.FontFace = val
		end
	})
	ReachDisplay:CreateColorSlider({
		Name = 'Color',
		DefaultValue = 0,
		DefaultOpacity = 0.5,
		Function = function(hue, sat, val, opacity)
			label.BackgroundColor3 = Color3.fromHSV(hue, sat, val)
			label.BackgroundTransparency = 1 - opacity
		end
	})
	label = Instance.new('TextLabel')
	label.Size = UDim2.fromScale(1, 1)
	label.BackgroundTransparency = 0.5
	label.TextSize = 15
	label.Font = Enum.Font.Gotham
	label.Text = '0.00 studs'
	label.TextColor3 = Color3.new(1, 1, 1)
	label.BackgroundColor3 = Color3.new()
	label.Parent = ReachDisplay.Children
	local corner = Instance.new('UICorner')
	corner.CornerRadius = UDim.new(0, 4)
	corner.Parent = label
end)
	
run(function()
	local SongBeats
	local List
	local FOV
	local FOVValue = {}
	local Volume
	local alreadypicked = {}
	local beattick = tick()
	local oldfov, songobj, songbpm, songtween
	
	local function choosesong()
		local list = List.ListEnabled
		if #alreadypicked >= #list then 
			table.clear(alreadypicked) 
		end
	
		if #list <= 0 then
			notif('SongBeats', 'no songs', 10)
			SongBeats:Toggle()
			return
		end
	
		local chosensong = list[math.random(1, #list)]
		if #list > 1 and table.find(alreadypicked, chosensong) then
			repeat 
				task.wait() 
				chosensong = list[math.random(1, #list)] 
			until not table.find(alreadypicked, chosensong) or not SongBeats.Enabled
		end
		if not SongBeats.Enabled then return end
	
		local split = chosensong:split('/')
		if not isfile(split[1]) then
			notif('SongBeats', 'Missing song ('..split[1]..')', 10)
			SongBeats:Toggle()
			return
		end
	
		songobj.SoundId = assetfunction(split[1])
		repeat task.wait() until songobj.IsLoaded or not SongBeats.Enabled
		if SongBeats.Enabled then
			beattick = tick() + (tonumber(split[3]) or 0)
			songbpm = 60 / (tonumber(split[2]) or 50)
			songobj:Play()
		end
	end
	
	SongBeats = vape.Categories.Legit:CreateModule({
		Name = 'Song Beats',
		Function = function(callback)
			if callback then
				songobj = Instance.new('Sound')
				songobj.Volume = Volume.Value / 100
				songobj.Parent = workspace
				repeat
					if not songobj.Playing then choosesong() end
					if beattick < tick() and SongBeats.Enabled and FOV.Enabled then
						beattick = tick() + songbpm
						oldfov = math.min(bedwars.FovController:getFOV() * (bedwars.SprintController.sprinting and 1.1 or 1), 120)
						gameCamera.FieldOfView = oldfov - FOVValue.Value
						songtween = tweenService:Create(gameCamera, TweenInfo.new(math.min(songbpm, 0.2), Enum.EasingStyle.Linear), {FieldOfView = oldfov})
						songtween:Play()
					end
					task.wait()
				until not SongBeats.Enabled
			else
				if songobj then
					songobj:Destroy()
				end
				if songtween then
					songtween:Cancel()
				end
				if oldfov then
					gameCamera.FieldOfView = oldfov
				end
				table.clear(alreadypicked)
			end
		end,
		Tooltip = 'Built in mp3 player'
	})
	List = SongBeats:CreateTextList({
		Name = 'Songs',
		Placeholder = 'filepath/bpm/start'
	})
	FOV = SongBeats:CreateToggle({
		Name = 'Beat FOV',
		Function = function(callback)
			if FOVValue.Object then
				FOVValue.Object.Visible = callback
			end
			if SongBeats.Enabled then
				SongBeats:Toggle()
				SongBeats:Toggle()
			end
		end,
		Default = true
	})
	FOVValue = SongBeats:CreateSlider({
		Name = 'Adjustment',
		Min = 1,
		Max = 30,
		Default = 5,
		Darker = true
	})
	Volume = SongBeats:CreateSlider({
		Name = 'Volume',
		Function = function(val)
			if songobj then 
				songobj.Volume = val / 100 
			end
		end,
		Min = 1,
		Max = 100,
		Default = 100,
		Suffix = '%'
	})
end)
	
run(function()
	local SoundChanger
	local List
	local soundlist = {}
	local old
	
	SoundChanger = vape.Categories.Legit:CreateModule({
		Name = 'SoundChanger',
		Function = function(callback)
			if callback then
				old = bedwars.SoundManager.playSound
				bedwars.SoundManager.playSound = function(self, id, ...)
					if soundlist[id] then
						id = soundlist[id]
					end
	
					return old(self, id, ...)
				end
			else
				bedwars.SoundManager.playSound = old
				old = nil
			end
		end,
		Tooltip = 'Change ingame sounds to custom ones.'
	})
	List = SoundChanger:CreateTextList({
		Name = 'Sounds',
		Placeholder = '(DAMAGE_1/ben.mp3)',
		Function = function()
			table.clear(soundlist)
			for _, entry in List.ListEnabled do
				local split = entry:split('/')
				local id = bedwars.SoundList[split[1]]
				if id and #split > 1 then
					soundlist[id] = split[2]:find('rbxasset') and split[2] or isfile(split[2]) and assetfunction(split[2]) or ''
				end
			end
		end
	})
end)
	
run(function()
	local UICleanup
	local OpenInv
	local KillFeed
	local OldTabList
	local HotbarApp = getRoactRender(require(lplr.PlayerScripts.TS.controllers.global.hotbar.ui['hotbar-app']).HotbarApp.render)
	local HotbarOpenInventory = require(lplr.PlayerScripts.TS.controllers.global.hotbar.ui['hotbar-open-inventory']).HotbarOpenInventory
	local old, new = {}, {}
	local oldkillfeed
	
	vape:Clean(function()
		for _, v in new do
			table.clear(v)
		end
		for _, v in old do
			table.clear(v)
		end
		table.clear(new)
		table.clear(old)
	end)
	
	local function modifyconstant(func, ind, val)
		if not old[func] then old[func] = {} end
		if not new[func] then new[func] = {} end
		if not old[func][ind] then
			local typing = type(old[func][ind])
			if typing == 'function' or typing == 'userdata' then return end
			old[func][ind] = debug.getconstant(func, ind)
		end
		if typeof(old[func][ind]) ~= typeof(val) and val ~= nil then return end
	
		new[func][ind] = val
		if UICleanup.Enabled then
			if val then
				debug.setconstant(func, ind, val)
			else
				debug.setconstant(func, ind, old[func][ind])
				old[func][ind] = nil
			end
		end
	end
	
	UICleanup = vape.Categories.Legit:CreateModule({
		Name = 'UI Cleanup',
		Function = function(callback)
			for i, v in (callback and new or old) do
				for i2, v2 in v do
					debug.setconstant(i, i2, v2)
				end
			end
			if callback then
				if OpenInv.Enabled then
					oldinvrender = HotbarOpenInventory.render
					HotbarOpenInventory.render = function()
						return bedwars.Roact.createElement('TextButton', {Visible = false}, {})
					end
				end
	
				if KillFeed.Enabled then
					oldkillfeed = bedwars.KillFeedController.addToKillFeed
					bedwars.KillFeedController.addToKillFeed = function() end
				end
	
				if OldTabList.Enabled then
					starterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, true)
				end
			else
				if oldinvrender then
					HotbarOpenInventory.render = oldinvrender
					oldinvrender = nil
				end
	
				if KillFeed.Enabled then
					bedwars.KillFeedController.addToKillFeed = oldkillfeed
					oldkillfeed = nil
				end
	
				if OldTabList.Enabled then
					starterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, false)
				end
			end
		end,
		Tooltip = 'Cleans up the UI for kits & main'
	})
	UICleanup:CreateToggle({
		Name = 'Resize Health',
		Function = function(callback)
			modifyconstant(HotbarApp, 60, callback and 1 or nil)
			modifyconstant(debug.getupvalue(HotbarApp, 15).render, 30, callback and 1 or nil)
			modifyconstant(debug.getupvalue(HotbarApp, 23).tweenPosition, 16, callback and 0 or nil)
		end,
		Default = true
	})
	UICleanup:CreateToggle({
		Name = 'No Hotbar Numbers',
		Function = function(callback)
			local func = oldinvrender or HotbarOpenInventory.render
			modifyconstant(debug.getupvalue(HotbarApp, 23).render, 90, callback and 0 or nil)
			modifyconstant(func, 71, callback and 0 or nil)
		end,
		Default = true
	})
	OpenInv = UICleanup:CreateToggle({
		Name = 'No Inventory Button',
		Function = function(callback)
			modifyconstant(HotbarApp, 78, callback and 0 or nil)
			if UICleanup.Enabled then
				if callback then
					oldinvrender = HotbarOpenInventory.render
					HotbarOpenInventory.render = function()
						return bedwars.Roact.createElement('TextButton', {Visible = false}, {})
					end
				else
					HotbarOpenInventory.render = oldinvrender
					oldinvrender = nil
				end
			end
		end,
		Default = true
	})
	KillFeed = UICleanup:CreateToggle({
		Name = 'No Kill Feed',
		Function = function(callback)
			if UICleanup.Enabled then
				if callback then
					oldkillfeed = bedwars.KillFeedController.addToKillFeed
					bedwars.KillFeedController.addToKillFeed = function() end
				else
					bedwars.KillFeedController.addToKillFeed = oldkillfeed
					oldkillfeed = nil
				end
			end
		end,
		Default = true
	})
	OldTabList = UICleanup:CreateToggle({
		Name = 'Old Player List',
		Function = function(callback)
			if UICleanup.Enabled then
				starterGui:SetCoreGuiEnabled(Enum.CoreGuiType.PlayerList, callback)
			end
		end,
		Default = true
	})
	UICleanup:CreateToggle({
		Name = 'Fix Queue Card',
		Function = function(callback)
			modifyconstant(bedwars.QueueCard.render, 15, callback and 0.1 or nil)
		end,
		Default = true
	})
end)
	
run(function()
    local WinEffect
    local List
    local NameToId = {}
    
    WinEffect = vape.Categories.Legit:CreateModule({
        Name = "WinEffect",
        Function = function(callback)
            if callback then
                WinEffect:Clean(vapeEvents.MatchEndEvent.Event:Connect(function()
                    for i, v in getconnections(bedwars.Client:Get("WinEffectTriggered").instance.OnClientEvent) do
                        if v.Function then
                            v.Function({
                                winEffectType = NameToId[List.Value],
                                winningPlayer = lplr
                            })
                        end
                    end
                end))
            end
        end,
        Tooltip = "Allows you to select any clientside win effect"
    })
    
    local WinEffectName = {}
    for i, v in bedwars.WinEffectMeta do
        table.insert(WinEffectName, v.name)
        NameToId[v.name] = i
    end
    table.sort(WinEffectName)
    
    List = WinEffect:CreateDropdown({
        Name = "Effects",
        List = WinEffectName
    })
end)

run(function()
	local Viewmodel
	local Depth
	local Horizontal
	local Vertical
	local NoBob
	local Rots = {}
	local old, oldc1
	
	Viewmodel = vape.Categories.Combat:CreateModule({
		Name = 'Viewmodel',
		Function = function(callback)
			local viewmodel = gameCamera:FindFirstChild('Viewmodel')
			if callback then
				old = bedwars.ViewmodelController.playAnimation
				oldc1 = viewmodel and viewmodel.RightHand.RightWrist.C1 or CFrame.identity
				if NoBob.Enabled then
					bedwars.ViewmodelController.playAnimation = function(self, animtype, ...)
						if bedwars.AnimationType and animtype == bedwars.AnimationType.FP_WALK then return end
						return old(self, animtype, ...)
					end
				end
	
				bedwars.InventoryViewmodelController:handleStore(bedwars.Store:getState())
				if viewmodel then
					gameCamera.Viewmodel.RightHand.RightWrist.C1 = oldc1 * CFrame.Angles(math.rad(Rots[1].Value), math.rad(Rots[2].Value), math.rad(Rots[3].Value))
				end
				lplr.PlayerScripts.TS.controllers.global.viewmodel['viewmodel-controller']:SetAttribute('ConstantManager_DEPTH_OFFSET', -Depth.Value)
				lplr.PlayerScripts.TS.controllers.global.viewmodel['viewmodel-controller']:SetAttribute('ConstantManager_HORIZONTAL_OFFSET', Horizontal.Value)
				lplr.PlayerScripts.TS.controllers.global.viewmodel['viewmodel-controller']:SetAttribute('ConstantManager_VERTICAL_OFFSET', Vertical.Value)
			else
				bedwars.ViewmodelController.playAnimation = old
				if viewmodel then
					viewmodel.RightHand.RightWrist.C1 = oldc1
				end
	
				bedwars.InventoryViewmodelController:handleStore(bedwars.Store:getState())
				lplr.PlayerScripts.TS.controllers.global.viewmodel['viewmodel-controller']:SetAttribute('ConstantManager_DEPTH_OFFSET', 0)
				lplr.PlayerScripts.TS.controllers.global.viewmodel['viewmodel-controller']:SetAttribute('ConstantManager_HORIZONTAL_OFFSET', 0)
				lplr.PlayerScripts.TS.controllers.global.viewmodel['viewmodel-controller']:SetAttribute('ConstantManager_VERTICAL_OFFSET', 0)
				old = nil
			end
		end,
		Tooltip = 'Changes the viewmodel animations'
	})
	Depth = Viewmodel:CreateSlider({
		Name = 'Depth',
		Min = 0,
		Max = 2,
		Default = 0.8,
		Decimal = 10,
		Function = function(val)
			if Viewmodel.Enabled then
				lplr.PlayerScripts.TS.controllers.global.viewmodel['viewmodel-controller']:SetAttribute('ConstantManager_DEPTH_OFFSET', -val)
			end
		end
	})
	Horizontal = Viewmodel:CreateSlider({
		Name = 'Horizontal',
		Min = 0,
		Max = 2,
		Default = 0.8,
		Decimal = 10,
		Function = function(val)
			if Viewmodel.Enabled then
				lplr.PlayerScripts.TS.controllers.global.viewmodel['viewmodel-controller']:SetAttribute('ConstantManager_HORIZONTAL_OFFSET', val)
			end
		end
	})
	Vertical = Viewmodel:CreateSlider({
		Name = 'Vertical',
		Min = -0.2,
		Max = 2,
		Default = -0.2,
		Decimal = 10,
		Function = function(val)
			if Viewmodel.Enabled then
				lplr.PlayerScripts.TS.controllers.global.viewmodel['viewmodel-controller']:SetAttribute('ConstantManager_VERTICAL_OFFSET', val)
			end
		end
	})
	for _, name in {'Rotation X', 'Rotation Y', 'Rotation Z'} do
		table.insert(Rots, Viewmodel:CreateSlider({
			Name = name,
			Min = 0,
			Max = 360,
			Function = function(val)
				if Viewmodel.Enabled then
					gameCamera.Viewmodel.RightHand.RightWrist.C1 = oldc1 * CFrame.Angles(math.rad(Rots[1].Value), math.rad(Rots[2].Value), math.rad(Rots[3].Value))
				end
			end
		}))
	end
	NoBob = Viewmodel:CreateToggle({
		Name = 'No Bobbing',
		Default = true,
		Function = function()
			if Viewmodel.Enabled then
				Viewmodel:Toggle()
				Viewmodel:Toggle()
			end
		end
	})
end)

run(function() 
    local MatchHistory
    
    MatchHistory = vape.Categories.Utility:CreateModule({
        Name = "ClearMatchHistory",
        Tooltip = "Resets ur match history",
        Function = function(callback)
            
            if callback then 
                MatchHistory:Toggle(false)
                local TeleportService = game:GetService("TeleportService")
                local data = TeleportService:GetLocalPlayerTeleportData()
                TeleportService:Teleport(game.PlaceId, game.Players.LocalPlayer, data)
            end
        end,
    }) 
end)

run(function()
	local ViewMatchHistory
	ViewMatchHistory = vape.Categories.Utility:CreateModule({
		Name = "ViewMatchHistory",
		Function = function(callback)
			if callback then
				ViewMatchHistory:Toggle(false)
				local d = nil
				bedwars.MatchHistroyController:requestMatchHistory(lplr.Name):andThen(function(Data)
					if Data then
						bedwars.AppController:openApp({app = bedwars.MatchHistroyApp,appId = "MatchHistoryApp",},Data)
					end
				end)
			else
				return
			end
		end,
		Tooltip = "matchhisory"
	})																								
end)

run(function()
    local lightingService = cloneref(game:GetService('Lighting'))
    local lightingsettings = {}
    local Fullbright = {Enabled = false}
    local BrightnessSlider
    
    local lastLightingChange = 0
    local DEBOUNCE_TIME = 0.016 
    
    Fullbright = vape.Categories.World:CreateModule({
        Name = "Fullbright",
        Function = function(callback)
            if callback then
                lightingsettings = {
                    Brightness = lightingService.Brightness,
                    ClockTime = lightingService.ClockTime,
                    FogEnd = lightingService.FogEnd,
                    GlobalShadows = lightingService.GlobalShadows,
                    OutdoorAmbient = lightingService.OutdoorAmbient,
                    Ambient = lightingService.Ambient,
                    ExposureCompensation = lightingService.ExposureCompensation
                }
                
                local brightnessValue = BrightnessSlider and BrightnessSlider.Value or 5
                
                lastLightingChange = tick()
                lightingService.Brightness = brightnessValue
                lightingService.ClockTime = 14  
                lightingService.FogEnd = 100000 
                lightingService.GlobalShadows = false  
                lightingService.OutdoorAmbient = Color3.fromRGB(255, 255, 255)  
                lightingService.Ambient = Color3.fromRGB(255, 255, 255)  
                lightingService.ExposureCompensation = 1  
                
                local function protectProperty(propertyName, value)
                    return lightingService:GetPropertyChangedSignal(propertyName):Connect(function()
                        local now = tick()
                        if now - lastLightingChange > DEBOUNCE_TIME then
                            lastLightingChange = now
                            lightingService[propertyName] = value
                        end
                    end)
                end
                
                Fullbright:Clean(protectProperty("Brightness", brightnessValue))
                Fullbright:Clean(protectProperty("Ambient", Color3.fromRGB(255, 255, 255)))
                Fullbright:Clean(protectProperty("ExposureCompensation", 1))
                
            else
                lastLightingChange = tick()
                
                for property, value in pairs(lightingsettings) do
                    if value ~= nil then
                        lightingService[property] = value
                    end
                end
                
                table.clear(lightingsettings)
            end
        end,
        HoverText = "Makes everything bright and removes shadows"
    })
    
    BrightnessSlider = Fullbright:CreateSlider({
        Name = "Brightness",
        Min = 1,
        Max = 10,
        Default = 5,
        Function = function(value)
            if Fullbright.Enabled then
                lastLightingChange = tick()
                lightingService.Brightness = value
            end
        end
    })
    
    local ExtraBright = Fullbright:CreateToggle({
        Name = "Extra Bright",
        Function = function(callback)
            if Fullbright.Enabled then
                lastLightingChange = tick()
                if callback then
                    lightingService.Brightness = 10
                    lightingService.Ambient = Color3.fromRGB(255, 255, 255)
                    lightingService.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
                    lightingService.ExposureCompensation = 2
                    
                    if not lightingService:FindFirstChild("VapeSun") then
                        local sun = Instance.new("SunRaysEffect")
                        sun.Name = "VapeSun"
                        sun.Intensity = 0.1
                        sun.Spread = 1
                        sun.Parent = lightingService
                    end
                else
                    lightingService.Brightness = BrightnessSlider.Value
                    lightingService.Ambient = Color3.fromRGB(255, 255, 255)
                    lightingService.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
                    lightingService.ExposureCompensation = 1
                    
                    local sun = lightingService:FindFirstChild("VapeSun")
                    if sun then
                        sun:Destroy()
                    end
                end
            end
        end
    })
    
    local NoShadows = Fullbright:CreateToggle({
        Name = "No Shadows",
        Function = function(callback)
            if Fullbright.Enabled then
                lastLightingChange = tick()
                lightingService.GlobalShadows = not callback
            end
        end,
        Default = true
    })
end)

run(function()
    local Clutch
    local runService = game:GetService("RunService")
    local workspace = game:GetService("Workspace")
    local HoldBase = 0.15
    local FallVelocity = -6
    local lastPlace = 0
    local UseBlacklisted_Blocks
    local blacklisted
    local clutchCount = 0
    local lastResetTime = 0
    
    local cachedProximityBlock = nil
    local cachedProximityTime = 0
    local PROXIMITY_CACHE_TIME = 0.1
    
    local blacklistLookup = {}
    
    local function callPlace(blockpos, wool, rotate)
        local placeFn
        if type(vape) == "table" and type(vape.clean) == "function" then
            vape:clean(blockpos, wool, rotate)
            return
        end
        if type(vape) == "table" and type(vape.place) == "function" then
            placeFn = vape.place
        elseif type(place) == "function" then
            placeFn = place
        else
            placeFn = bedwars.placeBlock
        end
        task.spawn(placeFn, blockpos, wool, rotate)
    end

    local function nearCorner(poscheck, pos)
        local startpos = poscheck - Vector3.new(3, 3, 3)
        local endpos = poscheck + Vector3.new(3, 3, 3)
        local check = poscheck + (pos - poscheck).Unit * 100
        return Vector3.new(
            math.clamp(check.X, startpos.X, endpos.X), 
            math.clamp(check.Y, startpos.Y, endpos.Y), 
            math.clamp(check.Z, startpos.Z, endpos.Z)
        )
    end

    local function blockProximity(pos)
        local now = tick()
        
        if cachedProximityBlock and (now - cachedProximityTime) < PROXIMITY_CACHE_TIME then
            return cachedProximityBlock
        end
        
        local mag, returned = 60
        local blockPos = bedwars.BlockController:getBlockPosition(pos)
        
        local tab = getBlocksInPoints(
            bedwars.BlockController:getBlockPosition(pos - Vector3.new(15, 15, 15)), 
            bedwars.BlockController:getBlockPosition(pos + Vector3.new(15, 15, 15))
        )
        
        for _, v in tab do
            local blockpos = nearCorner(v, pos)
            local newmag = (pos - blockpos).Magnitude
            if newmag < mag then
                mag, returned = newmag, blockpos
            end
        end
        table.clear(tab)
        
        cachedProximityBlock = returned
        cachedProximityTime = now
        
        return returned
    end

    local function getClutchBlock()
        if store.hand.toolType == 'block' then
            return store.hand.tool.Name, store.hand.amount
        end
        return nil, 0
    end

    local function updateBlacklistLookup()
        table.clear(blacklistLookup)
        if blacklisted and blacklisted.ListEnabled then
            for _, v in blacklisted.ListEnabled do
                blacklistLookup[v] = true
            end
        end
    end

    Clutch = vape.Categories.Utility:CreateModule({
        Name = 'Clutch',
        Function = function(call)
            if call then
                clutchCount = 0
                lastResetTime = os.clock()
                updateBlacklistLookup()
                
                local heightCheckEnabled = false
                local minHeight = 20
                local minBlocksEnabled = false
                local minRequired = 5
                local limitToItemsEnabled = false
                local requireMouseEnabled = false
                local silentAimEnabled = false
                local speedVal = 6
                
                Clutch:Clean(runService.Heartbeat:Connect(function()
                    if not Clutch.Enabled or not entitylib.isAlive then return end
                    
                    local root = entitylib.character.RootPart
                    if not root or inputService:GetFocusedTextBox() then return end

                    if clutchCount % 10 == 0 then
                        heightCheckEnabled = Clutch.HeightCheck and Clutch.HeightCheck.Enabled or false
                        minHeight = (Clutch.MinHeight and Clutch.MinHeight.Value) or 20
                        minBlocksEnabled = Clutch.MinBlocks and Clutch.MinBlocks.Enabled or false
                        minRequired = (Clutch.MinBlockAmount and Clutch.MinBlockAmount.Value) or 5
                        limitToItemsEnabled = Clutch.LimitToItems and Clutch.LimitToItems.Enabled or false
                        requireMouseEnabled = Clutch.RequireMouse and Clutch.RequireMouse.Enabled or false
                        silentAimEnabled = Clutch.SilentAim and Clutch.SilentAim.Enabled or false
                        speedVal = (Clutch.Speed and Clutch.Speed.Value) or 6
                    end

                    if heightCheckEnabled and root.Position.Y < minHeight then return end
                    if limitToItemsEnabled and store.hand.toolType ~= "block" then return end
                    if requireMouseEnabled and not inputService:IsMouseButtonPressed(0) then return end

                    local wool, amount = getClutchBlock()
                    if not wool then return end

                    if not UseBlacklisted_Blocks.Enabled and blacklistLookup[wool] then
                        return
                    end

                    if minBlocksEnabled and amount < minRequired then
                        if Clutch.NotifyLowBlocks and Clutch.NotifyLowBlocks.Enabled then
                            notif('Clutch', 'Low on blocks! ('..amount..' left)', 2)
                        end
                        return
                    end
                    
                    local vy = root.Velocity.Y
                    local now = os.clock()
                    
                    if (now - lastResetTime) > 5 then
                        clutchCount = 0
                        lastResetTime = now
                    end
                    
                    local cooldown = math.clamp(HoldBase - (speedVal * 0.015), 0.01, HoldBase)
                    
                    if vy < FallVelocity and (now - lastPlace) > cooldown then
                        local target = roundPos(root.Position - Vector3.new(0, entitylib.character.HipHeight + 4.5, 0))
                        local exists, blockpos = getPlacedBlock(target)
                        
                        if not exists then
                            local prox = blockProximity(target)
                            local placePos = prox or (target * 3)
                            
                            callPlace(placePos, wool, false)
                            lastPlace = now
                            clutchCount = clutchCount + 1
                            
                            if silentAimEnabled then
                                local camera = workspace.CurrentCamera
                                if camera then
                                    local camCFrame = camera.CFrame
                                    local camType = camera.CameraType
                                    local camSubject = camera.CameraSubject
                                    local lv = root.CFrame.LookVector
                                    local newLook = -Vector3.new(lv.X, 0, lv.Z).Unit
                                    local rootPos = root.Position
                                    root.CFrame = CFrame.new(rootPos, rootPos + newLook)
                                    camera.CameraType = camType
                                    camera.CameraSubject = camSubject
                                    camera.CFrame = camCFrame
                                end
                            end
                        end
                    end
                end))
            else
                cachedProximityBlock = nil
                cachedProximityTime = 0
            end
        end,
        Tooltip = 'Automatically places a block when falling to clutch'
    })

    UseBlacklisted_Blocks = Clutch:CreateToggle({
        Name = "Use Blacklisted Blocks",
        Default = false,
        Tooltip = "Allows clutching with blacklisted blocks"
    })

    blacklisted = Clutch:CreateTextList({
        Name = "Blacklisted Blocks",
        Placeholder = "tnt",
        Function = updateBlacklistLookup
    })
    
    Clutch.LimitToItems = Clutch:CreateToggle({
        Name = 'Limit to items',
        Default = false,
        Tooltip = "Only clutch when holding blocks"
    })

    Clutch.RequireMouse = Clutch:CreateToggle({
        Name = 'Require mouse down',
        Default = false,
        Tooltip = "Only clutch when holding left click"
    })

    Clutch.SilentAim = Clutch:CreateToggle({
        Name = 'Silent Aim',
        Default = false,
        Tooltip = "Looks down while placing without moving camera"
    })

    Clutch.HeightCheck = Clutch:CreateToggle({
        Name = 'Height Check',
        Default = false,
        Tooltip = "Only clutch above minimum height (prevents void clutching)"
    })

    Clutch.MinBlocks = Clutch:CreateToggle({
        Name = 'Min Block Check',
        Default = false,
        Tooltip = "Disables clutch when running low on blocks"
    })

    Clutch.NotifyClutch = Clutch:CreateToggle({
        Name = 'Notify Clutch',
        Default = false,
        Tooltip = "Shows notification when you clutch"
    })

    Clutch.NotifyLowBlocks = Clutch:CreateToggle({
        Name = 'Notify Low Blocks',
        Default = false,
        Tooltip = "Warns you when running out of blocks"
    })

    Clutch.AutoDisable = Clutch:CreateToggle({
        Name = 'Auto Disable',
        Default = false,
        Tooltip = "Disables clutch when you run out of blocks"
    })

    Clutch.Speed = Clutch:CreateSlider({
        Name = 'Speed',
        Min = 0,
        Max = 9,
        Default = 6,
        Tooltip = "How fast to place blocks"
    })

    Clutch.MinHeight = Clutch:CreateSlider({
        Name = 'Min Height',
        Min = 0,
        Max = 50,
        Default = 20,
        Tooltip = "Minimum Y position to clutch (prevents void)"
    })

    Clutch.MinBlockAmount = Clutch:CreateSlider({
        Name = 'Min Block Amount',
        Min = 1,
        Max = 32,
        Default = 5,
        Tooltip = "Minimum blocks required to clutch"
    })

    task.spawn(function()
        while task.wait(1) do
            if Clutch.Enabled and Clutch.AutoDisable and Clutch.AutoDisable.Enabled then
                local wool, amount = getClutchBlock()
                if amount == 0 then
                    notif('Clutch', 'Out of blocks! Auto disabled.', 3)
                    Clutch:Toggle()
                end
            end
        end
    end)
end)

run(function()
    local InvisibleCursor = {}
    local isActive = false
    local renderConnection
    local ViewMode = {Value = 'First Person'}
    local LimitToItems = {Enabled = false}
    local ShowOnGUI = {Enabled = false}
    
    local lastCursorState = nil
    
    local function isFirstPerson()
        if not (lplr.Character and lplr.Character:FindFirstChild("HumanoidRootPart")) then 
            return false 
        end
        local characterPos = lplr.Character.HumanoidRootPart.Position
        local cameraPos = gameCamera.CFrame.Position
        local distance = (characterPos - cameraPos).Magnitude
        return distance < 2
    end
    
    local function isGUIOpen()
        if bedwars.AppController:isLayerOpen(bedwars.UILayers.MAIN) then
            return true
        end
        
        if bedwars.AppController:isLayerOpen(bedwars.UILayers.DIALOG) then
            return true
        end
        
        if bedwars.AppController:isLayerOpen(bedwars.UILayers.POPUP) then
            return true
        end
        
        local inventoryState = bedwars.Store:getState().Inventory
        if inventoryState and inventoryState.observedInventory and inventoryState.observedInventory.isOpen then
            return true
        end
        
        return false
    end
    
    local function hasBowEquipped()
        if not store.hand or not store.hand.tool then
            return false
        end
        
        local toolName = store.hand.tool.Name:lower()
        return toolName:find('bow') ~= nil or toolName:find('crossbow') ~= nil
    end
    
    local function shouldHideCursor()
        if not isActive then return false end
        
        if ShowOnGUI.Enabled and isGUIOpen() then
            return false
        end
        
        if LimitToItems.Enabled and not hasBowEquipped() then
            return false
        end
        
        local inFirstPerson = isFirstPerson()
    
        if ViewMode.Value == 'First Person' then
            return inFirstPerson
        elseif ViewMode.Value == 'Third Person' then
            return not inFirstPerson
        elseif ViewMode.Value == 'Both' then
            return true
        end
        
        return false
    end
    
    local function updateCursor()
        local shouldHide = shouldHideCursor()
        
        if lastCursorState == shouldHide then
            return 
        end
        
        lastCursorState = shouldHide
        inputService.MouseIconEnabled = not shouldHide
    end
    
    InvisibleCursor = vape.Categories.Utility:CreateModule({
        Name = 'InvisibleCursor',
        Function = function(callback)
            if callback then
                isActive = true
                lastCursorState = nil
                
                if renderConnection then
                    renderConnection:Disconnect()
                end
                
                renderConnection = runService.RenderStepped:Connect(updateCursor)
                
                InvisibleCursor:Clean(vapeEvents.InventoryChanged.Event:Connect(updateCursor))
            else
                isActive = false
                
                if renderConnection then
                    renderConnection:Disconnect()
                    renderConnection = nil
                end
                
                inputService.MouseIconEnabled = true
                lastCursorState = nil
            end
        end,
        Tooltip = 'Hides cursor based on view mode and item settings'
    })
    
    ViewMode = InvisibleCursor:CreateDropdown({
        Name = 'View Mode',
        List = {'First Person', 'Third Person', 'Both'},
        Default = 'First Person',
        Tooltip = 'Choose when to hide cursor\nFirst Person: Only in 1st person\nThird Person: Only in 3rd person\nBoth: Always hide',
        Function = function(val)
            ViewMode.Value = val
            updateCursor()
        end
    })
    
    LimitToItems = InvisibleCursor:CreateToggle({
        Name = 'Limit to Bow',
        Default = false,
        Tooltip = 'Only hide cursor when holding a bow/crossbow',
        Function = function(val)
            LimitToItems.Enabled = val
            updateCursor()
        end
    })
    
    ShowOnGUI = InvisibleCursor:CreateToggle({
        Name = 'Show on GUI',
        Default = false,
        Tooltip = 'Show cursor when any GUI is open (inventory, shop, etc)',
        Function = function(val)
            ShowOnGUI.Enabled = val
            updateCursor()
        end
    })
end)

run(function()
    local BCR
    local Value
    local CpsConstants = nil
    local isMobileDevice = inputService.TouchEnabled and not inputService.KeyboardEnabled and not inputService.MouseEnabled
    
    BCR = vape.Categories.Blatant:CreateModule({
        Name = "BlockCPSRemover",
        Function = function(callback)
            
            if callback then
                task.wait(1)
                
                pcall(function()
                    CpsConstants = require(replicatedStorage.TS['shared-constants']).CpsConstants
                end)
                
                if not CpsConstants then
                    pcall(function()
                        CpsConstants = bedwars.CpsConstants
                    end)
                end
                
                if CpsConstants then
                    local newCPS = Value.Value == 0 and 1000 or Value.Value
                    CpsConstants.BLOCK_PLACE_CPS = newCPS
                    
                    if isMobileDevice then
                        for _, v in {'2', '5'} do
                            pcall(function()
                                BCR:Clean(lplr.PlayerGui.MobileUI[v].MouseButton1Down:Connect(function()
                                    if CpsConstants then
                                        local currentValue = Value.Value == 0 and 1000 or Value.Value
                                        CpsConstants.BLOCK_PLACE_CPS = currentValue
                                    end
                                end))
                            end)
                        end
                    end
                    
                    task.spawn(function()
                        while BCR.Enabled do
                            local currentValue = Value.Value == 0 and 1000 or Value.Value
                            if CpsConstants.BLOCK_PLACE_CPS ~= currentValue then
                                CpsConstants.BLOCK_PLACE_CPS = currentValue
                            end
                            task.wait(0.3)
                        end
                    end)
                end
                
            else
                if CpsConstants then
                    CpsConstants.BLOCK_PLACE_CPS = 12
                end
            end
        end,
        Tooltip = 'Simple CPS modifier (Mobile + Desktop)'
    })
    
    Value = BCR:CreateSlider({
        Name = "CPS Limit",
        Suffix = "CPS",
        Tooltip = "Higher = faster but more ghost blocks",
        Default = 67,
        Min = 12,
        Max = 100,
        Function = function()
            if BCR.Enabled and CpsConstants then
                local newCPS = Value.Value == 0 and 1000 or Value.Value
                CpsConstants.BLOCK_PLACE_CPS = newCPS
            end
        end,
    })
end)

run(function()
    local PlayerLevelSet = {Enabled = false}
    local PlayerLevel = {Value = 100}
    local originalLevel = nil  
    
    PlayerLevelSet = vape.Categories.Utility:CreateModule({
        Name = 'SetPlayerLevel',
        Tooltip = 'Sets your player level to 100 (client sided)',
        Function = function(calling)
            if calling then                 
                if PlayerLevelSet.Enabled and not originalLevel then
                    originalLevel = game.Players.LocalPlayer:GetAttribute("PlayerLevel") or 1
                end
                
                game.Players.LocalPlayer:SetAttribute("PlayerLevel", PlayerLevel.Value)
            else
                if originalLevel then
                    game.Players.LocalPlayer:SetAttribute("PlayerLevel", originalLevel)
                    originalLevel = nil  
                end
            end
        end
    })
    
    PlayerLevel = PlayerLevelSet:CreateSlider({
        Name = 'Sets your player level(client side)',
        Function = function() 
            if PlayerLevelSet.Enabled then 
                game.Players.LocalPlayer:SetAttribute("PlayerLevel", PlayerLevel.Value) 
            end 
        end,
        Min = 1,
        Max = 1000,
        Default = 100
    })
end)

run(function()
	local StaffDetector
	local Mode
	local Clans
	local Party
	local Profile
	local Users
	local AlertDuration
	local blacklistedclans = {'gg', 'gg2', 'DV', 'DV2'}
	local blacklisteduserids = {1502104539, 3826146717, 4531785383, 1049767300, 4926350670, 653085195, 184655415, 2752307430, 5087196317, 5744061325, 1536265275}
	local joined = {}
	local detectedPlayers = {} 
	local processing = {} 
	local blacklistedClansLookup = {}
	local blacklistedUserIdsLookup = {}
	local customUsersLookup = {}
	local rankCache = {}
	local RANK_CACHE_TIME = 300 
	
	local function updateBlacklistLookups()
		table.clear(blacklistedClansLookup)
		for _, clan in blacklistedclans do
			blacklistedClansLookup[clan] = true
		end
		
		table.clear(blacklistedUserIdsLookup)
		for _, userId in blacklisteduserids do
			blacklistedUserIdsLookup[userId] = true
		end
		
		table.clear(customUsersLookup)
		if Users and Users.ListEnabled then
			for _, userId in Users.ListEnabled do
				local numId = tonumber(userId)
				if numId then
					customUsersLookup[numId] = true
				end
			end
		end
	end
	
	local function getRole(plr, groupId)
		local userId = plr.UserId
		local cacheKey = userId .. "_" .. groupId
		local now = tick()
		
		if rankCache[cacheKey] then
			local cached = rankCache[cacheKey]
			if (now - cached.time) < RANK_CACHE_TIME then
				return cached.rank
			end
		end
		
		local suc, res = pcall(function()
			return plr:GetRankInGroup(groupId)
		end)
		
		if not suc then
			notif('StaffDetector', res, 30, 'alert')
			return 0
		end
		
		rankCache[cacheKey] = {
			rank = res,
			time = now
		}
		
		return res
	end
	
	local function staffFunction(plr, checktype)
		if detectedPlayers[plr.UserId] then return end
		
		if not vape.Loaded then
			repeat task.wait() until vape.Loaded
		end
	
		local duration = AlertDuration.Value
		local playerName = plr.Name
		local playerId = plr.UserId
		
		detectedPlayers[playerId] = {
			name = playerName,
			checktype = checktype,
			detectedTime = tick()
		}
		
		local alertMsg = 'Staff Detected (' .. checktype .. '): ' .. playerName .. ' (' .. playerId .. ')'
		notif('StaffDetector', alertMsg, duration, 'alert')
		whitelist.customtags[playerName] = {{text = 'GAME STAFF', color = Color3.new(1, 0, 0)}}
	
		local isClanCheck = checktype:find('clan')
		if Party.Enabled and not isClanCheck then
			bedwars.PartyController:leaveParty()
		end
	
		local modeValue = Mode.Value
		if modeValue == 'Uninject' then
			task.spawn(function()
				vape:Uninject()
			end)
			game:GetService('StarterGui'):SetCore('SendNotification', {
				Title = 'StaffDetector',
				Text = 'Staff Detected (' .. checktype .. ')\n' .. playerName .. ' (' .. playerId .. ')',
				Duration = duration,
			})
		elseif modeValue == 'Requeue' then
			bedwars.QueueController:joinQueue(store.queueType)
		elseif modeValue == 'Profile' then
			vape.Save = function() end
			if vape.Profile ~= Profile.Value then
				vape:Load(true, Profile.Value)
			end
		elseif modeValue == 'AutoConfig' then
			local safe = {
				AutoClicker = true,
				Reach = true,
				Sprint = true,
				HitFix = true,
				StaffDetector = true
			}
			vape.Save = function() end
			for i, v in vape.Modules do
				if not (safe[i] or v.Category == 'Render') then
					if v.Enabled then
						v:Toggle()
					end
					v:SetBind('')
				end
			end
		end
	end
	
	local friendCache = {}
	local FRIEND_CACHE_TIME = 600
	
	local function checkFriends(list)
		for _, v in list do
			if joined[v] then
				return joined[v]
			end
		end
		return nil
	end
	
	local function getFriendsWithTimeout(userId, timeout)
		local now = tick()
		
		if friendCache[userId] then
			local cached = friendCache[userId]
			if (now - cached.time) < FRIEND_CACHE_TIME then
				return cached.friends
			end
		end
		
		local result = nil
		local finished = false
		
		task.spawn(function()
			local suc, res = pcall(function()
				local tab = {}
				local pages = playersService:GetFriendsAsync(userId)
				
				for i = 1, 6 do
					local currentPage = pages:GetCurrentPage()
					for _, v in currentPage do
						table.insert(tab, v.Id)
					end
					if pages.IsFinished then break end
					
					if #tab > 50 then break end
					
					pages:AdvanceToNextPageAsync()
				end
				return tab
			end)
			
			if suc then
				result = res
				friendCache[userId] = {
					friends = res,
					time = now
				}
			end
			finished = true
		end)
		
		local waited = 0
		while not finished and waited < timeout do
			task.wait(0.05)
			waited = waited + 0.05
		end
		
		return result
	end
	
	local function checkJoin(plr, connection)
		local hasTeam = plr:GetAttribute('Team')
		local isSpectator = plr:GetAttribute('Spectator')
		local isCustomMatch = bedwars.Store:getState().Game.customMatch
		
		if not hasTeam and isSpectator and not isCustomMatch then
			connection:Disconnect()
			
			local tab = getFriendsWithTimeout(plr.UserId, 5)
			
			if not tab then
				staffFunction(plr, 'impossible_join')
				return true
			end
			
			local friend = checkFriends(tab)
			if not friend then
				staffFunction(plr, 'impossible_join')
				return true
			else
				notif('StaffDetector', string.format('Spectator %s joined from %s', plr.Name, friend), 20, 'warning')
			end
		end
		return false
	end
	
	local function playerAdded(plr)
		joined[plr.UserId] = plr.Name
		
		if plr == lplr then return end
		if processing[plr.UserId] then return end
		processing[plr.UserId] = true
		
		if blacklistedUserIdsLookup[plr.UserId] or customUsersLookup[plr.UserId] then
			staffFunction(plr, 'blacklisted_user')
			processing[plr.UserId] = nil
			return
		end
	
		if getRole(plr, 5774246) >= 100 then
			staffFunction(plr, 'staff_role')
			processing[plr.UserId] = nil
			return
		end
		
		local spectatorConnection
		spectatorConnection = plr:GetAttributeChangedSignal('Spectator'):Connect(function()
			if checkJoin(plr, spectatorConnection) then
				processing[plr.UserId] = nil
			end
		end)
		StaffDetector:Clean(spectatorConnection)
		
		if checkJoin(plr, spectatorConnection) then
			processing[plr.UserId] = nil
			return
		end

		if Clans.Enabled then
			local function checkClanTag()
				local clanTag = plr:GetAttribute('ClanTag')
				if clanTag and blacklistedClansLookup[clanTag] then
					staffFunction(plr, 'blacklisted_clan_' .. clanTag:lower())
				end
			end
			
			if plr:GetAttribute('ClanTag') then
				checkClanTag()
			else
				local clanConnection
				local timeoutCancelled = false
				
				clanConnection = plr:GetAttributeChangedSignal('ClanTag'):Connect(function()
					if not timeoutCancelled then
						timeoutCancelled = true
						checkClanTag()
						if clanConnection then
							clanConnection:Disconnect()
						end
					end
				end)
				
				task.delay(5, function()
					if not timeoutCancelled then
						timeoutCancelled = true
						if clanConnection then
							clanConnection:Disconnect()
						end
					end
				end)
				
				StaffDetector:Clean(clanConnection)
			end
		end
		
		processing[plr.UserId] = nil
	end
	
	local function playerRemoving(plr)
		local userId = plr.UserId
		
		joined[userId] = nil
		processing[userId] = nil
		
		if detectedPlayers[userId] then
			local data = detectedPlayers[userId]
			local leaveMsg = data.name .. ' (' .. data.checktype .. ') has left the server'
			
			notif('StaffDetector', leaveMsg, AlertDuration.Value, 'warning')
			
			if whitelist.customtags[data.name] then
				whitelist.customtags[data.name] = nil
			end
			
			detectedPlayers[userId] = nil
		end
	end
	
	StaffDetector = vape.Categories.Utility:CreateModule({
		Name = 'StaffDetector',
		Function = function(callback)
			if callback then
				updateBlacklistLookups()
				
				StaffDetector:Clean(playersService.PlayerAdded:Connect(playerAdded))
				StaffDetector:Clean(playersService.PlayerRemoving:Connect(playerRemoving))
				
				for _, v in playersService:GetPlayers() do
					task.spawn(playerAdded, v)
				end
			else
				table.clear(joined)
				table.clear(processing)
				table.clear(detectedPlayers)
				table.clear(rankCache)
				table.clear(friendCache)
			end
		end,
		Tooltip = 'Detects people with a staff rank ingame'
	})
	
	Mode = StaffDetector:CreateDropdown({
		Name = 'Mode',
		List = {'Uninject', 'Profile', 'Requeue', 'AutoConfig', 'Notify'},
		Function = function(val)
			if Profile.Object then
				Profile.Object.Visible = val == 'Profile'
			end
		end
	})
	
	AlertDuration = StaffDetector:CreateSlider({
		Name = 'Alert Duration',
		Min = 5,
		Max = 120,
		Default = 60,
		Suffix = 's',
		Function = function(val)
		end,
		Tooltip = 'How long the alert notification stays on screen'
	})
	
	Clans = StaffDetector:CreateToggle({
		Name = 'Blacklist clans',
		Default = true
	})
	
	Party = StaffDetector:CreateToggle({
		Name = 'Leave party'
	})
	
	Profile = StaffDetector:CreateTextBox({
		Name = 'Profile',
		Default = 'default',
		Darker = true,
		Visible = false
	})
	
	Users = StaffDetector:CreateTextList({
		Name = 'Users',
		Placeholder = 'player (userid)',
		Function = updateBlacklistLookups 
	})
end)

run(function()
	local LegacyAnimation
	
	local function ensureAttribute()
		local workspace = game:GetService("Workspace")
		
		if workspace:GetAttribute("RbxLegacyAnimationBlending") == nil then
			workspace:SetAttribute("RbxLegacyAnimationBlending", false)
		end
	end
	
	local function setLegacyAnimation(enabled)
		local workspace = game:GetService("Workspace")
		
		ensureAttribute()
		
		workspace:SetAttribute("RbxLegacyAnimationBlending", enabled)
	end
	
	LegacyAnimation = vape.Categories.Render:CreateModule({
		Name = 'LegacyAnimation',
		Function = function(callback)
			
			if callback then
				ensureAttribute()
				
				setLegacyAnimation(true)
			else
				setLegacyAnimation(false)
			end
		end,
		Tooltip = 'Enables Roblox legacy animation blending'
	})
end)

run(function()
	local rayCheck = RaycastParams.new()
	rayCheck.RespectCanCollide = true
	local module, old
	
	vape.Categories.World:CreateModule({
		Name = 'SafeWalk',
		Function = function(callback)
			if callback then
				if not module then
					local suc = pcall(function() 
						module = require(lplr.PlayerScripts.PlayerModule).controls 
					end)
					if not suc then module = {} end
				end
				
				old = module.moveFunction
				module.moveFunction = function(self, vec, face)
					if entitylib.isAlive then
						rayCheck.FilterDescendantsInstances = {lplr.Character, gameCamera}
						local root = entitylib.character.RootPart
						local movedir = root.Position + vec
						local ray = game.Workspace:Raycast(movedir, Vector3.new(0, -15, 0), rayCheck)
						if not ray then
							local check = game.Workspace:Blockcast(root.CFrame, Vector3.new(3, 1, 3), Vector3.new(0, -(entitylib.character.HipHeight + 1), 0), rayCheck)
							if check then
								vec = (check.Instance:GetClosestPointOnSurface(movedir) - root.Position) * Vector3.new(1, 0, 1)
							end
						end
					end
	
					return old(self, vec, face)
				end
			else
				if module and old then
					module.moveFunction = old
				end
			end
		end,
		Tooltip = '"I need safe walk to main jugg" - desire'
	})
end)

run(function()
	local KaidaKillaura
	local Targets
	local AttackRange
	local UpdateRate
	local MouseDown
	local GUICheck
	local ShowAnimation
	local PerfectAbility
	local AbilityDistance
	local SwingDuringAbility
	local lastAttackTime = 0
	local lastAbilityTime = 0
	local attackCooldown = 0.65
	local abilityCooldown = 22
	local isChargingAbility = false
	local abilityStartTime = 0
	
	local function getPlayerClawLevel()
		local handItem = lplr.Character and lplr.Character:FindFirstChild('HandInvItem')
		if handItem and handItem.Value then
			local itemType = handItem.Value.Name
			if itemType == 'summoner_claw_1' then return 1 end
			if itemType == 'summoner_claw_2' then return 2 end
			if itemType == 'summoner_claw_3' then return 3 end
			if itemType == 'summoner_claw_4' then return 4 end
		end
		
		if store and store.inventory and store.inventory.hotbar then
			for _, v in pairs(store.inventory.hotbar) do
				if v.item then
					local itemType = v.item.itemType
					if itemType == 'summoner_claw_1' then return 1 end
					if itemType == 'summoner_claw_2' then return 2 end
					if itemType == 'summoner_claw_3' then return 3 end
					if itemType == 'summoner_claw_4' then return 4 end
				end
			end
		end
		
		return 1 
	end
	
	KaidaKillaura = vape.Categories.Blatant:CreateModule({
		Name = 'Kaida Killaura',
		Function = function(callback)
			
			if callback then
				if store.equippedKit ~= 'summoner' then
					notif('Kaida Killaura', 'You need to be using Summoner kit!', 3, 'alert')
					KaidaKillaura:Toggle()
					return
				end
				
				lastAttackTime = 0
				lastAbilityTime = 0
				isChargingAbility = false
				
				repeat
					if not entitylib.isAlive then
						task.wait(0.1)
						continue
					end
					
					if GUICheck.Enabled then
						if bedwars.AppController:isLayerOpen(bedwars.UILayers.MAIN) then
							task.wait(0.1)
							continue
						end
					end
					
					local handItem = lplr.Character:FindFirstChild('HandInvItem')
					local hasClaw = false
					if handItem and handItem.Value then
						local itemType = handItem.Value.Name
						hasClaw = itemType:find('summoner_claw')
					end
					
					if not hasClaw then
						task.wait(0.1)
						continue
					end
					
					if MouseDown.Enabled then
						local mousePressed = inputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1)
						if not mousePressed then
							task.wait(1.2)
							continue
						end
					end
					
					local plr = entitylib.EntityPosition({
						Range = AttackRange.Value,
						Part = 'RootPart',
						Players = Targets.Players.Enabled,
						NPCs = Targets.NPCs.Enabled,
						Wallcheck = Targets.Walls.Enabled or nil
					})
					
					if plr then
						local localPosition = entitylib.character.RootPart.Position
						local targetDistance = (localPosition - plr.RootPart.Position).Magnitude
						local currentTime = workspace:GetServerTimeNow()
						
						if PerfectAbility.Enabled and targetDistance <= AbilityDistance.Value then
							if (currentTime - lastAbilityTime) >= abilityCooldown then
								if not isChargingAbility then
									pcall(function()
										game:GetService("ReplicatedStorage")
											:WaitForChild("events-@easy-games/game-core:shared/game-core-networking@getEvents.Events")
											:WaitForChild("useAbility"):FireServer("summoner_start_charging")
									end)
									isChargingAbility = true
									abilityStartTime = currentTime
								end
								
								local chargeTime = currentTime - abilityStartTime
								if chargeTime >= 0.5 then
									pcall(function()
										game:GetService("ReplicatedStorage")
											:WaitForChild("events-@easy-games/game-core:shared/game-core-networking@getEvents.Events")
											:WaitForChild("useAbility"):FireServer("summoner_finish_charging")
									end)
									isChargingAbility = false
									lastAbilityTime = currentTime
								end
							end
						else
							if isChargingAbility then
								isChargingAbility = false
							end
						end
						if (currentTime - lastAttackTime) >= attackCooldown then
							if isChargingAbility and not SwingDuringAbility.Enabled then
								task.wait(0.05)
								continue
							end
							
							local shootDir = CFrame.lookAt(localPosition, plr.RootPart.Position).LookVector
							localPosition += shootDir * math.max((localPosition - plr.RootPart.Position).Magnitude - 16, 0)
							lastAttackTime = currentTime
							if ShowAnimation.Enabled then
								task.spawn(function()
									pcall(function()
										local clawLevel = getPlayerClawLevel()
										bedwars.AnimationUtil:playAnimation(lplr, bedwars.GameAnimationUtil:getAssetId(bedwars.AnimationType.SUMMONER_CHARACTER_SWIPE), {
											looped = false
										})
										local clawModel = replicatedStorage.Assets.Misc.Kaida.Summoner_DragonClaw:Clone()
										local clawColors = {
											Color3.fromRGB(75, 75, 75), 
											Color3.fromRGB(255, 255, 255), 
											Color3.fromRGB(43, 229, 229),  
											Color3.fromRGB(49, 229, 94)   
										}
										local nailMesh = clawModel:FindFirstChild("dragon_claw_nail_mesh")
										if nailMesh and nailMesh:IsA("MeshPart") then
											nailMesh.Color = clawColors[clawLevel] or clawColors[1]
										end
										if bedwars.KnightClient and bedwars.KnightClient.Controllers.SummonerKitSkinController then
											if bedwars.KnightClient.Controllers.SummonerKitSkinController:isPrismaticSkin(lplr) then
												bedwars.KnightClient.Controllers.SummonerKitSkinController:applyClawRGB(clawModel)
											end
										end
										clawModel.Parent = workspace
										local camera = workspace.CurrentCamera
										if camera and camera.CFrame.Position and (camera.CFrame.Position - entitylib.character.RootPart.Position).Magnitude < 1 then
											for _, part in clawModel:GetDescendants() do
												if part:IsA('MeshPart') then
													part.Transparency = 0.6
												end
											end
										end
										local rootPart = entitylib.character.RootPart
										local Unit = Vector3.new(shootDir.X, 0, shootDir.Z).Unit
										local startPos = rootPart.Position + Unit:Cross(Vector3.new(0, 1, 0)).Unit * -1 * 5 + Unit * 6
										local direction = (startPos + shootDir * 13 - startPos).Unit
										local cframe = CFrame.new(startPos, startPos + direction)
										clawModel:PivotTo(cframe)
										clawModel.PrimaryPart.Anchored = true
										if clawModel:FindFirstChild('AnimationController') then
											local animator = clawModel.AnimationController:FindFirstChildOfClass('Animator')
											if animator then
												bedwars.AnimationUtil:playAnimation(animator, bedwars.GameAnimationUtil:getAssetId(bedwars.AnimationType.SUMMONER_CLAW_ATTACK), {
													looped = false,
													speed = 1
												})
											end
										end
										pcall(function()
											local sounds = {
												bedwars.SoundList.SUMMONER_CLAW_ATTACK_1,
												bedwars.SoundList.SUMMONER_CLAW_ATTACK_2,
												bedwars.SoundList.SUMMONER_CLAW_ATTACK_3,
												bedwars.SoundList.SUMMONER_CLAW_ATTACK_4
											}
											bedwars.SoundManager:playSound(sounds[math.random(1, #sounds)], {
												position = rootPart.Position
											})
										end)
										task.wait(0.75)
										clawModel:Destroy()
									end)
								end)
							end
							bedwars.Client:Get(remotes.SummonerClawAttack):SendToServer({
								position = localPosition,
								direction = shootDir,
								clientTime = currentTime
							})
						end
					else
						if isChargingAbility then
							isChargingAbility = false
						end
					end
					
					task.wait(1 / UpdateRate.Value)
				until not KaidaKillaura.Enabled
			end
		end,
		Tooltip = 'Auto attacks with Summoner claw'
	})
	
	Targets = KaidaKillaura:CreateTargets({
		Players = true,
		NPCs = true,
		Walls = true
	})
	
	AttackRange = KaidaKillaura:CreateSlider({
		Name = 'Attack Range',
		Min = 1,
		Max = 32,
		Default = 22,
		Suffix = function(val)
			return val == 1 and 'stud' or 'studs'
		end
	})
	
	UpdateRate = KaidaKillaura:CreateSlider({
		Name = 'Update Rate',
		Min = 1,
		Max = 120,
		Default = 60,
		Suffix = 'hz'
	})
	
	MouseDown = KaidaKillaura:CreateToggle({
		Name = 'Require Mouse Down',
		Tooltip = 'Only attacks while holding left click'
	})
	
	GUICheck = KaidaKillaura:CreateToggle({
		Name = 'GUI Check'
	})
	
	ShowAnimation = KaidaKillaura:CreateToggle({
		Name = 'Show Animation',
		Default = true
	})
	
	SwingDuringAbility = KaidaKillaura:CreateToggle({
		Name = 'Swing During Ability',
		Default = true,
		Tooltip = 'Continue claw attacks while charging ability (disable for legit gameplay)'
	})
	
	PerfectAbility = KaidaKillaura:CreateToggle({
		Name = 'Perfect Ability',
		Default = false,
		Tooltip = 'Uses ability with minimum 0.5s charge when enemy is close',
		Function = function(callback)
			AbilityDistance.Object.Visible = callback
		end
	})
	
	AbilityDistance = KaidaKillaura:CreateSlider({
		Name = 'Ability Distance',
		Min = 3,
		Max = 15,
		Default = 6,
		Visible = false,
		Tooltip = 'Distance to trigger ability (in studs, 3 studs = 1 block)',
		Suffix = function(val)
			return val == 1 and 'stud' or 'studs'
		end
	})
end)

run(function()
	local RemovePlayerLevel
	
	local function removePlayerLevels(gui)
		for _, descendant in gui:GetDescendants() do
			if descendant:IsA("TextLabel") and descendant.Name == "PlayerLevel" then
				descendant:Destroy()
			end
		end
	end
	
	RemovePlayerLevel = vape.Categories.Render:CreateModule({
		Name = 'Remove Player Level',
		Function = function(callback)
			if callback then
				local existingTabList = lplr.PlayerGui:FindFirstChild("TabListScreenGui")
				if existingTabList then
					removePlayerLevels(existingTabList)
				end
				
				RemovePlayerLevel:Clean(lplr.PlayerGui.ChildAdded:Connect(function(gui)
					if gui.Name == "TabListScreenGui" then
						removePlayerLevels(gui)
						
						RemovePlayerLevel:Clean(gui.DescendantAdded:Connect(function(descendant)
							if descendant:IsA("TextLabel") and descendant.Name == "PlayerLevel" then
								descendant:Destroy()
							end
						end))
					end
				end))
				
			end
		end,
		Tooltip = 'Removes player levels from the TabList'
	})
end)

run(function()
	local OG4v4v4v4
	local OldMaterials = {}
	local OldColors = {}
	local oldTexture = {}
	local oldColor = {}
	local deletedNumTeamMembers = {} 
	
	local function getWorldFolder()
		local Map = workspace:WaitForChild("Map", math.huge)
		local Worlds = Map:WaitForChild("Worlds", math.huge)
		if not Worlds then return nil end
		return Worlds:GetChildren()[1] 
	end
	
	local worldFolder = getWorldFolder()
	if not worldFolder then return end
	local blocks = worldFolder:WaitForChild("Blocks")
	
	local function isValidWoolBlock(obj)
		if not obj:IsA("BasePart") then
			return false
		end
		if obj.Name ~= "wool_orange" and obj.Name ~= "wool_pink" then
			return false
		end
		local parent = obj.Parent
		if parent then
			if parent.Name == "Viewmodel" or parent.Parent and parent.Parent.Name == "Viewmodel" then
				return false
			end
			
			if parent:IsA("Accessory") or parent:IsA("Tool") then
				return false
			end
			
			local ancestor = parent
			while ancestor do
				if ancestor:IsA("Model") and playersService:GetPlayerFromCharacter(ancestor) then
					return false
				end
				ancestor = ancestor.Parent
			end
		end
		
		return true
	end
	
	local function removeNumTeamMembers(gui)
		if not gui then return end
		
		local topBarApp = gui:FindFirstChild("TopBarApp")
		if not topBarApp then return end
		
		local frame5 = topBarApp:FindFirstChild("5")
		if not frame5 then return end
		
		local frame4 = frame5:FindFirstChild("4")
		if not frame4 then return end
		
		for _, frameName in pairs({"2", "3", "4", "5"}) do
			local targetFrame = frame4:FindFirstChild(frameName)
			if targetFrame and targetFrame:IsA("Frame") then
				local numLabel = targetFrame:FindFirstChild("NumTeamMembers")
				if numLabel and numLabel:IsA("TextLabel") then
					deletedNumTeamMembers[numLabel] = {
						Parent = numLabel.Parent,
						Name = numLabel.Name,
						Text = numLabel.Text,
						Position = numLabel.Position,
						Size = numLabel.Size,
						Visible = numLabel.Visible
					}
					numLabel:Destroy()
				end
			end
		end
	end
	
	local function restoreNumTeamMembers()
		for label, data in pairs(deletedNumTeamMembers) do
			if data.Parent and data.Parent.Parent then
				local newLabel = Instance.new("TextLabel")
				newLabel.Name = data.Name
				newLabel.Text = data.Text
				newLabel.Position = data.Position
				newLabel.Size = data.Size
				newLabel.Visible = data.Visible
				newLabel.Parent = data.Parent
			end
		end
		table.clear(deletedNumTeamMembers)
	end
	
	OG4v4v4v4 = vape.Categories.Render:CreateModule({
		Name = 'OG 4v4v4v4',
		Function = function(callback)
			if callback then
				local OrangeMaterial = Instance.new('MaterialVariant')
				OrangeMaterial.Parent = cloneref(game:GetService('MaterialService'))
				OrangeMaterial.Name = 'rbxassetid://16991768606_red'
				OrangeMaterial.ColorMap = 'rbxassetid://16991768606'
				OrangeMaterial.StudsPerTile = 3
				OrangeMaterial.RoughnessMap = 'rbxassetid://16991768606'
				OrangeMaterial.BaseMaterial = 'Fabric'
				
				local PinkMaterial = Instance.new('MaterialVariant')
				PinkMaterial.Parent = cloneref(game:GetService('MaterialService'))
				PinkMaterial.Name = 'rbxassetid://16991768606_green'
				PinkMaterial.ColorMap = 'rbxassetid://16991768606'
				PinkMaterial.StudsPerTile = 3
				PinkMaterial.RoughnessMap = 'rbxassetid://16991768606'
				PinkMaterial.BaseMaterial = 'Fabric'
				
				local topBarGui = lplr.PlayerGui:FindFirstChild('TopBarAppGui')
				if topBarGui then
					removeNumTeamMembers(topBarGui)
				end
				
				OG4v4v4v4:Clean(lplr.PlayerGui.ChildAdded:Connect(function(gui)
					if gui.Name == "TopBarAppGui" then
						removeNumTeamMembers(gui)
						
						OG4v4v4v4:Clean(gui.DescendantAdded:Connect(function(descendant)
							if descendant:IsA("Frame") and 
							   (descendant.Name == "2" or descendant.Name == "3" or 
							    descendant.Name == "4" or descendant.Name == "5") then
								local frame4 = descendant.Parent
								if frame4 and frame4.Name == "4" then
									local frame5 = frame4.Parent
									if frame5 and frame5.Name == "5" then
										local topBarApp = frame5.Parent
										if topBarApp and topBarApp.Name == "TopBarApp" then
											task.wait(0.1) 
											local numLabel = descendant:FindFirstChild("NumTeamMembers")
											if numLabel and numLabel:IsA("TextLabel") then
												deletedNumTeamMembers[numLabel] = {
													Parent = numLabel.Parent,
													Name = numLabel.Name,
													Text = numLabel.Text,
													Position = numLabel.Position,
													Size = numLabel.Size,
													Visible = numLabel.Visible
												}
												numLabel:Destroy()
											end
										end
									end
								end
							end
						end))
					end
				end))
				
				local viewmodel = gameCamera:FindFirstChild("Viewmodel")
				if viewmodel then
					OG4v4v4v4:Clean(viewmodel.ChildAdded:Connect(function(obj)
						if obj.Name == "wool_orange" then
							task.wait(0.01)
							if obj:FindFirstChild('Handle') then
								for i, texture in obj:FindFirstChild('Handle'):GetChildren() do
									if texture:IsA('Texture') then
										oldTexture[texture] = texture.Texture
										oldColor[texture] = texture.Color3
										texture.Texture = "rbxassetid://16991768606"
										texture.Color3 = Color3.fromRGB(196, 40, 28)
									end
								end
							end
						elseif obj.Name == "wool_pink" then
							task.wait(0.01)
							if obj:FindFirstChild('Handle') then
								for i, texture in obj:FindFirstChild('Handle'):GetChildren() do
									if texture:IsA('Texture') then
										oldTexture[texture] = texture.Texture
										oldColor[texture] = texture.Color3
										texture.Texture = "rbxassetid://16991768606"
										texture.Color3 = Color3.fromRGB(15, 185, 55)
									end
								end
							end
						end
					end))
				end
				
				OG4v4v4v4:Clean(lplr.Character.ChildAdded:Connect(function(obj)
					if obj.Name == "wool_orange" then
						task.wait(0.01)
						if obj:FindFirstChild('Handle') then
							for i, texture in obj:FindFirstChild('Handle'):GetChildren() do
								if texture:IsA('Texture') then
									oldTexture[texture] = texture.Texture
									oldColor[texture] = texture.Color3
									texture.Texture = "rbxassetid://16991768606"
									texture.Color3 = Color3.fromRGB(196, 40, 28)
								end
							end
						end
					elseif obj.Name == "wool_pink" then
						task.wait(0.01)
						if obj:FindFirstChild('Handle') then
							for i, texture in obj:FindFirstChild('Handle'):GetChildren() do
								if texture:IsA('Texture') then
									oldTexture[texture] = texture.Texture
									oldColor[texture] = texture.Color3
									texture.Texture = "rbxassetid://16991768606"
									texture.Color3 = Color3.fromRGB(15, 185, 55)
								end
							end
						end
					end
				end))
				
				OG4v4v4v4:Clean(blocks.ChildAdded:Connect(function(obj)
					if obj.Name == "wool_orange" and isValidWoolBlock(obj) then
						OldMaterials[obj] = obj.MaterialVariant
						OldColors[obj] = obj.Color
						obj.MaterialVariant = 'rbxassetid://16991768606_red'
						obj.Color = Color3.fromRGB(196, 40, 28)
					elseif obj.Name == "wool_pink" and isValidWoolBlock(obj) then
						OldMaterials[obj] = obj.MaterialVariant
						OldColors[obj] = obj.Color
						obj.MaterialVariant = 'rbxassetid://16991768606_green'
						obj.Color = Color3.fromRGB(15, 185, 55)
					end
				end))
				
				OG4v4v4v4:Clean(workspace.ChildAdded:Connect(function(obj)
					if obj.Name == "wool_orange" and isValidWoolBlock(obj) then
						OldMaterials[obj] = obj.MaterialVariant
						OldColors[obj] = obj.Color
						obj.MaterialVariant = 'rbxassetid://16991768606_red'
						obj.Color = Color3.fromRGB(196, 40, 28)
					elseif obj.Name == "wool_pink" and isValidWoolBlock(obj) then
						OldMaterials[obj] = obj.MaterialVariant
						OldColors[obj] = obj.Color
						obj.MaterialVariant = 'rbxassetid://16991768606_green'
						obj.Color = Color3.fromRGB(15, 185, 55)
					end
				end))
				
				for _, obj in blocks:GetChildren() do
					if obj.Name == "wool_orange" and isValidWoolBlock(obj) then
						OldMaterials[obj] = obj.MaterialVariant
						OldColors[obj] = obj.Color
						obj.MaterialVariant = 'rbxassetid://16991768606_red'
						obj.Color = Color3.fromRGB(196, 40, 28)
					elseif obj.Name == "wool_pink" and isValidWoolBlock(obj) then
						OldMaterials[obj] = obj.MaterialVariant
						OldColors[obj] = obj.Color
						obj.MaterialVariant = 'rbxassetid://16991768606_green'
						obj.Color = Color3.fromRGB(15, 185, 55)
					end
				end
				
				task.spawn(function()
					while OG4v4v4v4.Enabled do
						local topBarGui = lplr.PlayerGui:FindFirstChild('TopBarAppGui')
						if topBarGui then
							for i, v in topBarGui:GetDescendants() do
								if v:IsA("Frame") and v.Name == "3" then
									if v.BackgroundColor3 == Color3.fromRGB(242, 142, 41) then
										v.BackgroundColor3 = Color3.fromRGB(196, 40, 28)
										if v.Parent then
											for _, sibling in v.Parent:GetChildren() do
												if sibling:IsA("UIStroke") then
													sibling.Color = Color3.fromRGB(196, 40, 28)
												end
											end
										end
									elseif v.BackgroundColor3 == Color3.fromRGB(255, 102, 204) or 
										   v.BackgroundColor3 == Color3.fromRGB(255, 85, 255) or 
										   v.BackgroundColor3 == Color3.fromRGB(218, 133, 222) then
										v.BackgroundColor3 = Color3.fromRGB(15, 185, 55)
										if v.Parent then
											for _, sibling in v.Parent:GetChildren() do
												if sibling:IsA("UIStroke") then
													sibling.Color = Color3.fromRGB(15, 185, 55)
												end
											end
										end
									end
								end
							end
						end
						task.wait(0.015)
					end
				end)
				
				OG4v4v4v4:Clean(lplr.PlayerGui.ChildAdded:Connect(function(obj)
					if obj.Name == "TabListScreenGui" then
						for i, v in obj:GetDescendants() do
							if v:IsA("Frame") and v.Name == "2" then
								if v.BackgroundColor3 == Color3.fromRGB(242, 142, 41) then
									v.BackgroundColor3 = Color3.fromRGB(196, 40, 28)
									if v.Parent then
										for _, sibling in v.Parent:GetChildren() do
											if sibling:IsA("UIStroke") then
												sibling.Color = Color3.fromRGB(196, 40, 28)
											end
										end
									end
									if v:FindFirstChild("TeamName") then
										v:FindFirstChild("TeamName").RichText = true
										v:FindFirstChild("TeamName").Text = "<b>Red Team</b>"
									end
								elseif v.BackgroundColor3 == Color3.fromRGB(255, 102, 204) or 
									   v.BackgroundColor3 == Color3.fromRGB(255, 85, 255) or 
									   v.BackgroundColor3 == Color3.fromRGB(218, 133, 222) then
									v.BackgroundColor3 = Color3.fromRGB(15, 185, 55)
									if v.Parent then
										for _, sibling in v.Parent:GetChildren() do
											if sibling:IsA("UIStroke") then
												sibling.Color = Color3.fromRGB(15, 185, 55)
											end
										end
									end
									if v:FindFirstChild("TeamName") then
										v:FindFirstChild("TeamName").RichText = true
										v:FindFirstChild("TeamName").Text = "<b>Green Team</b>"
									end
								end
							end
						end
					end
				end))
			else
				for i, v in lplr.PlayerGui:FindFirstChild('TopBarAppGui'):GetDescendants() do
					if v:IsA("Frame") and v.Name == "3" then
						if v.BackgroundColor3 == Color3.fromRGB(196, 40, 28) then
							v.BackgroundColor3 = Color3.fromRGB(242, 142, 41)
							if v.Parent then
								for _, sibling in v.Parent:GetChildren() do
									if sibling:IsA("UIStroke") then
										sibling.Color = Color3.fromRGB(242, 142, 41)
									end
								end
							end
						elseif v.BackgroundColor3 == Color3.fromRGB(15, 185, 55) then
							v.BackgroundColor3 = Color3.fromRGB(255, 102, 204)
							if v.Parent then
								for _, sibling in v.Parent:GetChildren() do
									if sibling:IsA("UIStroke") then
										sibling.Color = Color3.fromRGB(255, 102, 204)
									end
								end
							end
						end
					end
				end
				
				restoreNumTeamMembers()
				
				for texture, oldTex in pairs(oldTexture) do
					if texture and texture.Parent then
						texture.Texture = oldTex
					end
				end
				for texture, oldCol in pairs(oldColor) do
					if texture and texture.Parent then
						texture.Color3 = oldCol
					end
				end
				
				for obj, oldMaterial in pairs(OldMaterials) do
					if obj and obj.Parent then
						obj.MaterialVariant = oldMaterial
						if OldColors[obj] then
							obj.Color = OldColors[obj]
						end
					end
				end
				
				table.clear(OldMaterials)
				table.clear(OldColors)
				table.clear(oldTexture)
				table.clear(oldColor)
			end
		end,
		Tooltip = 'OG team colors: Orange->Red, Pink->Dark Green + Remove NumTeamMembers'
	})
end)

run(function()
	local NoNameTag
	local originalNametags = {}
	local nametagConnection = nil
	local playerConnections = {}
	
	local function removeNametag(character)
		if not NoNameTag or not NoNameTag.Enabled then return end
		if not character then return end
		
		local head = character:FindFirstChild("Head")
		if not head then return end
		
		pcall(function()
			local nametag = head:FindFirstChild('Nametag')
			if nametag then
				if not originalNametags[character] then
					originalNametags[character] = nametag:Clone()
				end
				nametag:Destroy()
			end
		end)
	end
	
	local function restoreNametag(character)
		if not character then return end
		
		local head = character:FindFirstChild("Head")
		if not head then return end
		
		pcall(function()
			local existing = head:FindFirstChild('Nametag')
			if existing then
				existing:Destroy()
			end
			
			if originalNametags[character] then
				local restoredTag = originalNametags[character]:Clone()
				restoredTag.Parent = head
				restoredTag.Visible = true
				originalNametags[character] = nil
			end
		end)
	end
	
	NoNameTag = vape.Categories.Utility:CreateModule({
		Name = 'NoNameTag',
		Tooltip = 'Removes nametags for all players',
		Function = function(callback)
			if callback then
				nametagConnection = runService.RenderStepped:Connect(function()
					pcall(function()
						for _, player in playersService:GetPlayers() do
							if player.Character then
								removeNametag(player.Character)
							end
						end
						
						for _, entity in collectionService:GetTagged("entity") do
							if entity:IsA("Model") then
								removeNametag(entity)
							end
						end
					end)
				end)
				
				for _, player in playersService:GetPlayers() do
					if player.Character then
						removeNametag(player.Character)
					end
					
					local charConn = player.CharacterAdded:Connect(function(character)
						task.wait(0.5)
						if NoNameTag.Enabled then
							removeNametag(character)
						end
					end)
					table.insert(playerConnections, charConn)
				end
				
				local playerAddedConn = playersService.PlayerAdded:Connect(function(player)
					if player.Character then
						removeNametag(player.Character)
					end
					
					local charConn = player.CharacterAdded:Connect(function(character)
						task.wait(0.5)
						if NoNameTag.Enabled then
							removeNametag(character)
						end
					end)
					table.insert(playerConnections, charConn)
				end)
				table.insert(playerConnections, playerAddedConn)
				
			else
				if nametagConnection then
					nametagConnection:Disconnect()
					nametagConnection = nil
				end
				
				for _, conn in pairs(playerConnections) do
					if conn then
						conn:Disconnect()
					end
				end
				table.clear(playerConnections)
				
				for _, player in playersService:GetPlayers() do
					if player.Character then
						restoreNametag(player.Character)
					end
				end
				
				for _, entity in collectionService:GetTagged("entity") do
					if entity:IsA("Model") then
						restoreNametag(entity)
					end
				end
				
				table.clear(originalNametags)
			end
		end,
	})
end)

run(function()
    local OGNametags
    local storedNametags = {}
    local connections = {}
    local ActiveTags = {}
    local CLAN_GRAY = "#B9B9B9"
    local HideOwnNametag
    local DotSizeSlider
    local DotPositionSlider

    local function getClan(player)
        if not player then return "" end
        return player:GetAttribute("ClanTag") or player:GetAttribute("Clan") or ""
    end

    local function removeOtherNameTags(char)
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then
            hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
            hum.NameDisplayDistance = 0
        end
        local head = char:FindFirstChild("Head")
        if not head then return end
        for _, child in head:GetChildren() do
            if child:IsA("BillboardGui") and child.Name ~= "OGNametag" and child.Name ~= "Nametag" then
                child:Destroy()
            end
        end
    end

    local function getNameColor(player, entity)
        if not player then return Color3.fromRGB(255, 255, 255) end
        local localPlayer = playersService.LocalPlayer
        local localTeamId = localPlayer and localPlayer:GetAttribute("Team")
        local playerTeamId = player:GetAttribute("Team") or (entity and entity:GetAttribute("Team"))
        if localTeamId and playerTeamId and localTeamId == playerTeamId then
            return Color3.fromRGB(90, 255, 90)
        end
        return Color3.fromRGB(255, 80, 80)
    end

    local function getTeamColor(player, entity)
        local teamId = player and player:GetAttribute("Team") or (entity and entity:GetAttribute("Team"))
        if teamId then
            local success, KnitClient = pcall(function()
                return require(replicatedStorage['rbxts_include']['node_modules']['@easy-games']['knit'].src).KnitClient
            end)
            if success and KnitClient and KnitClient.Controllers and KnitClient.Controllers.TeamController then
                local team = KnitClient.Controllers.TeamController:getTeamById(teamId)
                if team and team.color then
                    local teamColor = team.color
                    if teamColor == Color3.fromRGB(255, 102, 204) or
                       teamColor == Color3.fromRGB(255, 85, 255) or
                       teamColor == Color3.fromRGB(218, 133, 222) then
                        return Color3.fromRGB(90, 255, 90)
                    elseif teamColor == Color3.fromRGB(255, 106, 0) or
                           teamColor == Color3.fromRGB(255, 85, 0) then
                        return Color3.fromRGB(255, 80, 80)
                    elseif teamColor == Color3.fromRGB(0, 85, 255) or
                           teamColor == Color3.fromRGB(0, 102, 255) then
                        return Color3.fromRGB(80, 160, 255)
                    elseif teamColor == Color3.fromRGB(255, 255, 0) or
                           teamColor == Color3.fromRGB(255, 255, 85) then
                        return Color3.fromRGB(255, 220, 80)
                    else
                        return teamColor
                    end
                end
            end
        end
        return Color3.fromRGB(255, 255, 255)
    end

    local function create(className, props)
        local obj = Instance.new(className)
        for k, v in pairs(props) do
            obj[k] = v
        end
        return obj
    end

    local function makeDot(parent, teamDotColor, dotSize, dotPosition)
        local Dot = create("Frame", {
            Parent = parent,
            BackgroundColor3 = teamDotColor,
            BackgroundTransparency = 0.1,
            Position = UDim2.fromScale(0.02, dotPosition),
            Size = UDim2.fromScale(dotSize, 0.80),
            BorderSizePixel = 0
        })
        create("UICorner", {Parent = Dot, CornerRadius = UDim.new(1, 0)})
        create("UISizeConstraint", {
            Parent = Dot,
            MinSize = Vector2.new(6, 6),
            MaxSize = Vector2.new(40, 40)
        })
        return Dot
    end

    local function CreateLocalPlayerTag(player, character)
        if not OGNametags or not OGNametags.Enabled then return end
        if not character then return end
        if HideOwnNametag and HideOwnNametag.Enabled then return end

        local head = character:FindFirstChild("Head")
        if not head then return end

        removeOtherNameTags(character)

        local originalNametag = head:FindFirstChild("Nametag")
        if originalNametag then
            storedNametags[character] = originalNametag:Clone()
            originalNametag:Destroy()
        end

        local oldOGNametag = head:FindFirstChild("OGNametag")
        if oldOGNametag then oldOGNametag:Destroy() end

        local clan = getClan(player)
        local nameColor = getNameColor(player, character)
        local teamDotColor = getTeamColor(player, character)
        local dotSize = DotSizeSlider and DotSizeSlider.Value or 0.14
        local dotPosition = DotPositionSlider and DotPositionSlider.Value or 0.10

        local billui = create("BillboardGui", {
            Name = "OGNametag",
            AlwaysOnTop = false,
            Parent = head,
            Size = UDim2.fromScale(5.35, 0.6),
            StudsOffsetWorldSpace = Vector3.new(0, 1.6, 0),
            Adornee = head
        })

        local Main = create("Frame", {
            Parent = billui,
            BackgroundTransparency = 1,
            Size = UDim2.fromScale(1, 1)
        })

        local Dot = makeDot(Main, teamDotColor, dotSize, dotPosition)

        local Bar = create("Frame", {
            Parent = Main,
            BackgroundColor3 = Color3.new(0, 0, 0),
            BackgroundTransparency = 0.65,
            Position = UDim2.fromScale(0.19, 0.14),
            Size = UDim2.fromScale(0.82, 0.72),
            BorderSizePixel = 0
        })
        create("UICorner", {Parent = Bar, CornerRadius = UDim.new(0, 0)})

        local Stroke = create("UIStroke", {
            Parent = Bar,
            Color = nameColor,
            Thickness = 1.2,
            Transparency = 0.3
        })

        local Txt = create("TextLabel", {
            Parent = Bar,
            BackgroundTransparency = 1,
            Size = UDim2.fromScale(0.99, 1.15),
            Position = UDim2.fromScale(0.5, 0.5),
            AnchorPoint = Vector2.new(0.5, 0.5),
            Font = Enum.Font.GothamMedium,
            TextScaled = true,
            RichText = true,
            TextXAlignment = Enum.TextXAlignment.Center,
            TextYAlignment = Enum.TextYAlignment.Center
        })

        local displayName = player.DisplayName ~= "" and player.DisplayName or player.Name

        if clan ~= "" then
            Txt.Text = string.format(
                '<font color="%s" size="140">[%s]</font>&nbsp;<font color="rgb(%d,%d,%d)" size="130">%s</font>',
                CLAN_GRAY, clan,
                nameColor.R * 255, nameColor.G * 255, nameColor.B * 255,
                displayName
            )
        else
            Txt.Text = string.format(
                '<font color="rgb(%d,%d,%d)" size="130">%s</font>',
                nameColor.R * 255, nameColor.G * 255, nameColor.B * 255,
                displayName
            )
        end

        ActiveTags[player] = {bill = billui, bar = Bar, dot = Dot, stroke = Stroke, txt = Txt}
    end

    local function CreateOtherPlayerTag(player, character)
        if not OGNametags or not OGNametags.Enabled then return end
        if not character then return end

        local head = character:FindFirstChild("Head")
        if not head then return end

        removeOtherNameTags(character)

        local originalNametag = head:FindFirstChild("Nametag")
        if originalNametag then
            storedNametags[character] = originalNametag:Clone()
            originalNametag:Destroy()
        end

        local oldOGNametag = head:FindFirstChild("OGNametag")
        if oldOGNametag then oldOGNametag:Destroy() end

        local nameColor = getNameColor(player, character)
        local teamDotColor = getTeamColor(player, character)
        local clan = getClan(player)
        local dotSize = DotSizeSlider and DotSizeSlider.Value or 0.14
        local dotPosition = DotPositionSlider and DotPositionSlider.Value or 0.10

        local billui = create("BillboardGui", {
            Name = "OGNametag",
            AlwaysOnTop = false,
            Parent = head,
            Size = UDim2.fromScale(5.35, 0.6),
            StudsOffsetWorldSpace = Vector3.new(0, 1.6, 0),
            Adornee = head
        })

        local Main = create("Frame", {
            Parent = billui,
            BackgroundTransparency = 1,
            Size = UDim2.fromScale(1, 1)
        })

        local Dot = makeDot(Main, teamDotColor, dotSize, dotPosition)

        local Bar = create("Frame", {
            Parent = Main,
            BackgroundColor3 = Color3.new(0, 0, 0),
            BackgroundTransparency = 0.65,
            Position = UDim2.fromScale(0.19, 0.14),
            Size = UDim2.fromScale(0.82, 0.72),
            BorderSizePixel = 0
        })
        create("UICorner", {Parent = Bar, CornerRadius = UDim.new(0, 0)})

        local Stroke = create("UIStroke", {
            Parent = Bar,
            Color = nameColor,
            Thickness = 1.2,
            Transparency = 0.3
        })

        local Txt = create("TextLabel", {
            Parent = Bar,
            BackgroundTransparency = 1,
            Size = UDim2.fromScale(0.99, 1.15),
            Position = UDim2.fromScale(0.5, 0.5),
            AnchorPoint = Vector2.new(0.5, 0.5),
            Font = Enum.Font.GothamMedium,
            TextScaled = true,
            RichText = true,
            TextXAlignment = Enum.TextXAlignment.Center,
            TextYAlignment = Enum.TextYAlignment.Center
        })

        local displayName = player and (player.DisplayName ~= "" and player.DisplayName or player.Name) or character.Name

        if clan ~= "" then
            Txt.Text = string.format(
                '<font color="%s" size="140">[%s]</font>&nbsp;<font color="rgb(%d,%d,%d)" size="130">%s</font>',
                CLAN_GRAY, clan,
                nameColor.R * 255, nameColor.G * 255, nameColor.B * 255,
                displayName
            )
        else
            Txt.Text = string.format(
                '<font color="rgb(%d,%d,%d)" size="130">%s</font>',
                nameColor.R * 255, nameColor.G * 255, nameColor.B * 255,
                displayName
            )
        end

        ActiveTags[player or character] = {bill = billui, bar = Bar, dot = Dot, stroke = Stroke, txt = Txt}
    end

    local function createOGNametag(character)
        if not OGNametags or not OGNametags.Enabled then return end
        if not character then return end

        task.wait(0.25)

        local player = playersService:GetPlayerFromCharacter(character)
        local localPlayer = playersService.LocalPlayer

        if player == localPlayer then
            CreateLocalPlayerTag(player, character)
        else
            CreateOtherPlayerTag(player, character)
        end
    end

    OGNametags = vape.Categories.Render:CreateModule({
        Name = "OG Nametags",
        Function = function(callback)
            if callback then
                for _, player in playersService:GetPlayers() do
                    if player.Character then
                        createOGNametag(player.Character)
                    end
                    local charAddedConn = player.CharacterAdded:Connect(function(character)
                        createOGNametag(character)
                    end)
                    table.insert(connections, charAddedConn)
                end

                for _, entity in collectionService:GetTagged("entity") do
                    if entity:IsA("Model") then
                        createOGNametag(entity)
                    end
                end

                local playerAddedConn = playersService.PlayerAdded:Connect(function(player)
                    if player.Character then
                        createOGNametag(player.Character)
                    end
                    local charAddedConn = player.CharacterAdded:Connect(function(character)
                        createOGNametag(character)
                    end)
                    table.insert(connections, charAddedConn)
                end)
                table.insert(connections, playerAddedConn)

                local entityAddedConn = collectionService:GetInstanceAddedSignal("entity"):Connect(function(entity)
                    if entity:IsA("Model") then
                        createOGNametag(entity)
                    end
                end)
                table.insert(connections, entityAddedConn)

            else
                for _, conn in connections do
                    if conn then conn:Disconnect() end
                end
                table.clear(connections)
                table.clear(ActiveTags)

                for _, player in playersService:GetPlayers() do
                    if player.Character then
                        local head = player.Character:FindFirstChild("Head")
                        if head then
                            local ogNametag = head:FindFirstChild("OGNametag")
                            if ogNametag then ogNametag:Destroy() end
                            if storedNametags[player.Character] then
                                local restoredNametag = storedNametags[player.Character]:Clone()
                                restoredNametag.Parent = head
                                storedNametags[player.Character] = nil
                            end
                        end
                    end
                end

                for _, entity in collectionService:GetTagged("entity") do
                    if entity:IsA("Model") then
                        local head = entity:FindFirstChild("Head")
                        if head then
                            local ogNametag = head:FindFirstChild("OGNametag")
                            if ogNametag then ogNametag:Destroy() end
                            if storedNametags[entity] then
                                local restoredNametag = storedNametags[entity]:Clone()
                                restoredNametag.Parent = head
                                storedNametags[entity] = nil
                            end
                        end
                    end
                end

                table.clear(storedNametags)
            end
        end,
        Tooltip = "OG BedWars nametags with Koli's UI"
    })

    HideOwnNametag = OGNametags:CreateToggle({
        Name = "Hide Self Nametag",
        Tooltip = "Removes your own nametag for cleaner screen",
        Default = true,
        Function = function(callback)
            if OGNametags.Enabled then
                local localPlayer = playersService.LocalPlayer
                if localPlayer and localPlayer.Character then
                    if callback then
                        local head = localPlayer.Character:FindFirstChild("Head")
                        if head then
                            local ogTag = head:FindFirstChild("OGNametag")
                            if ogTag then ogTag:Destroy() end
                        end
                    else
                        CreateLocalPlayerTag(localPlayer, localPlayer.Character)
                    end
                end
            end
        end
    })

    DotSizeSlider = OGNametags:CreateSlider({
        Name = "Dot Size",
        Min = 0.05,
        Max = 0.35,
        Default = 0.14,
        Decimal = 100,
        Suffix = "x",
        Tooltip = "Adjust the size of the colored team dot",
        Function = function(val)
            for _, tagData in pairs(ActiveTags) do
                if tagData and tagData.dot then
                    tagData.dot.Size = UDim2.fromScale(val, 0.80)
                    local constraint = tagData.dot:FindFirstChildOfClass("UISizeConstraint")
                    if constraint then
                        local px = math.round(val * 200)
                        constraint.MinSize = Vector2.new(px * 0.4, px * 0.4)
                        constraint.MaxSize = Vector2.new(px * 1.6, px * 1.6)
                    end
                end
            end
        end
    })

    DotPositionSlider = OGNametags:CreateSlider({
        Name = "Dot Position",
        Min = 0.01,
        Max = 0.30,
        Default = 0.10,
        Decimal = 100,
        Tooltip = "Move the dot up or down",
        Function = function(val)
            for _, tagData in pairs(ActiveTags) do
                if tagData and tagData.dot then
                    tagData.dot.Position = UDim2.fromScale(0.02, val)
                end
            end
        end
    })

end)

run(function()
	local WoolColorChanger
	local OldMaterials = {}
	local OldColors = {}
	local oldTexture = {}
	local oldColor = {}
	
	local function getWorldFolder()
		local Map = workspace:WaitForChild("Map", math.huge)
		local Worlds = Map:WaitForChild("Worlds", math.huge)
		if not Worlds then return nil end
		return Worlds:GetChildren()[1] 
	end
	
	local worldFolder = getWorldFolder()
	if not worldFolder then return end
	local blocks = worldFolder:WaitForChild("Blocks")
	
	local function isValidWoolBlock(obj)
		if not obj:IsA("BasePart") then
			return false
		end
		
		if obj.Name ~= "wool_orange" then
			return false
		end
		
		local parent = obj.Parent
		if parent then
			if parent.Name == "Viewmodel" or parent.Parent and parent.Parent.Name == "Viewmodel" then
				return false
			end
			
			if parent:IsA("Accessory") or parent:IsA("Tool") then
				return false
			end
			
			local ancestor = parent
			while ancestor do
				if ancestor:IsA("Model") and playersService:GetPlayerFromCharacter(ancestor) then
					return false
				end
				ancestor = ancestor.Parent
			end
		end
		
		return true
	end
	
	WoolColorChanger = vape.Categories.Render:CreateModule({
		Name = 'REDvsBLUE (wool)',
		Function = function(callback)
			if callback then
				local NewMaterial = Instance.new('MaterialVariant')
				NewMaterial.Parent = cloneref(game:GetService('MaterialService'))
				NewMaterial.Name = 'rbxassetid://16991768606'
				NewMaterial.ColorMap = 'rbxassetid://16991768606'
				NewMaterial.StudsPerTile = 3
				NewMaterial.RoughnessMap = 'rbxassetid://16991768606'
				NewMaterial.BaseMaterial = 'Fabric'
				
				WoolColorChanger:Clean(gameCamera:FindFirstChild("Viewmodel").ChildAdded:Connect(function(obj)
					if obj.Name == "wool_orange" then
						task.wait(0.01)
						if obj:FindFirstChild('Handle') then
							for i, texture in obj:FindFirstChild('Handle'):GetChildren() do
								if texture:IsA('Texture') then
									oldTexture[texture] = texture.Texture
									oldColor[texture] = texture.Color3
									texture.Texture = "rbxassetid://16991768606"
									texture.Color3 = Color3.fromRGB(196, 40, 28)
								end
							end
						end
					end
				end))
				
				WoolColorChanger:Clean(lplr.Character.ChildAdded:Connect(function(obj)
					if obj.Name == "wool_orange" then
						task.wait(0.01)
						if obj:FindFirstChild('Handle') then
							for i, texture in obj:FindFirstChild('Handle'):GetChildren() do
								if texture:IsA('Texture') then
									oldTexture[texture] = texture.Texture
									oldColor[texture] = texture.Color3
									texture.Texture = "rbxassetid://16991768606"
									texture.Color3 = Color3.fromRGB(196, 40, 28)
								end
							end
						end
					end
				end))
				
				WoolColorChanger:Clean(blocks.ChildAdded:Connect(function(obj)
					if obj.Name == "wool_orange" and isValidWoolBlock(obj) then
						OldMaterials[obj] = obj.MaterialVariant
						OldColors[obj] = obj.Color
						obj.MaterialVariant = 'rbxassetid://16991768606'
						obj.Color = Color3.fromRGB(196, 40, 28)
					end
				end))
				
				WoolColorChanger:Clean(workspace.ChildAdded:Connect(function(obj)
					if obj.Name == "wool_orange" and isValidWoolBlock(obj) then
						OldMaterials[obj] = obj.MaterialVariant
						OldColors[obj] = obj.Color
						obj.MaterialVariant = 'rbxassetid://16991768606'
						obj.Color = Color3.fromRGB(196, 40, 28)
					end
				end))
				
				for _, obj in blocks:GetChildren() do
					if obj.Name == "wool_orange" and isValidWoolBlock(obj) then
						OldMaterials[obj] = obj.MaterialVariant
						OldColors[obj] = obj.Color
						obj.MaterialVariant = 'rbxassetid://16991768606'
						obj.Color = Color3.fromRGB(196, 40, 28)
					end
				end
				
				task.spawn(function()
					while WoolColorChanger.Enabled do
						for i, v in lplr.PlayerGui:FindFirstChild('TopBarAppGui'):GetDescendants() do
							if v:IsA("Frame") and v.Name == "3" and v.BackgroundColor3 == Color3.fromRGB(242, 142, 41) then
								v.BackgroundColor3 = Color3.fromRGB(196, 40, 28)
								for _, child in v:GetDescendants() do
									if child:IsA("UIStroke") then
										child.Color = Color3.fromRGB(196, 40, 28)
									end
								end
							end
						end
						task.wait(0.015)
					end
				end)
				
				WoolColorChanger:Clean(lplr.PlayerGui.ChildAdded:Connect(function(obj)
					if obj.Name == "TabListScreenGui" then
						for i, v in obj:GetDescendants() do
							if v:IsA("Frame") and v.Name == "2" and v.BackgroundColor3 == Color3.fromRGB(242, 142, 41) then
								v.BackgroundColor3 = Color3.fromRGB(196, 40, 28)
								for _, child in v:GetDescendants() do
									if child:IsA("UIStroke") then
										child.Color = Color3.fromRGB(196, 40, 28)
									end
								end
								if v:FindFirstChild("TeamName") then
									v:FindFirstChild("TeamName").RichText = true
									v:FindFirstChild("TeamName").Text = "<b>Red Team</b>"
								end
							end
						end
					end
				end))
				
			else
				for i, v in lplr.PlayerGui:FindFirstChild('TopBarAppGui'):GetDescendants() do
					if v:IsA("Frame") and v.Name == "3" and v.BackgroundColor3 == Color3.fromRGB(196, 40, 28) then
						v.BackgroundColor3 = Color3.fromRGB(242, 142, 41)
						for _, child in v:GetDescendants() do
							if child:IsA("UIStroke") then
								child.Color = Color3.fromRGB(242, 142, 41)
							end
						end
					end
				end
				
				for texture, oldTex in pairs(oldTexture) do
					if texture and texture.Parent then
						texture.Texture = oldTex
					end
				end
				for texture, oldCol in pairs(oldColor) do
					if texture and texture.Parent then
						texture.Color3 = oldCol
					end
				end
				
				for obj, oldMaterial in pairs(OldMaterials) do
					if obj and obj.Parent then
						obj.MaterialVariant = oldMaterial
						if OldColors[obj] then
							obj.Color = OldColors[obj]
						end
					end
				end
				
				table.clear(OldMaterials)
				table.clear(OldColors)
				table.clear(oldTexture)
				table.clear(oldColor)
			end
		end,
		Tooltip = 'Changes orange wool blocks to red wool (instant, no flicker)'
	})
end)

run(function()
    local MetalDetector
    local CollectionToggle
    local LimitToItem
    local Animation
    local CollectionDelay
    local DelaySlider
    local RangeSlider
    local ESPToggle
    local ESPNotify
    local ESPBackground
    local ESPColor
    local HoldingCheck
    local DistanceCheck
    local DistanceLimit
    local Folder = Instance.new('Folder')
    Folder.Parent = vape.gui
    local Reference = {}
    local lastNotification = 0
    local spawnQueue = {}
    local notificationCooldown = 1
    local collectionActive = false
    local collectedMetals = {}
    local animationDebounce = {}

    local function isHoldingMetalDetector()
        if not store.hand or not store.hand.tool then return false end
        return store.hand.tool.Name == 'metal_detector'
    end

    local function sendNotification(count)
        notif("Metal ESP", string.format("%d metals spawned", count), 3)
    end

    local function processSpawnQueue()
        if #spawnQueue > 0 then
            local currentTime = tick()
            if currentTime - lastNotification >= notificationCooldown then
                sendNotification(#spawnQueue)
                lastNotification = currentTime
                spawnQueue = {}
            else
                task.delay(notificationCooldown - (currentTime - lastNotification), function()
                    if #spawnQueue > 0 then
                        sendNotification(#spawnQueue)
                        spawnQueue = {}
                    end
                end)
            end
        end
    end

    local function getProperImage()
        return bedwars.getIcon({itemType = 'iron'}, true)
    end

    local function Added(v)
        if Reference[v] then return end
        
        local billboard = Instance.new('BillboardGui')
        billboard.Parent = Folder
        billboard.Name = 'hidden-metal'
        billboard.StudsOffsetWorldSpace = Vector3.new(0, 3, 0)
        billboard.Size = UDim2.fromOffset(36, 36)
        billboard.AlwaysOnTop = true
        billboard.ClipsDescendants = false
        billboard.Adornee = v
        
        local blur = addBlur(billboard)
        blur.Visible = ESPBackground.Enabled
        
        local image = Instance.new('ImageLabel')
        image.Size = UDim2.fromOffset(36, 36)
        image.Position = UDim2.fromScale(0.5, 0.5)
        image.AnchorPoint = Vector2.new(0.5, 0.5)
        image.BackgroundColor3 = Color3.fromHSV(ESPColor.Hue, ESPColor.Sat, ESPColor.Value)
        image.BackgroundTransparency = 1 - (ESPBackground.Enabled and ESPColor.Opacity or 0)
        image.BorderSizePixel = 0
        image.Image = getProperImage()
        image.Parent = billboard
        
        local uicorner = Instance.new('UICorner')
        uicorner.CornerRadius = UDim.new(0, 4)
        uicorner.Parent = image
        
        Reference[v] = billboard
        
        if ESPNotify.Enabled then
            table.insert(spawnQueue, {item = 'metal', time = tick()})
            processSpawnQueue()
        end
    end

    local function Removed(v)
        if Reference[v] then
            Reference[v]:Destroy()
            Reference[v] = nil
        end
    end

    local function setupESP()
        for _, v in collectionService:GetTagged('hidden-metal') do
            if v:IsA("Model") and v.PrimaryPart then
                Added(v.PrimaryPart)
            end
        end

        MetalDetector:Clean(collectionService:GetInstanceAddedSignal('hidden-metal'):Connect(function(v)
            if v:IsA("Model") and v.PrimaryPart then
                task.wait(0.1)
                Added(v.PrimaryPart)
            end
        end))

        MetalDetector:Clean(collectionService:GetInstanceRemovedSignal('hidden-metal'):Connect(function(v)
            if v.PrimaryPart then
                Removed(v.PrimaryPart)
            end
        end))

        MetalDetector:Clean(runService.RenderStepped:Connect(function()
            if not ESPToggle.Enabled then return end
            
            for v, billboard in pairs(Reference) do
                if not v or not v.Parent then
                    Removed(v)
                    continue
                end

                local shouldShow = true

                if HoldingCheck.Enabled and not isHoldingMetalDetector() then
                    shouldShow = false
                end

                if shouldShow and DistanceCheck.Enabled and entitylib.isAlive then
                    local distance = (entitylib.character.RootPart.Position - v.Position).Magnitude
                    if distance < DistanceLimit.ValueMin or distance > DistanceLimit.ValueMax then
                        shouldShow = false
                    end
                end

                billboard.Enabled = shouldShow
            end
        end))
    end

    local function collectMetal(metalModel)
        local metalId = metalModel:GetAttribute('Id')
        if not metalId then return false end
        
        if collectedMetals[metalId] then return false end
        collectedMetals[metalId] = true
        
        if Animation.Enabled then
            local currentTick = tick()
            if not animationDebounce[metalId] or (currentTick - animationDebounce[metalId]) >= 0.5 then
                animationDebounce[metalId] = currentTick
                bedwars.GameAnimationUtil:playAnimation(lplr, bedwars.AnimationType.SHOVEL_DIG)
                bedwars.SoundManager:playSound(bedwars.SoundList.SNAP_TRAP_CONSUME_MARK)
            end
        end
        
        local success = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("node_modules"):WaitForChild("@rbxts"):WaitForChild("net"):WaitForChild("out"):WaitForChild("_NetManaged"):WaitForChild("CollectCollectableEntity"):FireServer({
                id = metalId
            })
        end)
        
        task.delay(2, function()
            collectedMetals[metalId] = nil
            animationDebounce[metalId] = nil
        end)
        
        return success
    end

    local function startAutoCollect()
        if collectionActive then return end
        collectionActive = true
        
        task.spawn(function()
            while MetalDetector.Enabled and CollectionToggle.Enabled and collectionActive do
                if not entitylib.isAlive then 
                    task.wait(0.5)
                    continue 
                end
                
                if LimitToItem.Enabled and not isHoldingMetalDetector() then 
                    task.wait(0.5)
                    continue 
                end
                
                local localPosition = entitylib.character.RootPart.Position
                local range = RangeSlider.Value
                local collectedThisCycle = false
                
                for _, v in collectionService:GetTagged('hidden-metal') do
                    if not MetalDetector.Enabled or not CollectionToggle.Enabled or not collectionActive then 
                        break 
                    end
                    
                    if v:IsA("Model") and v.PrimaryPart then
                        local metalPos = v.PrimaryPart.Position
                        local distance = (localPosition - metalPos).Magnitude
                        
                        if distance <= range then
                            if CollectionDelay.Enabled and DelaySlider.Value > 0 then
                                task.wait(DelaySlider.Value)
                            end
                            
                            if collectMetal(v) then
                                collectedThisCycle = true
                                task.wait(0.15) 
                            end
                        end
                    end
                end
                
                task.wait(collectedThisCycle and 0.3 or 0.5)
            end
            
            collectionActive = false
        end)
    end

    local function stopAutoCollect()
        collectionActive = false
        table.clear(collectedMetals)
        table.clear(animationDebounce)
    end

    MetalDetector = vape.Categories.Kits:CreateModule({
        Name = 'AutoMetal',
        Function = function(callback)
            if callback then
                if ESPToggle.Enabled then 
                    setupESP() 
                end
                
                if CollectionToggle.Enabled then
                    startAutoCollect()
                end
            else
                stopAutoCollect()
                Folder:ClearAllChildren()
                table.clear(Reference)
                table.clear(spawnQueue)
                lastNotification = 0
            end
        end,
        Tooltip = 'automatically collects hidden metal and esp'
    })
    
    CollectionToggle = MetalDetector:CreateToggle({
        Name = 'Auto Collect',
        Default = true,
        Tooltip = 'automatically collect metals',
        Function = function(callback)
            if LimitToItem and LimitToItem.Object then LimitToItem.Object.Visible = callback end
            if Animation and Animation.Object then Animation.Object.Visible = callback end
            if CollectionDelay and CollectionDelay.Object then CollectionDelay.Object.Visible = callback end
            if DelaySlider and DelaySlider.Object then DelaySlider.Object.Visible = (callback and CollectionDelay.Enabled) end
            if RangeSlider and RangeSlider.Object then RangeSlider.Object.Visible = callback end
            
            if MetalDetector.Enabled then
                if callback then
                    startAutoCollect()
                else
                    stopAutoCollect()
                end
            end
        end
    })
    
    LimitToItem = MetalDetector:CreateToggle({
        Name = 'Limit to Items',
        Default = true,
        Tooltip = 'only works when holding metal_detector'
    })
    
    Animation = MetalDetector:CreateToggle({
        Name = 'Animation',
        Default = true,
        Tooltip = 'play shovel dig animation and sound'
    })
    
    CollectionDelay = MetalDetector:CreateToggle({
        Name = 'Collection Delay',
        Default = false,
        Tooltip = 'add delay before collecting metal',
        Function = function(callback)
            if DelaySlider and DelaySlider.Object then
                DelaySlider.Object.Visible = callback
            end
        end
    })
    
    DelaySlider = MetalDetector:CreateSlider({
        Name = 'Delay',
        Min = 0,
        Max = 2,
        Default = 0.5,
        Decimal = 10,
        Suffix = 's',
        Tooltip = 'delay in seconds before collecting'
    })
    
    RangeSlider = MetalDetector:CreateSlider({
        Name = 'Range',
        Min = 1, 
        Max = 10,
        Default = 10,
        Decimal = 1,
        Suffix = ' studs',
        Tooltip = 'control distance you want to collect metal'
    })
    
    ESPToggle = MetalDetector:CreateToggle({
        Name = 'Metal ESP',
        Default = false,
        Tooltip = 'shows metal locations',
        Function = function(callback)
            if ESPNotify and ESPNotify.Object then ESPNotify.Object.Visible = callback end
            if ESPBackground and ESPBackground.Object then ESPBackground.Object.Visible = callback end
            if ESPColor and ESPColor.Object then ESPColor.Object.Visible = callback end
            if HoldingCheck and HoldingCheck.Object then HoldingCheck.Object.Visible = callback end
            if DistanceCheck and DistanceCheck.Object then DistanceCheck.Object.Visible = callback end
            if DistanceLimit and DistanceLimit.Object then
                DistanceLimit.Object.Visible = (callback and DistanceCheck.Enabled)
            end
            
            if MetalDetector.Enabled then
                if callback then setupESP() else
                    Folder:ClearAllChildren()
                    table.clear(Reference)
                end
            end
        end
    })
    
    ESPNotify = MetalDetector:CreateToggle({
        Name = 'Notify',
        Default = false,
        Tooltip = 'get notifications when metals spawn'
    })
    
    ESPBackground = MetalDetector:CreateToggle({
        Name = 'Background',
        Default = true,
        Function = function(callback)
            if ESPColor and ESPColor.Object then ESPColor.Object.Visible = callback end
            for _, v in Reference do
                if v and v:FindFirstChild("ImageLabel") then
                    local blur = v:FindFirstChild("BlurEffect")
                    if blur then blur.Visible = callback end
                    v.ImageLabel.BackgroundTransparency = 1 - (callback and ESPColor.Opacity or 0)
                end
            end
        end
    })
    
    ESPColor = MetalDetector:CreateColorSlider({
        Name = 'Background Color',
        DefaultValue = 0,
        DefaultOpacity = 0.5,
        Function = function(hue, sat, val, opacity)
            for _, v in Reference do
                if v and v:FindFirstChild("ImageLabel") then
                    v.ImageLabel.BackgroundColor3 = Color3.fromHSV(hue, sat, val)
                    v.ImageLabel.BackgroundTransparency = 1 - opacity
                end
            end
        end,
        Darker = true
    })
    
    HoldingCheck = MetalDetector:CreateToggle({
        Name = 'Holding Detector',
        Default = false,
        Tooltip = 'only show esp when holding metal detector'
    })
    
    DistanceCheck = MetalDetector:CreateToggle({
        Name = 'Distance Check',
        Default = false,
        Tooltip = 'only show metals within distance range',
        Function = function(callback)
            if DistanceLimit and DistanceLimit.Object then
                DistanceLimit.Object.Visible = callback
            end
        end
    })
    
    DistanceLimit = MetalDetector:CreateTwoSlider({
        Name = 'Metal Distance',
        Min = 0,
        Max = 256,
        DefaultMin = 0,
        DefaultMax = 64,
        Darker = true,
        Tooltip = 'distance range for showing metals'
    })
end)

run(function()
	local NoCollision
	local connections = {}
	local trackedParts = {}
	local lastWeaponState = nil
	local weaponCheckCounter = 0
	local validWeaponTypes = {
		sword = true,
		bow = true,
		crossbow = true,
		axe = true
	}
	
	local function removeCollision(character)
		if not character then return end
		
		local charParts = trackedParts[character]
		if not charParts then
			charParts = {}
			trackedParts[character] = charParts
			
			for _, part in character:GetDescendants() do
				if part:IsA("BasePart") then
					table.insert(charParts, part)
					part.CanCollide = false
					part.CanQuery = false
				end
			end
		else
			for _, part in charParts do
				if part and part.Parent then
					part.CanCollide = false
					part.CanQuery = false
				end
			end
		end
	end
	
	local function restoreCollision(character)
		if not character then return end
		
		local charParts = trackedParts[character]
		if charParts then
			for _, part in charParts do
				if part and part.Parent then
					part.CanCollide = true
					part.CanQuery = true
				end
			end
		else
			for _, part in character:GetDescendants() do
				if part:IsA("BasePart") then
					part.CanCollide = true
					part.CanQuery = true
				end
			end
		end
	end

	local function hasValidWeapon()
		if not store.hand or not store.hand.tool then return false end
		
		local toolType = store.hand.toolType
		
		if validWeaponTypes[toolType] then
			return true
		end
		
		local toolName = store.hand.tool.Name
		if toolName:find('headhunter') then
			return true
		end
		
		return false
	end

	local function updateAllCollisions(forceUpdate)
		weaponCheckCounter = weaponCheckCounter + 1
		local shouldCheck = forceUpdate or (weaponCheckCounter % 3 == 0)
		
		if not shouldCheck then return end
		
		local isWeaponEquipped = hasValidWeapon()
		
		if not forceUpdate and lastWeaponState == isWeaponEquipped then
			return
		end
		
		lastWeaponState = isWeaponEquipped
		
		for _, entity in entitylib.List do
			if entity.Character and entity.Character.Parent then
				if isWeaponEquipped then
					restoreCollision(entity.Character)
				else
					removeCollision(entity.Character)
				end
			end
		end
	end
	
	local motorParts = {}
	local function updateMotorParts()
		for _, entity in entitylib.List do
			if entity.Character then
				local charMotors = motorParts[entity.Character]
				
				if not charMotors then
					charMotors = {}
					motorParts[entity.Character] = charMotors
					
					for _, part in entity.Character:GetChildren() do
						if part:IsA("BasePart") and part.Name == "Part" and part:FindFirstChildOfClass("Motor6D") then
							table.insert(charMotors, part)
						end
					end
				end
				
				for _, part in charMotors do
					if part and part.Parent then
						part.CanCollide = false
					end
				end
			end
		end
	end
	
	NoCollision = vape.Categories.World:CreateModule({
		Name = 'NoCollision',
		Function = function(callback)
			if callback then
				local frameCounter = 0
				local heartbeatConn = runService.Heartbeat:Connect(function()
					if not NoCollision.Enabled then return end
					
					frameCounter = frameCounter + 1
					
					updateAllCollisions(false)
					
					if frameCounter % 5 == 0 then
						updateMotorParts()
					end
				end)
				table.insert(connections, heartbeatConn)
				
				lastWeaponState = hasValidWeapon()
				for _, entity in entitylib.List do
					if entity.Character and entity.Character.Parent then
						if not lastWeaponState then
							removeCollision(entity.Character)
						end
					end
				end
				
				local entityAddedConn = entitylib.Events.EntityAdded:Connect(function(entity)
					if not NoCollision.Enabled then return end
					if entity.Character then
						task.wait(0.05)
						if not hasValidWeapon() then
							removeCollision(entity.Character)
						end
					end
				end)
				table.insert(connections, entityAddedConn)
				
				local entityRemovedConn = entitylib.Events.EntityRemoved:Connect(function(entity)
					if entity.Character then
						trackedParts[entity.Character] = nil
						motorParts[entity.Character] = nil
					end
				end)
				table.insert(connections, entityRemovedConn)
				
				if vapeEvents and vapeEvents.InventoryChanged then
					local inventoryConn = vapeEvents.InventoryChanged.Event:Connect(function()
						if NoCollision.Enabled then
							updateAllCollisions(true)
						end
					end)
					table.insert(connections, inventoryConn)
				else
					local lastTool = store.hand and store.hand.tool
					local toolFrameCounter = 0
					local monitorConn = runService.Heartbeat:Connect(function()
						if not NoCollision.Enabled then return end
						
						toolFrameCounter = toolFrameCounter + 1
						if toolFrameCounter % 5 == 0 then
							local currentTool = store.hand and store.hand.tool
							if currentTool ~= lastTool then
								lastTool = currentTool
								updateAllCollisions(true)
							end
						end
					end)
					table.insert(connections, monitorConn)
				end
				
				updateAllCollisions(true)
			else
				for _, conn in connections do
					conn:Disconnect()
				end
				table.clear(connections)
				
				for _, entity in entitylib.List do
					if entity.Character then
						restoreCollision(entity.Character)
					end
				end
			
				table.clear(trackedParts)
				table.clear(motorParts)
				lastWeaponState = nil
				weaponCheckCounter = 0
			end
		end,
		Tooltip = 'Mine/build through players and NPCs'
	})
end)

run(function()
	local InfiniteJump
	local Mode
	local jumps = 0
	
	InfiniteJump = vape.Categories.Blatant:CreateModule({
		Name = "Infinite Jump",
		Tooltip = "jumpjumpjump",
		Function = function(callback)
			if callback then
				jumps = 0
				
				InfiniteJump:Clean(runService.Heartbeat:Connect(function()
					if entitylib.isAlive then
						local humanoid = entitylib.character.Humanoid
						if humanoid.FloorMaterial and humanoid.FloorMaterial ~= Enum.Material.Air then
							jumps = 0
						end
					end
				end))
				
				InfiniteJump:Clean(inputService.JumpRequest:Connect(function()
					if not entitylib.isAlive then return end
					
					jumps += 1
					
					if Mode.Value == "Velocity" then
						if jumps > 1 then
							local power = math.sqrt(2 * workspace.Gravity * entitylib.character.Humanoid.JumpHeight)
							entitylib.character.RootPart.Velocity = Vector3.new(entitylib.character.RootPart.Velocity.X, power, entitylib.character.RootPart.Velocity.Z)
						end
					elseif Mode.Value == "Jump" then
						if jumps > 1 then
							entitylib.character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
						end
					end
				end))
			end
		end,
		ExtraText = function() return Mode.Value end
	})
	
	Mode = InfiniteJump:CreateDropdown({
		Name = "Mode",
		List = {"Jump", "Velocity"},
		Default = "Velocity"
	})
end)

run(function()
	local TextureRemover
	local MaterialSelector
	local connections = {}
	local originalTextures = {}
	local isRestoring = false
	local processedObjects = {}
	
	local materialMap = {
		["SmoothPlastic"] = Enum.Material.SmoothPlastic,
		["Plastic"] = Enum.Material.Plastic,
		["Neon"] = Enum.Material.Neon,
		["ForceField"] = Enum.Material.ForceField,
		["Glass"] = Enum.Material.Glass
	}
	
	local function removeTextures(obj)
		if isRestoring or processedObjects[obj] then return end
		
		if obj.Name == "Nametag" and obj.Parent and obj.Parent.Name == "Head" and obj.Parent.Parent and obj.Parent.Parent:FindFirstChild("Humanoid") then
			return
		end
		
		if obj:IsA("BasePart") then
			if not originalTextures[obj] then
				originalTextures[obj] = {
					Material = obj.Material,
					TextureID = obj:IsA("MeshPart") and obj.TextureID or nil
				}
			end
			
			obj.Material = materialMap[MaterialSelector.Value] or Enum.Material.SmoothPlastic
			
			if obj:IsA("MeshPart") then
				obj.TextureID = ""
			end
			
			processedObjects[obj] = true
			
		elseif obj:IsA("Decal") or obj:IsA("Texture") then
			if not originalTextures[obj] then
				originalTextures[obj] = {
					Texture = obj.Texture,
					Transparency = obj.Transparency
				}
			end
			obj.Transparency = 1
			processedObjects[obj] = true
			
		elseif obj:IsA("SurfaceAppearance") then
			if not originalTextures[obj] then
				originalTextures[obj] = {
					ColorMap = obj.ColorMap or "",
					NormalMap = obj.NormalMap or "",
					RoughnessMap = obj.RoughnessMap or "",
					MetalnessMap = obj.MetalnessMap or ""
				}
			end
			obj.ColorMap = ""
			obj.NormalMap = ""
			obj.RoughnessMap = ""
			obj.MetalnessMap = ""
			processedObjects[obj] = true
		end
	end
	
	local function cleanupDestroyedObjects()
		for obj, _ in pairs(originalTextures) do
			if not obj or not obj.Parent then
				originalTextures[obj] = nil
				processedObjects[obj] = nil
			end
		end
	end
	
	local function processWorkspace()
		local descendants = workspace:GetDescendants()
		local batchSize = 50
		
		task.spawn(function()
			for i, obj in descendants do
				removeTextures(obj)
				
				if i % batchSize == 0 then
					task.wait()
				end
			end
		end)
	end
	
	TextureRemover = vape.Categories.BoostFPS:CreateModule({
		Name = 'Texture Remover',
		Function = function(callback)
			if callback then
				processWorkspace()
				
				local conn = workspace.DescendantAdded:Connect(function(obj)
					if TextureRemover.Enabled and not isRestoring then
						removeTextures(obj)
					end
				end)
				table.insert(connections, conn)
				
				local cleanupConn = runService.Heartbeat:Connect(function()
					if tick() % 30 < 0.016 then 
						cleanupDestroyedObjects()
					end
				end)
				table.insert(connections, cleanupConn)
				
			else
				isRestoring = true
				
				for obj, props in pairs(originalTextures) do
					if obj and obj.Parent then
						for prop, val in pairs(props) do
							if val ~= nil then
								pcall(function()
									obj[prop] = val
								end)
							end
						end
					end
				end
				
				for _, conn in connections do
					conn:Disconnect()
				end
				table.clear(connections)
				table.clear(originalTextures)
				table.clear(processedObjects)
				
				task.wait(0.1)
				isRestoring = false
			end
		end,
		Tooltip = 'Removes all textures and makes blocks a solid material for FPS boost'
	})
	
	MaterialSelector = TextureRemover:CreateDropdown({
		Name = 'Material',
		List = {'SmoothPlastic', 'Plastic', 'Neon', 'ForceField', 'Glass'},
		Default = 'SmoothPlastic',
		Tooltip = 'Choose what material to replace textures with',
		Function = function(val)
			if TextureRemover.Enabled then
				table.clear(processedObjects)
				processWorkspace()
			end
		end
	})
end)

run(function()
	local ParticleRemover
	local connections = {}
	local originalParticles = {}
	local processedParticles = {}
	
	local particleTypes = {
		ParticleEmitter = true,
		Trail = true,
		Beam = true,
		Fire = true,
		Smoke = true,
		Sparkles = true
	}
	
	local function removeParticle(obj)
		if processedParticles[obj] then return end
		
		local className = obj.ClassName
		if particleTypes[className] then
			if not originalParticles[obj] then
				originalParticles[obj] = obj.Enabled
			end
			obj.Enabled = false
			processedParticles[obj] = true
		end
	end
	
	ParticleRemover = vape.Categories.BoostFPS:CreateModule({
		Name = 'Particle Remover',
		Function = function(callback)
			if callback then
				local descendants = workspace:GetDescendants()
				
				task.spawn(function()
					for i, obj in descendants do
						removeParticle(obj)
						if i % 100 == 0 then
							task.wait()
						end
					end
				end)
				
				local conn = workspace.DescendantAdded:Connect(function(obj)
					if ParticleRemover.Enabled then
						removeParticle(obj)
					end
				end)
				table.insert(connections, conn)
			else
				for obj, enabled in pairs(originalParticles) do
					if obj and obj.Parent then
						pcall(function()
							obj.Enabled = enabled
						end)
					end
				end
				
				for _, conn in connections do
					conn:Disconnect()
				end
				table.clear(connections)
				table.clear(originalParticles)
				table.clear(processedParticles)
			end
		end,
		Tooltip = 'Removes all particle effects for FPS boost'
	})
end)

run(function()
	local ShadowRemover
	local connections = {}
	local originalShadows = {}
	local processedShadows = {}
	
	local function removeShadow(obj)
		if obj:IsA("BasePart") and not processedShadows[obj] then
			if not originalShadows[obj] then
				originalShadows[obj] = obj.CastShadow
			end
			obj.CastShadow = false
			processedShadows[obj] = true
		end
	end
	
	ShadowRemover = vape.Categories.BoostFPS:CreateModule({
		Name = 'Shadow Remover',
		Function = function(callback)
			if callback then
				local descendants = workspace:GetDescendants()
				
				task.spawn(function()
					for i, obj in descendants do
						removeShadow(obj)
						if i % 100 == 0 then
							task.wait()
						end
					end
				end)
				
				local conn = workspace.DescendantAdded:Connect(function(obj)
					if ShadowRemover.Enabled then
						removeShadow(obj)
					end
				end)
				table.insert(connections, conn)
			else
				for obj, shadow in pairs(originalShadows) do
					if obj and obj.Parent then
						pcall(function()
							obj.CastShadow = shadow
						end)
					end
				end
				
				for _, conn in connections do
					conn:Disconnect()
				end
				table.clear(connections)
				table.clear(originalShadows)
				table.clear(processedShadows)
			end
		end,
		Tooltip = 'Removes shadows from all parts for FPS boost'
	})
end)

run(function()
	local ArmorRemover
	local connections = {}
	local hiddenArmor = {}
	
	local function hideArmor(character)
		if not character or character == lplr.Character then return end
		
		for _, obj in character:GetDescendants() do
			if obj:IsA("Accessory") and not hiddenArmor[obj] then
				hiddenArmor[obj] = {
					Parent = obj.Parent,
					Character = character
				}
				obj.Parent = nil
			end
		end
	end
	
	ArmorRemover = vape.Categories.BoostFPS:CreateModule({
		Name = 'Armor Remover',
		Function = function(callback)
			if callback then
				for _, player in game.Players:GetPlayers() do
					if player ~= lplr then
						if player.Character then
							hideArmor(player.Character)
						end
						
						local charConn = player.CharacterAdded:Connect(function(char)
							if ArmorRemover.Enabled then
								task.wait(0.5)
								hideArmor(char)
							end
						end)
						table.insert(connections, charConn)
					end
				end
				
				local playerConn = game.Players.PlayerAdded:Connect(function(player)
					if player == lplr then return end
					
					local charConn = player.CharacterAdded:Connect(function(char)
						if ArmorRemover.Enabled then
							task.wait(0.5)
							hideArmor(char)
						end
					end)
					table.insert(connections, charConn)
				end)
				table.insert(connections, playerConn)
				
				local descConn = workspace.DescendantAdded:Connect(function(obj)
					if ArmorRemover.Enabled and obj:IsA("Accessory") then
						task.wait(0.1)
						local char = obj.Parent
						if char and char ~= lplr.Character and char:FindFirstChild("Humanoid") then
							hiddenArmor[obj] = {
								Parent = obj.Parent,
								Character = char
							}
							obj.Parent = nil
						end
					end
				end)
				table.insert(connections, descConn)
			else
				for obj, data in pairs(hiddenArmor) do
					if obj then
						pcall(function()
							if data.Parent and data.Parent.Parent then
								obj.Parent = data.Parent
							elseif data.Character and data.Character.Parent then
								obj.Parent = data.Character
							end
						end)
					end
				end
				
				for _, conn in connections do
					conn:Disconnect()
				end
				table.clear(connections)
				table.clear(hiddenArmor)
			end
		end,
		Tooltip = 'Hides armor visuals for FPS boost (armor still works)'
	})
end)

run(function()
	local PotatoMode
	local originalProperties = {}
	local blockMonitorConnections = {}
	local processedBlocks = {}
	
	local blockColors = {
		["wool_white"] = Color3.fromRGB(255, 255, 255),
		["wool_red"] = Color3.fromRGB(255, 50, 50),
		["wool_green"] = Color3.fromRGB(50, 255, 50),
		["wool_blue"] = Color3.fromRGB(50, 100, 255),
		["wool_yellow"] = Color3.fromRGB(255, 255, 50),
		["wool_orange"] = Color3.fromRGB(255, 150, 50),
		["wool_purple"] = Color3.fromRGB(180, 50, 255),
		["wool_pink"] = Color3.fromRGB(255, 100, 200),
		["wool_black"] = Color3.fromRGB(50, 50, 50),
		["wool_cyan"] = Color3.fromRGB(50, 255, 255),
		["wool_magenta"] = Color3.fromRGB(255, 50, 150),
		["wool_lime"] = Color3.fromRGB(150, 255, 50),
		["wool_brown"] = Color3.fromRGB(150, 75, 0),
		["wool_light_blue"] = Color3.fromRGB(100, 200, 255),
		["wool_gray"] = Color3.fromRGB(150, 150, 150),
		["clay"] = Color3.fromRGB(220, 180, 140),
		["wood"] = Color3.fromRGB(180, 140, 100),
		["stone"] = Color3.fromRGB(150, 150, 150),
		["glass"] = Color3.fromRGB(200, 220, 240),
		["planks"] = Color3.fromRGB(200, 170, 120),
		["plank"] = Color3.fromRGB(200, 170, 120),
		["end_stone"] = Color3.fromRGB(240, 230, 180),
		["obsidian"] = Color3.fromRGB(50, 30, 80),
		["bedrock"] = Color3.fromRGB(80, 80, 80),
		["tnt"] = Color3.fromRGB(255, 50, 50),
		["sandstone"] = Color3.fromRGB(220, 200, 150),
		["sand"] = Color3.fromRGB(220, 200, 150),
		["wool"] = Color3.fromRGB(200, 200, 200),
		["bed"] = Color3.fromRGB(200, 50, 50),
		["barrier"] = Color3.fromRGB(200, 200, 200),
		["magic"] = Color3.fromRGB(150, 100, 255),
		["concrete"] = Color3.fromRGB(180, 180, 180),
	}
	
	local cachedColors = {}
	
	local function getBlockColor(blockName)
		if cachedColors[blockName] then
			return cachedColors[blockName]
		end
		
		if blockColors[blockName] then
			cachedColors[blockName] = blockColors[blockName]
			return blockColors[blockName]
		end
		
		local lowerName = blockName:lower()
		
		if blockColors[lowerName] then
			cachedColors[blockName] = blockColors[lowerName]
			return blockColors[lowerName]
		end
		
		if lowerName:find("wool", 1, true) then 
			for key, color in pairs(blockColors) do
				if key:find("wool", 1, true) and lowerName:find(key, 1, true) then
					cachedColors[blockName] = color
					return color
				end
			end
			cachedColors[blockName] = blockColors["wool"]
			return blockColors["wool"]
		end
		
		for name, color in pairs(blockColors) do
			if lowerName:find(name, 1, true) then
				cachedColors[blockName] = color
				return color
			end
		end
		
		local defaultColor = Color3.fromRGB(150, 150, 150)
		cachedColors[blockName] = defaultColor
		return defaultColor
	end
	
	local function cleanupDeadReferences()
		for block, _ in pairs(originalProperties) do
			if not block or not block.Parent then
				originalProperties[block] = nil
				processedBlocks[block] = nil
			end
		end
	end
	
	local function simplifyBlock(block)
		if not block or not block.Parent or processedBlocks[block] then return end
		
		if not originalProperties[block] then
			originalProperties[block] = {
				Material = block.Material,
				Color = block.Color,
				TextureID = block:IsA("MeshPart") and block.TextureID or nil,
				Textures = {}
			}
			
			for _, child in block:GetChildren() do
				if child:IsA("Texture") or child:IsA("Decal") then
					table.insert(originalProperties[block].Textures, {
						Class = child.ClassName,
						Texture = child.Texture,
						StudsPerTileU = child.StudsPerTileU,
						StudsPerTileV = child.StudsPerTileV,
						Face = child.Face,
						Transparency = child.Transparency,
						Color3 = child:IsA("Decal") and child.Color3 or nil
					})
				end
			end
		end
		
		block.Material = Enum.Material.SmoothPlastic
		block.Color = getBlockColor(block.Name)
		
		for _, child in block:GetChildren() do
			if child:IsA("Texture") or child:IsA("Decal") then
				child:Destroy()
			end
		end
		
		if block:IsA("MeshPart") and block.TextureID ~= "" then
			block.TextureID = ""
		end
		
		processedBlocks[block] = true
	end
	
	local function restoreBlock(block)
		if not block or not block.Parent then 
			originalProperties[block] = nil
			processedBlocks[block] = nil
			return 
		end
		
		local props = originalProperties[block]
		if not props then return end
		
		block.Material = props.Material or Enum.Material.Plastic
		block.Color = props.Color or Color3.fromRGB(255, 255, 255)
		
		if props.TextureID and block:IsA("MeshPart") then
			block.TextureID = props.TextureID
		end
		
		for _, textureProps in props.Textures do
			local newTexture
			if textureProps.Class == "Texture" then
				newTexture = Instance.new("Texture")
				newTexture.StudsPerTileU = textureProps.StudsPerTileU or 1
				newTexture.StudsPerTileV = textureProps.StudsPerTileV or 1
			else
				newTexture = Instance.new("Decal")
				newTexture.Color3 = textureProps.Color3 or Color3.fromRGB(255, 255, 255)
			end
			
			newTexture.Texture = textureProps.Texture or ""
			newTexture.Face = textureProps.Face or Enum.NormalId.Front
			newTexture.Transparency = textureProps.Transparency or 0
			newTexture.Parent = block
		end
		
		originalProperties[block] = nil
		processedBlocks[block] = nil
	end
	
	local function isTargetBlock(obj)
		if not obj:IsA("BasePart") then return false end
		
		local name = obj.Name
		
		if blockColors[name] then return true end
		
		local lowerName = name:lower()
		return lowerName:find("wool", 1, true) or 
		       lowerName:find("clay", 1, true) or
		       lowerName:find("wood", 1, true) or 
		       lowerName:find("stone", 1, true) or 
		       lowerName:find("glass", 1, true) or
		       lowerName:find("plank", 1, true) or 
		       lowerName:find("bed", 1, true) or 
		       lowerName:find("obsidian", 1, true) or
		       lowerName:find("sand", 1, true) or 
		       lowerName:find("end", 1, true) or 
		       lowerName:find("tnt", 1, true) or
		       lowerName:find("barrier", 1, true) or 
		       lowerName:find("magic", 1, true) or 
		       lowerName:find("concrete", 1, true) or
		       lowerName:find("_block", 1, true) or 
		       obj:IsA("Seat")
	end
	
	local function processExistingBlocks(simplify)
		local descendants = workspace:GetDescendants()
		local batchSize = 50
		
		task.spawn(function()
			for i, obj in descendants do
				if isTargetBlock(obj) then
					if simplify then
						simplifyBlock(obj)
					else
						restoreBlock(obj)
					end
				end
				
				if i % batchSize == 0 then
					task.wait()
				end
			end
			
			if not simplify then
				cleanupDeadReferences()
			end
		end)
	end
	
	local function setupBlockMonitor(simplify)
		for _, conn in blockMonitorConnections do
			conn:Disconnect()
		end
		table.clear(blockMonitorConnections)
		
		if not simplify then return end
		
		local mainConn = workspace.DescendantAdded:Connect(function(descendant)
			if isTargetBlock(descendant) then
				simplifyBlock(descendant)
			end
		end)
		
		table.insert(blockMonitorConnections, mainConn)
		
		local cleanupConn = runService.Heartbeat:Connect(function()
			if tick() % 5 < 0.017 then
				cleanupDeadReferences()
			end
		end)
		
		table.insert(blockMonitorConnections, cleanupConn)
	end
	
	PotatoMode = vape.Categories.BoostFPS:CreateModule({
		Name = 'Potato Mode',
		Function = function(callback)
			if callback then
				processExistingBlocks(true)
				setupBlockMonitor(true)
			else
				processExistingBlocks(false)
				for _, conn in blockMonitorConnections do
					conn:Disconnect()
				end
				table.clear(blockMonitorConnections)
				table.clear(cachedColors)
				cleanupDeadReferences()
			end
		end,
		Tooltip = 'Removes block textures but keeps colors (like old FFlag) - No lighting changes'
	})
end)

run(function()
	local WhiteHits
	WhiteHits = vape.Categories.Legit:CreateModule({
		Name = "WhiteHits",
		Function = function(callback)
			repeat
				for i, v in entitylib.List do 
					local highlight = v.Character and v.Character:FindFirstChild('_DamageHighlight_')
					if highlight then 
						highlight.FillTransparency = 1
						if not highlight:GetAttribute("TransparencyHooked") then
							highlight:GetPropertyChangedSignal("FillTransparency"):Connect(function()
								highlight.FillTransparency = 1
							end)
							highlight:SetAttribute("TransparencyHooked", true)
						end
					end
				end
				task.wait(0.1)
			until not WhiteHits.Enabled
		end
	})
end)

run(function()
	local DamageHighlight
	local ColorPicker
	local FillTransparency
	local OutlineTransparency
	local hookedHighlights = {}
	
	DamageHighlight = vape.Categories.Legit:CreateModule({
		Name = "DamageHighlight",
		Function = function(callback)
			if callback then
				repeat
					for i, v in entitylib.List do 
						local highlight = v.Character and v.Character:FindFirstChild('_DamageHighlight_')
						if highlight and not hookedHighlights[highlight] then
							local color = Color3.fromHSV(ColorPicker.Hue, ColorPicker.Sat, ColorPicker.Value)
							highlight.FillColor = color
							highlight.OutlineColor = color
							highlight.FillTransparency = FillTransparency.Value
							highlight.OutlineTransparency = OutlineTransparency.Value
							
							highlight:GetPropertyChangedSignal("FillColor"):Connect(function()
								if DamageHighlight.Enabled then
									local customColor = Color3.fromHSV(ColorPicker.Hue, ColorPicker.Sat, ColorPicker.Value)
									highlight.FillColor = customColor
								end
							end)
							
							highlight:GetPropertyChangedSignal("OutlineColor"):Connect(function()
								if DamageHighlight.Enabled then
									local customColor = Color3.fromHSV(ColorPicker.Hue, ColorPicker.Sat, ColorPicker.Value)
									highlight.OutlineColor = customColor
								end
							end)
							
							highlight:GetPropertyChangedSignal("FillTransparency"):Connect(function()
								if DamageHighlight.Enabled then
									highlight.FillTransparency = FillTransparency.Value
								end
							end)
							
							highlight:GetPropertyChangedSignal("OutlineTransparency"):Connect(function()
								if DamageHighlight.Enabled then
									highlight.OutlineTransparency = OutlineTransparency.Value
								end
							end)
							
							hookedHighlights[highlight] = true
						elseif highlight and hookedHighlights[highlight] then
							local color = Color3.fromHSV(ColorPicker.Hue, ColorPicker.Sat, ColorPicker.Value)
							highlight.FillColor = color
							highlight.OutlineColor = color
							highlight.FillTransparency = FillTransparency.Value
							highlight.OutlineTransparency = OutlineTransparency.Value
						end
					end
					task.wait(0.1)
				until not DamageHighlight.Enabled
			else
				table.clear(hookedHighlights)
			end
		end,
		Tooltip = 'Customize damage highlight colors and transparency'
	})
	
	ColorPicker = DamageHighlight:CreateColorSlider({
		Name = 'Highlight Color',
		DefaultValue = 0,
		DefaultOpacity = 1,
		Tooltip = 'Color for damage highlights',
		Function = function()
			if DamageHighlight.Enabled then
				for i, v in entitylib.List do 
					local highlight = v.Character and v.Character:FindFirstChild('_DamageHighlight_')
					if highlight then
						local color = Color3.fromHSV(ColorPicker.Hue, ColorPicker.Sat, ColorPicker.Value)
						highlight.FillColor = color
						highlight.OutlineColor = color
					end
				end
			end
		end
	})
	
	FillTransparency = DamageHighlight:CreateSlider({
		Name = 'Fill Transparency',
		Min = 0,
		Max = 1,
		Default = 0.5,
		Decimal = 100,
		Tooltip = 'Transparency of the fill (0 = solid, 1 = invisible)',
		Function = function()
			if DamageHighlight.Enabled then
				for i, v in entitylib.List do 
					local highlight = v.Character and v.Character:FindFirstChild('_DamageHighlight_')
					if highlight then
						highlight.FillTransparency = FillTransparency.Value
					end
				end
			end
		end
	})
	
	OutlineTransparency = DamageHighlight:CreateSlider({
		Name = 'Outline Transparency',
		Min = 0,
		Max = 1,
		Default = 0,
		Decimal = 100,
		Tooltip = 'Transparency of the outline (0 = solid, 1 = invisible)',
		Function = function()
			if DamageHighlight.Enabled then
				for i, v in entitylib.List do 
					local highlight = v.Character and v.Character:FindFirstChild('_DamageHighlight_')
					if highlight then
						highlight.OutlineTransparency = OutlineTransparency.Value
					end
				end
			end
		end
	})
end)

run(function()
    local AutoLani
    local PlayerDropdown
    local RefreshButton
    local DelaySlider
    local AutoBuyToggle
    local GUICheck
    local DelayBuySlider
    local LimitItems
    local TargetModeDropdown
    local HealthActivationToggle
    local HealthThresholdSlider
    local TeammateHealthToggle
    local TeammateHealthSlider
    local running = false
    local buyRunning = false
    local buyLoopThread = nil
    
    local function getTeammateList()
        local teammates = {}
        local myTeam = lplr:GetAttribute('Team')
        
        if not myTeam then return {} end
        
        for _, player in playersService:GetPlayers() do
            if player ~= lplr then
                local playerTeam = player:GetAttribute('Team')
                if playerTeam and playerTeam == myTeam then
                    table.insert(teammates, player.Name)
                end
            end
        end
        
        table.sort(teammates)
        return teammates
    end
    
    local function isHoldingScepter()
        if not entitylib.isAlive then return false end
        
        local inventory = store.inventory
        if inventory and inventory.inventory and inventory.inventory.hand then
            local handItem = inventory.inventory.hand
            if handItem and handItem.itemType == "scepter" then
                return true
            end
        end
        return false
    end
    
    local function hasScepterInInventory()
        if not entitylib.isAlive then return false end
        
        local inventory = store.inventory
        if inventory and inventory.inventory then
            if inventory.inventory.hand then
                local handItem = inventory.inventory.hand
                if handItem and handItem.itemType == "scepter" then
                    return true
                end
            end
            
            for _, item in pairs(inventory.inventory) do
                if type(item) == "table" and item.itemType == "scepter" then
                    return true
                end
            end
        end
        return false
    end
    
    local function getScepterTool()
        if not entitylib.isAlive then return nil end
        
        local inventory = store.inventory
        if inventory and inventory.inventory and inventory.inventory.hand then
            local handItem = inventory.inventory.hand
            if handItem and handItem.itemType == "scepter" then
                return handItem.tool
            end
        end
        return nil
    end
    
    local function getPlayerHealth(player)
        if not player or not player.Character then return 0 end
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if humanoid then
            return humanoid.Health, humanoid.MaxHealth
        end
        return 0, 100
    end
    
    local function getPlayerHealthPercent(player)
        local health, maxHealth = getPlayerHealth(player)
        if maxHealth == 0 then return 0 end
        return (health / maxHealth) * 100
    end
    
    local function isPlayerAlive(player)
        if not player or not player.Character then return false end
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if humanoid and humanoid.Health > 0 then
            return true
        end
        return false
    end
    
    local function isPlayerInVoid(player)
        if not player or not player.Character then return true end
        local rootPart = player.Character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            return rootPart.Position.Y < 0
        end
        return true
    end
    
    local function getTargetPlayer()
        local myTeam = lplr:GetAttribute('Team')
        if not myTeam then return nil end
        
        local mode = TargetModeDropdown.Value
        
        if mode == "Specific Player" then
            local targetName = PlayerDropdown.Value
            if not targetName or targetName == "" then return nil end
            
            local targetPlayer = playersService:FindFirstChild(targetName)
            if targetPlayer and targetPlayer:GetAttribute('Team') == myTeam then
                if isPlayerAlive(targetPlayer) and not isPlayerInVoid(targetPlayer) then
                    return targetPlayer
                end
            end
            return nil
            
        elseif mode == "Lowest Health Teammate" then
            local lowestHealth = math.huge
            local lowestPlayer = nil
            
            for _, player in playersService:GetPlayers() do
                if player ~= lplr and player:GetAttribute('Team') == myTeam then
                    if isPlayerAlive(player) and not isPlayerInVoid(player) then
                        local healthPercent = getPlayerHealthPercent(player)
                        if healthPercent < lowestHealth and healthPercent > 0 then
                            lowestHealth = healthPercent
                            lowestPlayer = player
                        end
                    end
                end
            end
            return lowestPlayer
            
        elseif mode == "Closest Teammate" then
            if not entitylib.isAlive then return nil end
            local myPos = entitylib.character.RootPart.Position
            local closestDist = math.huge
            local closestPlayer = nil
            
            for _, player in playersService:GetPlayers() do
                if player ~= lplr and player:GetAttribute('Team') == myTeam then
                    if isPlayerAlive(player) and not isPlayerInVoid(player) then
                        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            local dist = (player.Character.HumanoidRootPart.Position - myPos).Magnitude
                            if dist < closestDist then
                                closestDist = dist
                                closestPlayer = player
                            end
                        end
                    end
                end
            end
            return closestPlayer
            
        elseif mode == "Furthest Teammate" then
            if not entitylib.isAlive then return nil end
            local myPos = entitylib.character.RootPart.Position
            local furthestDist = 0
            local furthestPlayer = nil
            
            for _, player in playersService:GetPlayers() do
                if player ~= lplr and player:GetAttribute('Team') == myTeam then
                    if isPlayerAlive(player) and not isPlayerInVoid(player) then
                        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                            local dist = (player.Character.HumanoidRootPart.Position - myPos).Magnitude
                            if dist > furthestDist then
                                furthestDist = dist
                                furthestPlayer = player
                            end
                        end
                    end
                end
            end
            return furthestPlayer
            
        elseif mode == "Random Teammate" then
            local validTeammates = {}
            
            for _, player in playersService:GetPlayers() do
                if player ~= lplr and player:GetAttribute('Team') == myTeam then
                    if isPlayerAlive(player) and not isPlayerInVoid(player) then
                        table.insert(validTeammates, player)
                    end
                end
            end
            
            if #validTeammates > 0 then
                return validTeammates[math.random(1, #validTeammates)]
            end
            return nil
            
        elseif mode == "Self" then
            return nil
        end
        
        return nil
    end
    
    local function shouldActivateByHealth()
        if not HealthActivationToggle.Enabled then return true end
        
        if not entitylib.isAlive then return false end
        
        local myHealthPercent = getPlayerHealthPercent(lplr)
        if myHealthPercent <= HealthThresholdSlider.Value then
            return true
        end
        
        if TeammateHealthToggle.Enabled then
            local target = getTargetPlayer()
            if target then
                local targetHealthPercent = getPlayerHealthPercent(target)
                if targetHealthPercent <= TeammateHealthSlider.Value then
                    return true
                end
            end
        end
        
        return false
    end
    
    local function consumeScepter()
        local scepterTool = getScepterTool()
        if scepterTool then
            pcall(function()
                local args = {
                    {
                        item = scepterTool
                    }
                }
                game:GetService("ReplicatedStorage")
                    :WaitForChild("rbxts_include")
                    :WaitForChild("node_modules")
                    :WaitForChild("@rbxts")
                    :WaitForChild("net")
                    :WaitForChild("out")
                    :WaitForChild("_NetManaged")
                    :WaitForChild("ConsumeItem")
                    :InvokeServer(unpack(args))
            end)
        end
    end
    
    local function getShopNPC()
        local shopFound = false
        if entitylib.isAlive then
            local localPosition = entitylib.character.RootPart.Position
            for _, v in store.shop do
                if (v.RootPart.Position - localPosition).Magnitude <= 20 then
                    shopFound = true
                    break
                end
            end
        end
        return shopFound
    end
    
    local function buyScepter()
        pcall(function()
            local args = {
                {
                    shopItem = {
                        currency = "iron",
                        itemType = "scepter",
                        amount = 1,
                        price = 45,
                        category = "Combat",
                        requiresKit = {
                            "paladin"
                        },
                        lockAfterPurchase = true
                    },
                    shopId = "1_item_shop"
                }
            }
            game:GetService("ReplicatedStorage")
                :WaitForChild("rbxts_include")
                :WaitForChild("node_modules")
                :WaitForChild("@rbxts")
                :WaitForChild("net")
                :WaitForChild("out")
                :WaitForChild("_NetManaged")
                :WaitForChild("BedwarsPurchaseItem")
                :InvokeServer(unpack(args))
        end)
    end
    
    local function startBuyLoop()
        if buyLoopThread then
            task.cancel(buyLoopThread)
            buyLoopThread = nil
        end
        
        buyRunning = true
        buyLoopThread = task.spawn(function()
            while buyRunning and AutoBuyToggle.Enabled and AutoLani.Enabled do
                local canBuy = true
                
                if GUICheck.Enabled then
                    if bedwars.AppController:isAppOpen('BedwarsItemShopApp') then
                        canBuy = true
                    else
                        canBuy = false
                    end
                else
                    canBuy = getShopNPC()
                end
                
                if canBuy then
                    buyScepter()
                end
                
                task.wait(1 / DelayBuySlider.GetRandomValue())
            end
            buyLoopThread = nil
        end)
    end
    
    local function stopBuyLoop()
        buyRunning = false
        if buyLoopThread then
            task.cancel(buyLoopThread)
            buyLoopThread = nil
        end
    end
    
    AutoLani = vape.Categories.Kits:CreateModule({
        Name = "AutoLani",
        Function = function(callback)
            running = callback
            
            if callback then
                task.spawn(function()
                    AutoLani:Clean(lplr:GetAttributeChangedSignal("PaladinStartTime"):Connect(function()
                        if not running then return end
                        
                        if not shouldActivateByHealth() then
                            return
                        end
                        
                        if LimitItems.Enabled then
                            if not isHoldingScepter() then
                                return
                            end
                        end
                        
                        consumeScepter()
                        local delay = DelaySlider.GetRandomValue()
                        task.wait(delay)
                        
                        if bedwars.AbilityController:canUseAbility('PALADIN_ABILITY') then
                            local targetPlayer = getTargetPlayer()
                            
                            if targetPlayer and targetPlayer.Character then
                                bedwars.Client:Get("PaladinAbilityRequest"):SendToServer({target = targetPlayer})
                            else
                                bedwars.Client:Get("PaladinAbilityRequest"):SendToServer({})
                            end
                            
                            task.wait(0.022)
                            bedwars.AbilityController:useAbility('PALADIN_ABILITY')
                        end
                    end))
                end)
                
                if AutoBuyToggle.Enabled then
                    startBuyLoop()
                end
                
                AutoLani:Clean(playersService.PlayerAdded:Connect(function()
                    task.wait(0.5)
                    PlayerDropdown:SetList(getTeammateList())
                end))
                
                AutoLani:Clean(playersService.PlayerRemoving:Connect(function()
                    task.wait(0.5)
                    PlayerDropdown:SetList(getTeammateList())
                end))
                
                AutoLani:Clean(lplr:GetAttributeChangedSignal('Team'):Connect(function()
                    task.wait(1)
                    PlayerDropdown:SetList(getTeammateList())
                end))
                
            else
                running = false
                stopBuyLoop()
            end
        end,
        Tooltip = "Automatically teleports to selected teammate using Paladin ability"
    })
    
    TargetModeDropdown = AutoLani:CreateDropdown({
        Name = "Target Mode",
        List = {"Specific Player", "Lowest Health Teammate", "Closest Teammate", "Furthest Teammate", "Random Teammate", "Self"},
        Default = "Specific Player",
        Function = function(val)
            if PlayerDropdown then
                PlayerDropdown.Object.Visible = (val == "Specific Player")
            end
        end,
        Tooltip = "How to select teleport target"
    })
    
    PlayerDropdown = AutoLani:CreateDropdown({
        Name = "Teammate",
        List = getTeammateList(),
        Function = function(val)
        end,
        Tooltip = "Select teammate to teleport to"
    })
    
    RefreshButton = AutoLani:CreateButton({
        Name = "Refresh Teammates",
        Function = function()
            task.spawn(function()
                local newList = getTeammateList()
                
                if PlayerDropdown then
                    pcall(function()
                        PlayerDropdown:Change(newList)
                        
                        if #newList > 0 then
                            if not PlayerDropdown.Value or PlayerDropdown.Value == "" or not table.find(newList, PlayerDropdown.Value) then
                                PlayerDropdown:SetValue(newList[1])
                            else
                                PlayerDropdown:SetValue(PlayerDropdown.Value)
                            end
                        end
                    end)
                end
                
                notif("Auto Lani", string.format("Refreshed teammate list (%d teammates)", #newList), 2)
            end)
        end,
        Tooltip = "Manually refresh the teammate list"
    })
    
    DelaySlider = AutoLani:CreateTwoSlider({
        Name = "Teleport Delay",
        Min = 0,
        Max = 2,
        DefaultMin = 0.4,
        DefaultMax = 1.33,
        Decimal = 10,
        Suffix = "s",
        Tooltip = "Delay before teleporting to teammate"
    })
    
    LimitItems = AutoLani:CreateToggle({
        Name = "Limit to Scepter",
        Default = true,
        Function = function(val)
        end,
        Tooltip = "Only teleport when holding scepter"
    })
    
    HealthActivationToggle = AutoLani:CreateToggle({
        Name = "Health Activation",
        Default = false,
        Function = function(val)
            if HealthThresholdSlider then
                HealthThresholdSlider.Object.Visible = val
            end
            if TeammateHealthToggle then
                TeammateHealthToggle.Object.Visible = val
            end
        end,
        Tooltip = "Only use ability based on health conditions"
    })
    
    HealthThresholdSlider = AutoLani:CreateSlider({
        Name = "Self Health %",
        Min = 1,
        Max = 100,
        Default = 50,
        Suffix = "%",
        Function = function(val)
        end,
        Tooltip = "Use ability when your health is below this %",
        Visible = false
    })
    
    TeammateHealthToggle = AutoLani:CreateToggle({
        Name = "Teammate Health Check",
        Default = false,
        Function = function(val)
            if TeammateHealthSlider then
                TeammateHealthSlider.Object.Visible = val
            end
        end,
        Tooltip = "Also check teammate health",
        Visible = false
    })
    
    TeammateHealthSlider = AutoLani:CreateSlider({
        Name = "Teammate Health %",
        Min = 1,
        Max = 100,
        Default = 30,
        Suffix = "%",
        Function = function(val)
        end,
        Tooltip = "Use ability when teammate health is below this %",
        Visible = false
    })
    
    AutoBuyToggle = AutoLani:CreateToggle({
        Name = "Auto Buy Scepter",
        Default = false,
        Function = function(val)
            if GUICheck then
                GUICheck.Object.Visible = val
            end
            if DelayBuySlider then
                DelayBuySlider.Object.Visible = val
            end
            
            if val and AutoLani.Enabled then
                startBuyLoop()
            else
                stopBuyLoop()
            end
        end,
        Tooltip = "Automatically buys scepter when near shop"
    })
    
    GUICheck = AutoLani:CreateToggle({
        Name = "GUI Check",
        Default = false,
        Function = function(val)
        end,
        Tooltip = "Only buy when shop GUI is open",
        Visible = false
    })
    
    DelayBuySlider = AutoLani:CreateTwoSlider({
        Name = "Buy Delay",
        Min = 0.1,
        Max = 2,
        DefaultMin = 0.1,
        DefaultMax = 0.4,
        Decimal = 10,
        Suffix = "s",
        Tooltip = "Delay between purchase attempts",
        Visible = false
    })
end)

run(function()
	local AutoPearl
	local LimitItems

	local rayCheck = RaycastParams.new()
	rayCheck.RespectCanCollide = true

	local scanParams = RaycastParams.new()
	scanParams.RespectCanCollide = true

	local projectileRemote = {InvokeServer = function() end}
	task.spawn(function()
		projectileRemote = bedwars.Client:Get(remotes.FireProjectile).instance
	end)

	local function isHoldingPearl()
		if not entitylib.isAlive then return false end
		local hand = store.inventory and store.inventory.inventory and store.inventory.inventory.hand
		return hand and hand.itemType == 'telepearl'
	end

	local function getPearlHotbarSlot()
		for i, v in store.inventory.hotbar do
			if v.item and v.item.itemType == 'telepearl' then
				return i - 1, v.item
			end
		end
		return nil, nil
	end

	local function throwPearl(pos, spot, pearlTool)
		local meta = bedwars.ProjectileMeta.telepearl
		local adjustedSpot = spot - Vector3.new(0, 2, 0) 
		
		local calc = prediction.SolveTrajectory(
			pos,
			meta.launchVelocity,
			meta.gravitationalAcceleration,
			adjustedSpot, 
			Vector3.zero,
			workspace.Gravity,
			0, 0, nil, false,
			lplr:GetNetworkPing()
		)
		
		if not calc then 
			calc = prediction.SolveTrajectory(
				pos,
				meta.launchVelocity,
				meta.gravitationalAcceleration,
				spot,
				Vector3.zero,
				workspace.Gravity,
				0, 0, nil, false,
				lplr:GetNetworkPing()
			)
			if not calc then return false end
		end
		
		local dir = CFrame.lookAt(pos, calc).LookVector * meta.launchVelocity
		projectileRemote:InvokeServer(
			pearlTool,
			'telepearl', 'telepearl',
			pos, pos, dir,
			httpService:GenerateGUID(true),
			{drawDurationSeconds = 1, shotId = httpService:GenerateGUID(false)},
			workspace:GetServerTimeNow() - 0.045
		)
		return true
	end

	local function findBestLandingSpot(origin)
		local char = lplr.Character
		if not char then return nil end

		scanParams.FilterDescendantsInstances = {char, gameCamera}
		scanParams.FilterType = Enum.RaycastFilterType.Exclude

		local meta = bedwars.ProjectileMeta.telepearl
		local candidates = {}

		local distances = {8, 12, 16, 20, 24}
		local angleSteps = 16

		for _, dist in distances do
			for step = 0, angleSteps - 1 do
				local angle = (step / angleSteps) * math.pi * 2
				local offsetX = math.cos(angle) * dist
				local offsetZ = math.sin(angle) * dist

				local checkOrigin = Vector3.new(
					origin.X + offsetX,
					origin.Y + 30,
					origin.Z + offsetZ
				)

				local downRay = workspace:Raycast(checkOrigin, Vector3.new(0, -60, 0), scanParams)
				if downRay then
					local normal = downRay.Normal
					local hitPosition = downRay.Position
					
					local block = downRay.Instance
					if block and block:IsA("BasePart") then
						local blockSize = block.Size
						local blockPos = block.Position
						local landingSpot
						local hitOffset = hitPosition - blockPos
						local threshold = 0.5

						if math.abs(normal.X) > 0.5 then
							local sideX = blockPos.X + (math.sign(normal.X) * blockSize.X/2)
							landingSpot = Vector3.new(
								sideX - (math.sign(normal.X) * 1.5), 
								blockPos.Y + blockSize.Y/2, 
								hitPosition.Z
							)
						elseif math.abs(normal.Z) > 0.5 then
							local sideZ = blockPos.Z + (math.sign(normal.Z) * blockSize.Z/2)
							landingSpot = Vector3.new(
								hitPosition.X,
								blockPos.Y + blockSize.Y/2, 
								sideZ - (math.sign(normal.Z) * 1.5)
							)
						else
							local dirToPlayer = (origin - hitPosition).Unit
							landingSpot = hitPosition + Vector3.new(
								dirToPlayer.X * 2, 
								3, 
								dirToPlayer.Z * 2  
							)
						end
						
						local calc = prediction.SolveTrajectory(
							origin,
							meta.launchVelocity,
							meta.gravitationalAcceleration,
							landingSpot,
							Vector3.zero,
							workspace.Gravity,
							0, 0, nil, false,
							lplr:GetNetworkPing()
						)

						if calc then
							local dist2d = Vector2.new(origin.X - landingSpot.X, origin.Z - landingSpot.Z).Magnitude
							table.insert(candidates, {
								spot = landingSpot,
								dist = dist2d,
								height = landingSpot.Y,
								calc = calc
							})
						end
					end
				end
			end
		end

		if #candidates == 0 then return nil end

		table.sort(candidates, function(a, b)
			local aArc = math.abs(a.calc.Y - origin.Y)
			local bArc = math.abs(b.calc.Y - origin.Y)
			if math.abs(aArc - bArc) > 5 then
				return aArc < bArc
			end
			return a.dist < b.dist
		end)

		return candidates[1].spot
	end

	local function doPearl(pos, spot, pearl)
		if LimitItems.Enabled then
			if not isHoldingPearl() then return end
			throwPearl(pos, spot, pearl.tool)
			return
		end

		local pearlSlot, pearlItem = getPearlHotbarSlot()
		if not pearlSlot or not pearlItem then return end

		local originalSlot = store.inventory.hotbarSlot

		if isHoldingPearl() then
			throwPearl(pos, spot, pearlItem.tool)
		else
			hotbarSwitch(pearlSlot)
			task.wait(0.08)
			throwPearl(pos, spot, pearlItem.tool)
			task.wait(0.05)
			hotbarSwitch(originalSlot)
		end
	end

	AutoPearl = vape.Categories.Utility:CreateModule({
		Name = 'Auto Pearl',
		Function = function(callback)
			if callback then
				local lastThrowTime = 0
				local throwCooldown = 0.05
				local pearlTriggered = false
				
				repeat
					if entitylib.isAlive then
						local root = entitylib.character.RootPart
						local pearl = getItem('telepearl')
						local currentTime = tick()

						rayCheck.FilterDescendantsInstances = {lplr.Character, gameCamera, AntiFallPart}
						rayCheck.CollisionGroup = root.CollisionGroup

						local falling = root.Velocity.Y < -80
						local noGroundBelow = not workspace:Raycast(root.Position, Vector3.new(0, -200, 0), rayCheck)

						if pearl and falling and noGroundBelow then
							if not pearlTriggered and (currentTime - lastThrowTime) >= throwCooldown then
								pearlTriggered = true
								lastThrowTime = currentTime
								
								local ground = findBestLandingSpot(root.Position)
								if ground then
									task.spawn(doPearl, root.Position, ground, pearl)
								end
							end
						else
							pearlTriggered = false
						end
					end
					task.wait(0.1)
				until not AutoPearl.Enabled
			end
		end,
		Tooltip = 'automatically pearls to safety when falling into void'
	})

	LimitItems = AutoPearl:CreateToggle({
		Name = 'Limit to Pearl',
		Default = false,
		Tooltip = 'only pearls when already holding pearl, no switching'
	})
end)

run(function()
	local AutoUMA
	local CycleMode
	local AttackMode
	local HealMode
	local Range
	local AutoSummon
	local TargetVisualiser
	local PriorityDropdown
	local CollectionService = game:GetService("CollectionService")
	local selectedTarget = nil
	local targetOutline = nil
	local hovering = false
	local old
	local summonThread = nil
	local currentAffinity = nil
	local generatorCache = {}
	local lastCacheUpdate = 0
	local priorityOrders = {
		['Emerald > Diamond > Iron'] = {'emerald', 'diamond', 'iron'},
		['Diamond > Emerald > Iron'] = {'diamond', 'emerald', 'iron'},
		['Iron > Diamond > Emerald'] = {'iron', 'diamond', 'emerald'}
	}
	
	local lootNames = {
		emerald = {"Emerald", "EmeraldOre"},
		diamond = {"Diamond", "DiamondOre"},
		iron = {"IronIngot", "IronOre"}
	}
	
	local function updateOutline(target)
		if targetOutline then
			targetOutline:Destroy()
			targetOutline = nil
		end
		if target and TargetVisualiser.Enabled then
			targetOutline = Instance.new("Highlight")
			targetOutline.FillTransparency = 0.5
			targetOutline.OutlineColor = Color3.fromRGB(255, 215, 0)
			targetOutline.OutlineTransparency = 0
			targetOutline.Adornee = target
			targetOutline.Parent = target
		end
	end
	
	local function clearOutline()
		if targetOutline then
			targetOutline:Destroy()
			targetOutline = nil
		end
	end
	
	local function updateGeneratorCache()
		if tick() - lastCacheUpdate < 2 then return end
		
		generatorCache = {}
		for _, obj in ipairs(workspace:GetDescendants()) do
			if obj.Name == 'GeneratorAdornee' then
				table.insert(generatorCache, obj)
			end
		end
		lastCacheUpdate = tick()
	end
	
	local function isGeneratorLoot(drop)
		if drop:GetAttribute('OreGenDrop') then
			return true
		end
		
		updateGeneratorCache()
		
		local pos = drop:FindFirstChild('Handle') and drop.Handle.Position
		if not pos then return false end
		
		for _, gen in ipairs(generatorCache) do
			local genPos = gen:GetPivot().Position
			if (pos - genPos).Magnitude <= 20 then
				return true
			end
		end
		
		return false
	end
	
	local function getClosestLoot(originPos)
		local closest, closestDist = nil, math.huge
		local priorityOrder = priorityOrders[PriorityDropdown.Value] or priorityOrders['Emerald > Diamond > Iron']
		
		for _, itemType in ipairs(priorityOrder) do
			for _, drop in ipairs(CollectionService:GetTagged('ItemDrop')) do
				if not drop:FindFirstChild('Handle') then continue end
				if not isGeneratorLoot(drop) then continue end
				
				local dropName = drop.Name:lower()
				local isTargetType = false
				
				for _, name in ipairs(lootNames[itemType]) do
					if dropName:find(name:lower()) then
						isTargetType = true
						break
					end
				end
				
				if isTargetType then
					local dist = (drop.Handle.Position - originPos).Magnitude
					if dist <= Range.Value and dist < closestDist then
						closest = drop.Handle
						closestDist = dist
					end
				end
			end
			
			if closest then return closest end
		end
		
		return closest
	end
	
	local function switchAffinity(targetAffinity)
		local currentAff = lplr:GetAttribute('SpiritSummonerAffinity')
		if currentAff ~= targetAffinity then
			pcall(function()
				if bedwars.AbilityController:canUseAbility('spirit_summoner_switch_affinity') then
					bedwars.AbilityController:useAbility('spirit_summoner_switch_affinity')
					task.wait(0.1)
				end
			end)
		end
	end
	
	local function getTeammateHealth(plr)
		if not plr.Character then return 100 end
		local health = plr.Character:GetAttribute('Health') or 100
		local maxHealth = plr.Character:GetAttribute('MaxHealth') or 100
		return health, maxHealth
	end
	
	local function getLowHealthTeammate()
		local myTeam = lplr:GetAttribute('Team')
		if not myTeam then return nil end
		
		for _, plr in ipairs(game:GetService('Players'):GetPlayers()) do
			if plr ~= lplr and plr:GetAttribute('Team') == myTeam then
				local health, maxHealth = getTeammateHealth(plr)
				if health <= 40 and health > 0 then
					return plr
				end
			end
		end
		return nil
	end
	
	local function startAutoSummon()
		if summonThread then
			task.cancel(summonThread)
			summonThread = nil
		end
		
		summonThread = task.spawn(function()
			while AutoUMA.Enabled and AutoSummon.Enabled do
				if not entitylib.isAlive then
					task.wait(0.5)
					continue
				end
				
				local hasStaff = false
				for _, item in ipairs(store.inventory.inventory.items) do
					if item.itemType == 'spirit_staff' then
						hasStaff = true
						break
					end
				end
				
				if hasStaff then
					local attackSpirits = lplr:GetAttribute('ReadySummonedAttackSpirits') or 0
					local healSpirits = lplr:GetAttribute('ReadySummonedHealSpirits') or 0
					local totalSpirits = attackSpirits + healSpirits
					
					if totalSpirits < 10 then
						local hasStone = false
						for _, item in ipairs(store.inventory.inventory.items) do
							if item.itemType == 'summon_stone' then
								hasStone = true
								break
							end
						end
						
						if hasStone then
							pcall(function()
								if bedwars.AbilityController:canUseAbility('summon_attack_spirit') then
									bedwars.AbilityController:useAbility('summon_attack_spirit')
									task.wait(0.5)
								end
							end)
						end
					end
				end
				
				task.wait(0.5)
			end
		end)
	end
	
	local function stopAutoSummon()
		if summonThread then
			task.cancel(summonThread)
			summonThread = nil
		end
	end
	
	AutoUMA = vape.Categories.Kits:CreateModule({
		Name = 'AutoUma',
		Function = function(callback)
			if callback then
				old = bedwars.ProjectileController.calculateImportantLaunchValues
				bedwars.ProjectileController.calculateImportantLaunchValues = function(...)
					hovering = true
					local self, projmeta, worldmeta, origin, shootpos = ...
					
					if not (projmeta.projectile == 'attack_spirit' or projmeta.projectile == 'heal_spirit') then
						hovering = false
						clearOutline()
						return old(...)
					end
					
					local originPos = entitylib.isAlive and (shootpos or entitylib.character.RootPart.Position) or Vector3.zero
					local target = nil
					local targetPos = nil
					
					if CycleMode.Enabled then
						local targetLoot = getClosestLoot(originPos)
						if targetLoot and (targetLoot.Position - originPos).Magnitude <= Range.Value then
							target = targetLoot
							targetPos = targetLoot.Position
							updateOutline(targetLoot)
						else
							clearOutline()
						end
					end
					
					if HealMode.Enabled and not CycleMode.Enabled then
						local lowTeammate = getLowHealthTeammate()
						if lowTeammate and lowTeammate.Character and lowTeammate.Character.PrimaryPart then
							switchAffinity('heal')
							local dist = (lowTeammate.Character.PrimaryPart.Position - originPos).Magnitude
							if dist <= Range.Value then
								target = lowTeammate.Character.PrimaryPart
								targetPos = lowTeammate.Character.PrimaryPart.Position + Vector3.new(0, 2, 0)
								updateOutline(lowTeammate.Character)
							else
								clearOutline()
							end
						else
							clearOutline()
						end
					end
					
					if AttackMode.Enabled and not CycleMode.Enabled and not (HealMode.Enabled and getLowHealthTeammate()) then
						switchAffinity('attack')
						local plr = entitylib.EntityMouse({
							Part = 'RootPart',
							Range = 1000,
							Players = true,
							NPCs = true,
							Wallcheck = false,
							Origin = originPos
						})
						
						if plr and plr.RootPart and (plr.RootPart.Position - originPos).Magnitude <= Range.Value then
							target = plr.RootPart
							targetPos = plr.RootPart.Position + Vector3.new(0, 2, 0)
							updateOutline(plr.Character)
						else
							clearOutline()
						end
					end
					
					if target and targetPos then
						local pos = shootpos or self:getLaunchPosition(origin)
						if not pos then
							hovering = false
							clearOutline()
							return old(...)
						end
						
						local meta = projmeta:getProjectileMeta()
						local lifetime = (worldmeta and meta.predictionLifetimeSec or meta.lifetimeSec or 3)
						local gravity = (meta.gravitationalAcceleration or 196.2) * projmeta.gravityMultiplier
						local projSpeed = (meta.launchVelocity or 100)
						local offsetpos = pos + projmeta.fromPositionOffset
						
						local direction = (targetPos - offsetpos).Unit
						local distance = (targetPos - offsetpos).Magnitude
						local timeToReach = distance / projSpeed
						local dropAmount = 0.5 * gravity * (timeToReach * timeToReach)
						local adjustedTarget = targetPos + Vector3.new(0, dropAmount, 0)
						
						local newlook = CFrame.new(offsetpos, adjustedTarget)
						
						hovering = false
						return {
							initialVelocity = newlook.LookVector * projSpeed,
							positionFrom = offsetpos,
							deltaT = lifetime,
							gravitationalAcceleration = gravity,
							drawDurationSeconds = 5
						}
					end
					
					hovering = false
					clearOutline()
					return old(...)
				end
				
				if AutoSummon.Enabled then
					startAutoSummon()
				end
			else
				if old then
					bedwars.ProjectileController.calculateImportantLaunchValues = old
				end
				clearOutline()
				stopAutoSummon()
				selectedTarget = nil
			end
		end,
		Tooltip = 'Spirit Summoner automation - lock onto loot, enemies, or heal teammates'
	})
	
	CycleMode = AutoUMA:CreateToggle({
		Name = 'Cycle',
		Function = function(callback)
			if callback then
				if AttackMode.Enabled then
					AttackMode:Toggle()
				end
				if HealMode.Enabled then
					HealMode:Toggle()
				end
				PriorityDropdown.Object.Visible = true
			else
				PriorityDropdown.Object.Visible = false
				clearOutline()
			end
		end,
		Tooltip = 'Lock onto generator loot (iron/diamond/emerald) with priority system'
	})
	
	PriorityDropdown = AutoUMA:CreateDropdown({
		Name = 'Loot Priority',
		List = {'Emerald > Diamond > Iron', 'Diamond > Emerald > Iron', 'Iron > Diamond > Emerald'},
		Default = 'Emerald > Diamond > Iron',
		Darker = true
	})
	PriorityDropdown.Object.Visible = false
	
	AttackMode = AutoUMA:CreateToggle({
		Name = 'Attack',
		Function = function(callback)
			if callback then
				if CycleMode.Enabled then
					CycleMode:Toggle()
				end
				if HealMode.Enabled then
					HealMode:Toggle()
				end
				clearOutline()
			else
				clearOutline()
			end
		end,
		Tooltip = 'Lock onto enemies and attack them'
	})
	
	HealMode = AutoUMA:CreateToggle({
		Name = 'Heal',
		Function = function(callback)
			if callback then
				if CycleMode.Enabled then
					CycleMode:Toggle()
				end
				if AttackMode.Enabled then
					AttackMode:Toggle()
				end
				clearOutline()
			else
				clearOutline()
			end
		end,
		Tooltip = 'Heal teammates below 40 HP'
	})
	
	Range = AutoUMA:CreateSlider({
		Name = 'Lock Range',
		Min = 10,
		Max = 70,
		Default = 70,
		Tooltip = 'Maximum distance to lock onto targets'
	})
	
	AutoSummon = AutoUMA:CreateToggle({
		Name = 'Auto Summon',
		Function = function(callback)
			if callback and AutoUMA.Enabled then
				startAutoSummon()
			else
				stopAutoSummon()
			end
		end,
		Default = true,
		Tooltip = 'Automatically summons spirits when you have summon stones'
	})
	
	TargetVisualiser = AutoUMA:CreateToggle({
		Name = 'Target Visualiser',
		Function = function(callback)
			if not callback then
				clearOutline()
			end
		end,
		Default = true,
		Tooltip = 'Shows gold outline on locked target'
	})
end)

run(function()
    local Caitlyn
    local ContractVisuals
    local FillTransparency
    local OutlineTransparency
    local ColorPicker
    local AutoKitToggle
    local MethodDropdown
    local LowHealthSlider
    local ExecuteRangeSlider
    local HitRangeSlider
    local ProximityRangeSlider
    local connections = {}
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local lplr = Players.LocalPlayer
    local currentTarget = nil
    local lastHitTime = 0
    local lastContractSelect = 0
    local activeHighlight = nil
    local originalHighlightSettings = {}
    
    local function findActiveContractTarget()
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= lplr and player.Character then
                for _, obj in pairs(player.Character:GetDescendants()) do
                    if obj:IsA("Highlight") and obj.Name ~= "VapeHighlight" and obj.Name ~= "_DamageHighlight_" then
                        return player, player.Character, obj
                    end
                end
            end
        end
        return nil, nil, nil
    end
    
    local function enhanceHighlight()
        if not ContractVisuals.Enabled then return end
        
        local targetPlayer, targetChar, highlight = findActiveContractTarget()
        
        if highlight then
            if not originalHighlightSettings[highlight] then
                originalHighlightSettings[highlight] = {
                    FillColor = highlight.FillColor,
                    FillTransparency = highlight.FillTransparency,
                    OutlineColor = highlight.OutlineColor,
                    OutlineTransparency = highlight.OutlineTransparency,
                    DepthMode = highlight.DepthMode
                }
            end
            
            activeHighlight = highlight
            
            highlight.FillTransparency = FillTransparency.Value
            highlight.OutlineTransparency = OutlineTransparency.Value
            highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            
            local color = Color3.fromHSV(ColorPicker.Hue, ColorPicker.Sat, ColorPicker.Value)
            highlight.FillColor = color
            highlight.OutlineColor = color
        else
            activeHighlight = nil
        end
    end
    
    local function restoreHighlight()
        for highlight, settings in pairs(originalHighlightSettings) do
            if highlight and highlight.Parent then
                highlight.FillColor = settings.FillColor
                highlight.FillTransparency = settings.FillTransparency
                highlight.OutlineColor = settings.OutlineColor
                highlight.OutlineTransparency = settings.OutlineTransparency
                highlight.DepthMode = settings.DepthMode
            end
        end
        table.clear(originalHighlightSettings)
    end
    
    local function selectContract(targetPlayer)
        if not entitylib.isAlive then return false end
        if tick() - lastContractSelect < 0.1 then return false end
        
        local storeState = bedwars.Store:getState()
        local activeContract = storeState.Kit.activeContract
        local availableContracts = storeState.Kit.availableContracts or {}
        
        if activeContract then return false end
        if #availableContracts == 0 then return false end
        
        for _, contract in pairs(availableContracts) do
            if contract.target == targetPlayer then
                bedwars.Client:Get("BloodAssassinSelectContract"):SendToServer({
                    contractId = contract.id
                })
                lastContractSelect = tick()
                return true
            end
        end
        return false
    end
    
    local function executeOnLowHealth()
        if not currentTarget or tick() - lastHitTime > 3 then
            currentTarget = nil
            return
        end
        
        if not currentTarget.Character then return end
        
        local humanoid = currentTarget.Character:FindFirstChild("Humanoid")
        local rootPart = currentTarget.Character:FindFirstChild("HumanoidRootPart")
        
        if humanoid and rootPart and lplr.Character and lplr.Character:FindFirstChild("HumanoidRootPart") then
            local health = humanoid.Health
            local distance = (lplr.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude
            
            if health > 0 and health <= LowHealthSlider.Value and distance <= ExecuteRangeSlider.Value then
                selectContract(currentTarget)
            end
        end
    end
    
    local function contractOnHit()
        if not currentTarget or tick() - lastHitTime > 0.5 then
            currentTarget = nil
            return
        end
        
        if not currentTarget.Character then return end
        
        local rootPart = currentTarget.Character:FindFirstChild("HumanoidRootPart")
        
        if rootPart and lplr.Character and lplr.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (lplr.Character.HumanoidRootPart.Position - rootPart.Position).Magnitude
            
            if distance <= HitRangeSlider.Value then
                selectContract(currentTarget)
            end
        end
    end
    
    local function proximityContract()
        if not entitylib.isAlive then return end
        
        local myRoot = lplr.Character and lplr.Character:FindFirstChild("HumanoidRootPart")
        if not myRoot then return end
        
        local closestPlayer = nil
        local closestDistance = ProximityRangeSlider.Value
        
        for _, player in pairs(Players:GetPlayers()) do
            if player ~= lplr and player.Character then
                local theirRoot = player.Character:FindFirstChild("HumanoidRootPart")
                local humanoid = player.Character:FindFirstChild("Humanoid")
                
                if theirRoot and humanoid and humanoid.Health > 0 then
                    local distance = (myRoot.Position - theirRoot.Position).Magnitude
                    
                    if distance < closestDistance then
                        closestDistance = distance
                        closestPlayer = player
                    end
                end
            end
        end
        
        if closestPlayer then
            selectContract(closestPlayer)
        end
    end
    
    Caitlyn = vape.Categories.Kits:CreateModule({
        Name = 'AutoCaitlyn',
        Function = function(callback)
            if callback then
                if ContractVisuals.Enabled then
                    local updateConn = RunService.RenderStepped:Connect(function()
                        if not Caitlyn.Enabled or not ContractVisuals.Enabled then return end
                        enhanceHighlight()
                    end)
                    table.insert(connections, updateConn)
                end
                
                if AutoKitToggle.Enabled then
                    local damageConnection = vapeEvents.EntityDamageEvent.Event:Connect(function(damageTable)
                        if not entitylib.isAlive then return end
                        
                        local attacker = playersService:GetPlayerFromCharacter(damageTable.fromEntity)
                        local victim = playersService:GetPlayerFromCharacter(damageTable.entityInstance)
                    
                        if attacker == lplr and victim and victim ~= lplr then
                            currentTarget = victim
                            lastHitTime = tick()
                        end
                    end)
                    table.insert(connections, damageConnection)
                    
                    task.spawn(function()
                        repeat
                            if AutoKitToggle.Enabled and entitylib.isAlive then
                                local method = MethodDropdown.Value
                                
                                if method == "Execute on Low HP" then
                                    executeOnLowHealth()
                                elseif method == "Contract on Hit" then
                                    contractOnHit()
                                elseif method == "Proximity Select" then
                                    proximityContract()
                                end
                            end
                            task.wait(0.1)
                        until not Caitlyn.Enabled or not AutoKitToggle.Enabled
                    end)
                end
            else
                for _, conn in pairs(connections) do
                    if typeof(conn) == "RBXScriptConnection" then
                        conn:Disconnect()
                    end
                end
                table.clear(connections)
                
                restoreHighlight()
                currentTarget = nil
                activeHighlight = nil
                lastHitTime = 0
            end
        end,
        Tooltip = 'Contract visuals and auto kit caitlyn'
    })
    
    ContractVisuals = Caitlyn:CreateToggle({
        Name = 'Contract Visuals',
        Default = false,
        Tooltip = 'Makes contract target more visible',
        Function = function(callback)
            if FillTransparency and FillTransparency.Object then
                FillTransparency.Object.Visible = callback
            end
            if OutlineTransparency and OutlineTransparency.Object then
                OutlineTransparency.Object.Visible = callback
            end
            if ColorPicker and ColorPicker.Object then
                ColorPicker.Object.Visible = callback
            end
            
            if not callback then
                restoreHighlight()
            end
        end
    })
    
    FillTransparency = Caitlyn:CreateSlider({
        Name = 'Fill Transparency',
        Min = 0,
        Max = 1,
        Default = 0.3,
        Decimal = 100,
        Visible = false,
        Tooltip = 'Lower = more cool fill'
    })
    
    OutlineTransparency = Caitlyn:CreateSlider({
        Name = 'Outline Transparency',
        Min = 0,
        Max = 1,
        Default = 0,
        Decimal = 100,
        Visible = false,
        Tooltip = 'Lower = more cool outline'
    })
    
    ColorPicker = Caitlyn:CreateColorSlider({
        Name = 'Contract Highlight Color',
        DefaultValue = 0,
        DefaultOpacity = 1,
        Visible = false,
        Tooltip = 'Custom contract highlight color'
    })
    
    AutoKitToggle = Caitlyn:CreateToggle({
        Name = 'Auto Contract',
        Default = false,
        Tooltip = 'Automatically select contracts based on method',
        Function = function(callback)
            if MethodDropdown and MethodDropdown.Object then
                MethodDropdown.Object.Visible = callback
            end
            
            if callback then
                local method = MethodDropdown.Value
                if LowHealthSlider and LowHealthSlider.Object then
                    LowHealthSlider.Object.Visible = (method == "Execute on Low HP")
                end
                if ExecuteRangeSlider and ExecuteRangeSlider.Object then
                    ExecuteRangeSlider.Object.Visible = (method == "Execute on Low HP")
                end
                if HitRangeSlider and HitRangeSlider.Object then
                    HitRangeSlider.Object.Visible = (method == "Contract on Hit")
                end
                if ProximityRangeSlider and ProximityRangeSlider.Object then
                    ProximityRangeSlider.Object.Visible = (method == "Proximity Select")
                end
            else
                if LowHealthSlider and LowHealthSlider.Object then LowHealthSlider.Object.Visible = false end
                if ExecuteRangeSlider and ExecuteRangeSlider.Object then ExecuteRangeSlider.Object.Visible = false end
                if HitRangeSlider and HitRangeSlider.Object then HitRangeSlider.Object.Visible = false end
                if ProximityRangeSlider and ProximityRangeSlider.Object then ProximityRangeSlider.Object.Visible = false end
            end
        end
    })
    
    MethodDropdown = Caitlyn:CreateDropdown({
        Name = 'Method',
        List = {"Execute on Low HP", "Contract on Hit", "Proximity Select"},
        Default = "Execute on Low HP",
        Visible = false,
        Tooltip = 'Contract selection method',
        Function = function(value)
            if not AutoKitToggle.Enabled then return end
            
            if LowHealthSlider and LowHealthSlider.Object then
                LowHealthSlider.Object.Visible = (value == "Execute on Low HP")
            end
            if ExecuteRangeSlider and ExecuteRangeSlider.Object then
                ExecuteRangeSlider.Object.Visible = (value == "Execute on Low HP")
            end
            if HitRangeSlider and HitRangeSlider.Object then
                HitRangeSlider.Object.Visible = (value == "Contract on Hit")
            end
            if ProximityRangeSlider and ProximityRangeSlider.Object then
                ProximityRangeSlider.Object.Visible = (value == "Proximity Select")
            end
        end
    })
    
    LowHealthSlider = Caitlyn:CreateSlider({
        Name = 'Select HP',
        Min = 10,
        Max = 100,
        Default = 30,
        Visible = false,
        Tooltip = 'HP value to execute contract'
    })
    
    ExecuteRangeSlider = Caitlyn:CreateSlider({
        Name = 'Select Range',
        Min = 5,
        Max = 50,
        Default = 20,
        Suffix = ' studs',
        Visible = false,
        Tooltip = 'Range to select contract'
    })
    
    HitRangeSlider = Caitlyn:CreateSlider({
        Name = 'Hit Range',
        Min = 10,
        Max = 200,
        Default = 100,
        Suffix = ' studs',
        Visible = false,
        Tooltip = 'Max range to select a contract when hitting the player'
    })
    
    ProximityRangeSlider = Caitlyn:CreateSlider({
        Name = 'Proximity Range',
        Min = 10,
        Max = 200,
        Default = 50,
        Suffix = ' studs',
        Visible = false,
        Tooltip = 'Range to auto select nearby players (ran out of ideas...)'
    })
end)

run(function()
	local RemoveNeon = {Enabled = false}
	local neonConnection
	local safetyLoop
	local originalMaterials = {}
	local processedParts = {}
	local lastCleanup = 0
	
	local function cleanupDeadReferences()
		for obj, _ in pairs(originalMaterials) do
			if not obj or not obj.Parent then
				originalMaterials[obj] = nil
				processedParts[obj] = nil
			end
		end
	end
	
	local function removeNeonFromPart(obj)
		if obj:IsA("BasePart") then
			if processedParts[obj] then return end
			
			if obj.Material == Enum.Material.Neon then
				if not originalMaterials[obj] then
					originalMaterials[obj] = {
						Material = obj.Material,
						Reflectance = obj.Reflectance
					}
				end
				obj.Material = Enum.Material.Plastic
				obj.Reflectance = 0
				processedParts[obj] = true
			end
		end
	end
	
	local function restoreNeon()
		for obj, data in pairs(originalMaterials) do
			if obj and obj.Parent then
				pcall(function()
					obj.Material = data.Material
					obj.Reflectance = data.Reflectance
				end)
			end
		end
		table.clear(originalMaterials)
		table.clear(processedParts)
	end
	
	local function batchProcessParts(parts, batchSize)
		local count = 0
		for i, part in ipairs(parts) do
			if part and part.Parent then
				removeNeonFromPart(part)
				count = count + 1
			end
			
			if i % batchSize == 0 then
				task.wait()
			end
		end
		return count
	end
	
	RemoveNeon = vape.Categories.BoostFPS:CreateModule({
		Name = 'RemoveNeon',
		Function = function(callback)
			if callback then
				task.spawn(function()
					local allParts = {}
					for _, v in pairs(workspace:GetDescendants()) do
						if v:IsA("BasePart") then
							table.insert(allParts, v)
						end
					end
					
					batchProcessParts(allParts, 50)
				end)
				
				neonConnection = workspace.DescendantAdded:Connect(function(obj)
					if RemoveNeon.Enabled then
						removeNeonFromPart(obj)
					end
				end)
				
				safetyLoop = task.spawn(function()
					while RemoveNeon.Enabled do
						task.wait(5)
						
						if RemoveNeon.Enabled then
							local newParts = {}
							for _, v in pairs(workspace:GetDescendants()) do
								if v:IsA("BasePart") and not processedParts[v] and v.Material == Enum.Material.Neon then
									table.insert(newParts, v)
								end
							end
							
							if #newParts > 0 then
								batchProcessParts(newParts, 25)
							end
							
							if tick() - lastCleanup > 15 then
								cleanupDeadReferences()
								lastCleanup = tick()
							end
						end
					end
				end)
			else
				if neonConnection then
					neonConnection:Disconnect()
					neonConnection = nil
				end
				if safetyLoop then
					task.cancel(safetyLoop)
					safetyLoop = nil
				end
				restoreNeon()
			end
		end,
		Tooltip = 'Removes all neon materials for better FPS'
	})
end)

run(function()
	local FakePos
	local fflagWorking = false
	local fflagName = 'NextGenReplicatorEnabledWrite4'
	
	local function setFFlag(value)
		local success = pcall(function()
			setfflag(fflagName, value)
		end)
		
		if success then
			local verifySuccess, currentValue = pcall(function()
				return getfflag(fflagName)
			end)
			
			if verifySuccess and currentValue == value then
				fflagWorking = true
				return true
			end
		end
		
		fflagWorking = false
		return false
	end
	
	local function cleanup()
		pcall(function()
			setfflag(fflagName, 'false')
		end)
		
		if store.fakePosEnabled ~= nil then
			store.fakePosEnabled = nil
		end
	end
	
	FakePos = vape.Categories.Blatant:CreateModule({
		Name = "FakePos",
		Tooltip = 'Desyncs your position from the server (Fake Position)',
		Function = function(callback)
			if callback then
				local success = setFFlag('true')
				
				if success then
					store.fakePosEnabled = true
					
					task.spawn(function()
						task.wait(0.5)
						if FakePos.Enabled and fflagWorking then
							local check = pcall(function()
								return getfflag(fflagName)
							end)
							
							if not check then
								warningNotification("FakePos", "FFlag no longer available - disabling", 3)
								FakePos:Toggle()
							end
						end
					end)
				else
					warningNotification("FakePos", "FFlag not available in this Roblox version", 3)
					FakePos:Toggle()
					return
				end
			else
				cleanup()
			end
		end,
		ExtraText = function()
			return fflagWorking and "Active" or "Inactive"
		end
	})
	
	FakePos:Clean(game:GetService("Players").PlayerRemoving:Connect(function(player)
		if player == lplr then
			cleanup()
		end
	end))
	
	task.spawn(function()
		while true do
			task.wait(5)
			if not FakePos.Enabled and (store.fakePosEnabled or fflagWorking) then
				cleanup()
			end
		end
	end)
	
	cleanup()
end)

run(function()
	local RemoveEffects
	
	RemoveEffects = vape.Categories.BoostFPS:CreateModule({
		Name = "RemoveEffects",
		Function = function(callback)
			if callback then
				if not store.originalVignette then
					store.originalVignette = bedwars.VignetteController.createVignette
				end
				
				if not store.originalDebuffEffect then
					store.originalDebuffEffect = bedwars.DebuffEffectController and bedwars.DebuffEffectController.createEffect
				end
				
				if not store.originalStatusEffect then
					store.originalStatusEffect = bedwars.StatusEffectController and bedwars.StatusEffectController.createEffect
				end
				
				bedwars.VignetteController.createVignette = function(...)
					return nil
				end
				
				if bedwars.DebuffEffectController then
					bedwars.DebuffEffectController.createEffect = function(...)
						return nil
					end
				end
				
				if bedwars.StatusEffectController then
					bedwars.StatusEffectController.createEffect = function(...)
						return nil
					end
				end
				
				if bedwars.VignetteController.currentVignette then
					bedwars.VignetteController.currentVignette:Destroy()
					bedwars.VignetteController.currentVignette = nil
				end
				
				local screenGui = lplr:FindFirstChild("PlayerGui")
				if screenGui then
					for _, gui in pairs(screenGui:GetChildren()) do
						if gui:IsA("ScreenGui") and (gui.Name:find("Vignette") or gui.Name:find("Effect") or gui.Name:find("Debuff")) then
							gui:Destroy()
						end
					end
				end
				
			else
				if store.originalVignette then
					bedwars.VignetteController.createVignette = store.originalVignette
					store.originalVignette = nil
				end
				
				if store.originalDebuffEffect and bedwars.DebuffEffectController then
					bedwars.DebuffEffectController.createEffect = store.originalDebuffEffect
					store.originalDebuffEffect = nil
				end
				
				if store.originalStatusEffect and bedwars.StatusEffectController then
					bedwars.StatusEffectController.createEffect = store.originalStatusEffect
					store.originalStatusEffect = nil
				end
			end
		end,
		Tooltip = 'Removes annoying screen effects (static, glooped effects, etc.)'
	})
end)

run(function()
	local MiloExploit
	local Blocks
	local old
	MiloExploit = vape.Categories.Utility:CreateModule({
		Name = "MiloExploit",
		Function = function(callback)
			if not callback then
				return
			end

			MiloExploit:Toggle(false)
			old = bedwars.MimicController.onAbilityUsed
			bedwars.MimicController.onAbilityUsed = function(s1,s2)
				if not entitylib.isAlive then
					return nil
				end
				task.spawn(function()
					local v88 = {
						["data"] = {
							["blockType"] = Blocks.Value or 'wool_red'
						}
					}
					bedwars.Client:Get("MimicBlock"):SendToServer(v88)
				end)
			end
			if bedwars.AbilityController:canUseAbility("MIMIC_BLOCK") then
				bedwars.AbilityController:useAbility('MIMIC_BLOCK')
				task.wait(2)
				bedwars.MimicController.onAbilityUsed = old
				old = nil
			end
		end,
		Tooltip = 'Allows you to mimic any block you want without the block being there',
	})
	Blocks = MiloExploit:CreateTextBox({
		Name = "Blocks",
		Tooltip = 'Only use meta names (ex. wool_blue wool_red (like its customs))',
		Default = 'obsidian'
	})
end)

run(function()
	local Lobby
	Lobby = vape.Categories.Utility:CreateModule({
		Name = 'Lobby',
		Function = function(callback)
			if not callback then
				return
			end
			Lobby:Toggle(false)
			local s,err = pcall(function()
				bedwars.Client:Get("TeleportToLobby"):SendToServer()
			end)
			if not s then
				warn(err)
				task.wait(8)
				lobby()
			end
		end
	})
end)

run(function()
    local Fisherman
    local AutoMinigameToggle
    local CompleteDelaySlider
    local PullAnimationToggle
    local MinigameAnimationToggle
    local FishermanSpyToggle
    local IgnoreTeammatesToggle
    local ESPToggle
    local ESPNotifyToggle
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local lplr = Players.LocalPlayer
    local Folder = Instance.new('Folder')
    Folder.Parent = vape.gui
    local fishNames = {
        fish_iron = "Iron Fish",
        fish_diamond = "Diamond Fish",
        fish_gold = "Gold Fish",
        fish_special = "Special Fish",
        fish_emerald = "Emerald Fish"
    }
    local originalCreateElement = nil
    local moduleEnabled = false
    local autoMinigameActive = false
    local pullAnimationTrack = nil
    local successAnimationTrack = nil
    local roactHooked = false
    local notificationQueue = {}
    local lastNotificationTime = 0
    local NOTIFICATION_COOLDOWN = 0.5
    
    local function safeNotif(title, message, duration)
        local success, err = pcall(function()
            notif(title, message, duration or 3)
        end)
        if not success then
            warn("[Fisherman] Notification failed:", err)
        end
    end
    
    local function debugLog(message)
        if bedwars and bedwars.DebugMode then
            print("[Fisherman Debug]", message)
        end
    end
    
    local function processNotificationQueue()
        local currentTime = tick()
        
        while #notificationQueue > 0 and (currentTime - lastNotificationTime) >= NOTIFICATION_COOLDOWN do
            local fishType = table.remove(notificationQueue, 1)
            local fishName = fishNames[fishType] or fishType
            
            if ESPNotifyToggle and ESPNotifyToggle.Enabled then
                task.spawn(function()
                    notif('Fisherman ESP', 'Catching a ' .. fishName, 3)
                end)
            end
            
            lastNotificationTime = currentTime
            task.wait(0.1)
        end
    end

    
    local function stopAllAnimations()
        if pullAnimationTrack then
            pcall(function() pullAnimationTrack:Stop() end)
            pullAnimationTrack = nil
        end
        if successAnimationTrack then
            pcall(function() successAnimationTrack:Stop() end)
            successAnimationTrack = nil
        end
    end
    
    local function setupAutoMinigame()
        if not bedwars or not bedwars.FishingMinigameController then
            warn("[Fisherman] bedwars.FishingMinigameController not found!")
            return
        end
        
        local old = bedwars.FishingMinigameController.startMinigame
        
        bedwars.FishingMinigameController.startMinigame = function(self, dropData, result)
            if not AutoMinigameToggle.Enabled then
                return old(self, dropData, result)
            end
            
            autoMinigameActive = true
            
            stopAllAnimations()
            
            if PullAnimationToggle.Enabled and CompleteDelaySlider.Value > 0 then
                task.spawn(function()
                    local success, track = pcall(function()
                        return bedwars.GameAnimationUtil:playAnimation(
                            lplr, 
                            bedwars.AnimationType.FISHING_ROD_PULLING
                        )
                    end)
                    
                    if success and track then
                        pullAnimationTrack = track
                    end
                end)
            end
            
            task.spawn(function()
                if CompleteDelaySlider.Value > 0 then
                    task.wait(CompleteDelaySlider.Value)
                end
                
                if pullAnimationTrack then
                    pcall(function() pullAnimationTrack:Stop() end)
                    pullAnimationTrack = nil
                end
                
                if MinigameAnimationToggle.Enabled then
                    local success, track = pcall(function()
                        return bedwars.GameAnimationUtil:playAnimation(
                            lplr, 
                            bedwars.AnimationType.FISHING_ROD_CATCH_SUCCESS
                        )
                    end)
                    
                    if success and track then
                        successAnimationTrack = track
                    end
                end
                
                if result then
                    local success, err = pcall(function()
                        result({win = true})
                    end)
                    
                    if not success then
                        warn("[Fisherman] Failed to complete minigame:", err)
                    end
                end
                
                task.wait(0.5)
                if successAnimationTrack then
                    pcall(function() successAnimationTrack:Stop() end)
                    successAnimationTrack = nil
                end
                
                autoMinigameActive = false
            end)
        end
        
        Fisherman:Clean(function()
            bedwars.FishingMinigameController.startMinigame = old
            stopAllAnimations()
        end)
    end
    
    local function setupESP()
        if roactHooked then
            debugLog("Roact already hooked, skipping")
            return
        end
        
        task.spawn(function()
            task.wait(1)
            
            local success = pcall(function()
                local Roact = require(
                    ReplicatedStorage:WaitForChild("rbxts_include")
                    :WaitForChild("node_modules")
                    :WaitForChild("@rbxts")
                    :WaitForChild("roact")
                    :WaitForChild("src")
                )
                
                if originalCreateElement == nil then
                    originalCreateElement = Roact.createElement
                end
                
                Roact.createElement = function(component, props, ...)
                    local result = originalCreateElement(component, props, ...)
                    
                    if moduleEnabled and props and props.fishType then
                        local fishType = props.fishType
                        
                        if props.decaySpeedMultiplier then
                            table.insert(notificationQueue, fishType)
                        end
                    end
                    
                    return result
                end
                
                roactHooked = true
                debugLog("Roact successfully hooked")
            end)
            
            if not success then
                safeNotif('Fisherman ESP', 'Failed to hook ESP, try rejoining', 5)
                if ESPToggle then 
                    task.wait(0.5)
                    ESPToggle:Toggle() 
                end
            end
        end)
    end
    
    local function cleanupESP()
        if originalCreateElement and roactHooked then
            pcall(function()
                local Roact = require(
                    ReplicatedStorage:WaitForChild("rbxts_include")
                    :WaitForChild("node_modules")
                    :WaitForChild("@rbxts")
                    :WaitForChild("roact")
                    :WaitForChild("src")
                )
                Roact.createElement = originalCreateElement
                originalCreateElement = nil
                roactHooked = false
                debugLog("Roact unhooked")
            end)
        end
        
        notificationQueue = {}
    end
    
    local function setupFishermanSpy()
        if not bedwars or not bedwars.Client then
            warn("[Fisherman] bedwars.Client not found!")
            return
        end
        
        bedwars.Client:WaitFor("FishCaught"):andThen(function(rbx)
            Fisherman:Clean(rbx:Connect(function(tbl)
                local char = tbl.catchingPlayer.Character
                local fish = tbl.dropData.fishModel
                local plrName = char.Name
                local str = plrName:sub(1, 1):upper()..plrName:sub(2) or 'NIL'
                local strfish = fishNames[tostring(fish)] or 'NIL Fish'
                if IgnoreTeammatesToggle.Enabled then
                    local currentTeam = lplr.Team
                    local currentplr = Players:GetPlayerFromCharacter(char)
                    if currentplr and currentplr.Team == currentTeam then
                    else
                        notif("Fisherman Spy", str .. " has caught a " .. strfish, 8)
                    end
                else
                    notif("Fisherman Spy", str .. " has caught a " .. strfish, 8)
                end
            end))
        end)
    end
    
    Fisherman = vape.Categories.Kits:CreateModule({
        Name = 'AutoFisher',
        Function = function(callback)
            if callback then
                debugLog("module enabled")
                
                if AutoMinigameToggle.Enabled then
                    setupAutoMinigame()
                end
                
                if ESPToggle.Enabled then
                    moduleEnabled = true
                    setupESP()
                end
                
                if FishermanSpyToggle.Enabled then
                    setupFishermanSpy()
                end
                
                task.spawn(function()
                    while Fisherman.Enabled do
                        processNotificationQueue()
                        task.wait(0.1)
                    end
                end)
                
            else
                debugLog("module disabled")
                
                moduleEnabled = false
                autoMinigameActive = false
                
                stopAllAnimations()
                cleanupESP()
                
                Folder:ClearAllChildren()
            end
        end,
        Tooltip = 'All-in-one Fisherman module with auto minigame, ESP, and spy'
    })
    
    AutoMinigameToggle = Fisherman:CreateToggle({
        Name = 'Auto Minigame',
        Default = false,
        Tooltip = 'Automatically complete fishing minigame',
        Function = function(callback)
            if CompleteDelaySlider and CompleteDelaySlider.Object then 
                CompleteDelaySlider.Object.Visible = callback 
            end
            if PullAnimationToggle and PullAnimationToggle.Object then 
                PullAnimationToggle.Object.Visible = callback 
            end
            if MinigameAnimationToggle and MinigameAnimationToggle.Object then 
                MinigameAnimationToggle.Object.Visible = callback 
            end
            
            if Fisherman.Enabled and callback then
                setupAutoMinigame()
            end
        end
    })
    
    CompleteDelaySlider = Fisherman:CreateSlider({
        Name = 'Complete Delay',
        Min = 0,
        Max = 5,
        Default = 1,
        Decimal = 10,
        Suffix = 's',
        Visible = false,
        Tooltip = 'Delay before completing minigame (looks more legit)'
    })
    
    PullAnimationToggle = Fisherman:CreateToggle({
        Name = 'Pull Animation',
        Default = true,
        Visible = false,
        Tooltip = 'Play pulling animation during delay (only if delay > 0)'
    })
    
    MinigameAnimationToggle = Fisherman:CreateToggle({
        Name = 'Success Animation',
        Default = true,
        Visible = false,
        Tooltip = 'Play success animation on complete'
    })
    
    FishermanSpyToggle = Fisherman:CreateToggle({
        Name = 'Fisherman Spy',
        Default = false,
        Tooltip = 'Get notified when other players catch fish',
        Function = function(callback)
            if IgnoreTeammatesToggle and IgnoreTeammatesToggle.Object then 
                IgnoreTeammatesToggle.Object.Visible = callback 
            end
            
            if Fisherman.Enabled and callback then
                setupFishermanSpy()
            end
        end
    })
    
    IgnoreTeammatesToggle = Fisherman:CreateToggle({
        Name = 'Ignore Teammates',
        Default = true,
        Visible = false,
        Tooltip = 'Don\'t show notifications for teammates'
    })
    
    ESPToggle = Fisherman:CreateToggle({
        Name = 'Fish ESP',
        Default = false,
        Tooltip = 'Shows what fish you are catching',
        Function = function(callback)
            if ESPNotifyToggle and ESPNotifyToggle.Object then 
                ESPNotifyToggle.Object.Visible = callback 
            end
            
            if Fisherman.Enabled then
                moduleEnabled = callback
                
                if callback then
                    setupESP()
                else
                    cleanupESP()
                end
            end
        end
    })
    
    ESPNotifyToggle = Fisherman:CreateToggle({
        Name = 'Notify Fish Type',
        Default = true,
        Visible = false,
        Tooltip = 'Get notifications of fish type'
    })
    
end)

run(function()
    local RamilKit
    local AutoTornado
    local AutoMovingTornado
    local RangeSlider
    local MovingRangeSlider
    local AngleSlider
    local MaxTargets
    local Targets
    local UpdateRate
    local Animation
    local SortMethod
    
    local function isRamilKit()
        return store.equippedKit == 'airbender'
    end
    
    local function canUseAbility(abilityName)
        return bedwars.AbilityController:canUseAbility(abilityName)
    end
    
    local function useAbility(abilityName)
        bedwars.AbilityController:useAbility(abilityName)
    end
    
    RamilKit = vape.Categories.Kits:CreateModule({
        Name = 'AutoRamil',
        Function = function(callback)
            if callback then
                if not isRamilKit() then
                    vape:CreateNotification('Auto Ramil', 'Airbender kit required!', 5, 'warning')
                    RamilKit:Toggle()
                    return
                end
                task.spawn(function()
                    repeat
                        if not entitylib.isAlive then 
                            task.wait(0.1) 
                            continue 
                        end
                        local plrs = entitylib.AllPosition({
                            Range = RangeSlider.Value,
                            Wallcheck = Targets.Walls.Enabled,
                            Part = 'RootPart',
                            Players = Targets.Players.Enabled,
                            NPCs = Targets.NPCs.Enabled,
                            Limit = MaxTargets.Value,
                            Sort = sortmethods[SortMethod.Value]
                        })
                        local char = entitylib.character
                        local root = char.RootPart
                        if AutoTornado.Enabled and plrs and plrs[1] and plrs[1].RootPart then
                            local ent = plrs[1]
                            local delta = ent.RootPart.Position - root.Position
                            local localFacing = root.CFrame.LookVector * Vector3.new(1, 0, 1)
                            local angle = math.acos(localFacing:Dot((delta * Vector3.new(1, 0, 1)).Unit))
                            
                            if angle <= (math.rad(AngleSlider.Value) / 2) then
                                if canUseAbility('airbender_tornado') then
                                    if Animation.Enabled then
                                        bedwars.GameAnimationUtil:playAnimation(lplr, bedwars.AnimationType.AIRBENDER_CAST)
                                    end
                                    useAbility('airbender_tornado')
                                end
                            end
                        end
                        if AutoMovingTornado.Enabled then
                            local movingPlrs = entitylib.AllPosition({
                                Range = MovingRangeSlider.Value,
                                Wallcheck = Targets.Walls.Enabled,
                                Part = 'RootPart',
                                Players = Targets.Players.Enabled,
                                NPCs = Targets.NPCs.Enabled,
                                Limit = MaxTargets.Value,
                                Sort = sortmethods[SortMethod.Value]
                            })
                            
                            if movingPlrs and movingPlrs[1] and movingPlrs[1].RootPart then
                                local ent = movingPlrs[1]
                                local delta = ent.RootPart.Position - root.Position
                                local localFacing = root.CFrame.LookVector * Vector3.new(1, 0, 1)
                                local angle = math.acos(localFacing:Dot((delta * Vector3.new(1, 0, 1)).Unit))
                                
                                if angle <= (math.rad(AngleSlider.Value) / 2) then
                                    if canUseAbility('airbender_moving_tornado') then
                                        if Animation.Enabled then
                                            bedwars.GameAnimationUtil:playAnimation(lplr, bedwars.AnimationType.AIRBENDER_CHARGING)
                                        end
                                        useAbility('airbender_moving_tornado')
                                    end
                                end
                            end
                        end
                        
                        task.wait(1 / UpdateRate.Value)
                    until not RamilKit.Enabled
                end)
            end
        end,
        Tooltip = 'Automatically uses Ramil tornadoes on enemies'
    })
    
    AutoTornado = RamilKit:CreateToggle({
        Name = 'Auto Tornado',
        Default = true,
        Tooltip = 'Automatically use stationary tornado',
        Function = function(callback)
            if RangeSlider and RangeSlider.Object then 
                RangeSlider.Object.Visible = callback 
            end
        end
    })
    
    RangeSlider = RamilKit:CreateSlider({
        Name = 'Tornado Range',
        Min = 1,
        Max = 30,
        Default = 18,
        Visible = true,
        Suffix = function(v)
            return v == 1 and ' stud' or ' studs'
        end,
        Tooltip = 'Range for stationary tornado'
    })
    
    AutoMovingTornado = RamilKit:CreateToggle({
        Name = 'Auto Moving Tornado',
        Default = false,
        Tooltip = 'Automatically use moving tornado',
        Function = function(callback)
            if MovingRangeSlider and MovingRangeSlider.Object then
                MovingRangeSlider.Object.Visible = callback
            end
        end
    })
    
    MovingRangeSlider = RamilKit:CreateSlider({
        Name = 'Moving Range',
        Min = 1,
        Max = 35,
        Default = 20,
        Visible = false,
        Darker = true,
        Suffix = function(v)
            return v == 1 and ' stud' or ' studs'
        end,
        Tooltip = 'Range for moving tornado'
    })
    
    AngleSlider = RamilKit:CreateSlider({
        Name = 'FOV Angle',
        Min = 0,
        Max = 360,
        Default = 180,
        Suffix = '',
        Tooltip = 'Field of view angle for targeting'
    })
    
    MaxTargets = RamilKit:CreateSlider({
        Name = 'Max Targets',
        Min = 1,
        Max = 5,
        Default = 2,
        Tooltip = 'Maximum number of targets to check'
    })
    
    SortMethod = RamilKit:CreateDropdown({
        Name = 'Sort Method',
        List = {'Distance', 'Health', 'Threat', 'Damage', 'Kit', 'Angle'},
        Default = 'Distance',
        Tooltip = 'How to prioritize targets'
    })
    
    UpdateRate = RamilKit:CreateSlider({
        Name = 'Update Rate',
        Min = 1,
        Max = 60,
        Default = 20,
        Suffix = ' hz',
        Tooltip = 'How often to check for targets'
    })
    
    Targets = RamilKit:CreateTargets({
        Players = true,
        NPCs = false,
        Walls = true
    })
end)

run(function()
    local AutoWhisper
    local PlayerDropdown
    local AutoHeal
    local AutoHealSlider
    local AutoFly
    local LimitToItem
    local RefreshButton
    local running = false
    local healRunning = false
    local flyRunning = false
    local currentTarget = nil
    local currentMountedPlayer = nil
    local fallCheckTimer = 0
    local hasActivatedFly = false
    
    local function getTeammateList()
        local teammates = {}
        local myTeam = lplr:GetAttribute('Team')
        
        if not myTeam then return teammates end
        
        for _, player in playersService:GetPlayers() do
            if player ~= lplr then
                local playerTeam = player:GetAttribute('Team')
                if playerTeam and playerTeam == myTeam then
                    table.insert(teammates, player.Name)
                end
            end
        end
        
        table.sort(teammates)
        return teammates
    end
    
    local function isHoldingOwlOrb()
        if not entitylib.isAlive then return false end
        
        local inventory = store.inventory
        if inventory and inventory.inventory and inventory.inventory.hand then
            local handItem = inventory.inventory.hand
            if handItem and handItem.itemType == "owl_orb" then
                return true
            end
        end
        return false
    end
    
    local function getMountedPlayer()
        local owlTarget = lplr:GetAttribute('OwlTarget')
        if owlTarget then
            return playersService:GetPlayerByUserId(owlTarget)
        end
        return nil
    end
    
    local function demountOwl()
        pcall(function()
            game:GetService("ReplicatedStorage")
                :WaitForChild("events-@easy-games/game-core:shared/game-core-networking@getEvents.Events")
                :WaitForChild("useAbility")
                :FireServer("DEACTIVE_OWL")
            
            task.wait(0.05)
            
            game:GetService("ReplicatedStorage")
                :WaitForChild("rbxts_include")
                :WaitForChild("node_modules")
                :WaitForChild("@rbxts")
                :WaitForChild("net")
                :WaitForChild("out")
                :WaitForChild("_NetManaged")
                :WaitForChild("RemoveOwl")
                :FireServer()
        end)
        
        currentMountedPlayer = nil
    end
    
    local function mountBirdToPlayer(targetPlayer)
        if not targetPlayer or not targetPlayer.Character then return false end
        
        if LimitToItem.Enabled and not isHoldingOwlOrb() then
            return false
        end
        
        local success = false
        pcall(function()
            local result = game:GetService("ReplicatedStorage")
                :WaitForChild("rbxts_include")
                :WaitForChild("node_modules")
                :WaitForChild("@rbxts")
                :WaitForChild("net")
                :WaitForChild("out")
                :WaitForChild("_NetManaged")
                :WaitForChild("SummonOwl")
                :InvokeServer(targetPlayer)
            
            if result then
                task.wait(0.05)
                
                game:GetService("ReplicatedStorage")
                    :WaitForChild("events-@easy-games/game-core:shared/game-core-networking@getEvents.Events")
                    :WaitForChild("useAbility")
                    :FireServer("SUMMON_OWL")
                
                currentMountedPlayer = targetPlayer
                success = true
            end
        end)
        
        return success
    end
    
    local function getTargetHealth(targetPlayer)
        if not targetPlayer or not targetPlayer.Character then return 0, 100 end
        
        local health = 0
        local maxHealth = 100
        
        pcall(function()
            local character = targetPlayer.Character
            health = character:GetAttribute("Health") or (character:FindFirstChildOfClass("Humanoid") and character.Humanoid.Health) or 0
            maxHealth = character:GetAttribute("MaxHealth") or (character:FindFirstChildOfClass("Humanoid") and character.Humanoid.MaxHealth) or 100
        end)
        
        return health, maxHealth
    end
    
    local function healTarget()
        if not currentTarget then return end
        
        pcall(function()
            bedwars.Client:Get("OwlActionAbilities"):SendToServer({
                target = currentTarget,
                ability = "owl_heal"
            })
            task.wait(0.022)
            
            game:GetService("ReplicatedStorage")
                :WaitForChild("events-@easy-games/game-core:shared/game-core-networking@getEvents.Events")
                :WaitForChild("useAbility")
                :FireServer("OWL_HEAL")
        end)
    end
    
    local function isFalling(player)
        if not player or not player.Character or not player.Character.PrimaryPart then
            return false
        end
        
        local velocity = player.Character.PrimaryPart.AssemblyLinearVelocity.Y
        return velocity < -20
    end
    
    local function isAboveVoid(player)
        if not player or not player.Character or not player.Character.PrimaryPart then
            return false
        end
        
        local rayOrigin = player.Character.PrimaryPart.Position
        local rayDirection = Vector3.new(0, -1000, 0)
        
        local raycastParams = RaycastParams.new()
        raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
        raycastParams.FilterDescendantsInstances = {player.Character, gameCamera}
        raycastParams.RespectCanCollide = true
        
        local rayResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
        
        if not rayResult then
            return true
        end
        
        return rayResult.Distance > 200
    end
    
    local function activateFly()
        if not currentTarget then return end
        
        pcall(function()
            bedwars.Client:Get("OwlActionAbilities"):SendToServer({
                target = currentTarget,
                ability = "owl_lift"
            })
            task.wait(0.022)
            
            game:GetService("ReplicatedStorage")
                :WaitForChild("events-@easy-games/game-core:shared/game-core-networking@getEvents.Events")
                :WaitForChild("useAbility")
                :FireServer("OWL_LIFT")
            
            hasActivatedFly = true
            task.spawn(function()
                task.wait(85)
                hasActivatedFly = false
            end)
        end)
    end
    
    AutoWhisper = vape.Categories.Kits:CreateModule({
        Name = "AutoWhisper",
        Function = function(callback)
            running = callback
            healRunning = callback
            flyRunning = callback
            
            if callback then
                task.spawn(function()
                    while running do
                        if LimitToItem.Enabled and not isHoldingOwlOrb() then
                            task.wait(0.2)
                            continue
                        end
                        
                        local targetPlayer = playersService:FindFirstChild(PlayerDropdown.Value)
                        if targetPlayer then
                            currentTarget = targetPlayer
                            
                            local mountedTo = getMountedPlayer()
                            
                            if mountedTo ~= targetPlayer then
                                if mountedTo and mountedTo ~= targetPlayer then
                                    demountOwl()
                                    task.wait(0.3)
                                end
                                
                                if not mountedTo or mountedTo ~= targetPlayer then
                                    local success = mountBirdToPlayer(targetPlayer)
                                    if not success then
                                        task.wait(0.5)
                                    else
                                        task.wait(1)
                                    end
                                end
                            else
                                task.wait(0.5)
                            end
                        else
                            task.wait(0.5)
                        end
                    end
                end)
                
                if AutoHeal.Enabled then
                    task.spawn(function()
                        while healRunning and AutoHeal.Enabled do
                            if currentTarget and currentMountedPlayer == currentTarget then
                                local health, maxHealth = getTargetHealth(currentTarget)
                                local healthPercent = (health / maxHealth) * 100
                                
                                if healthPercent < AutoHealSlider.Value and healthPercent < 90 then
                                    healTarget()
                                    task.wait(8.5)
                                end
                            end
                            
                            task.wait(0.5)
                        end
                    end)
                end
                
                if AutoFly.Enabled then
                    task.spawn(function()
                        while flyRunning and AutoFly.Enabled do
                            if currentTarget and currentMountedPlayer == currentTarget and not hasActivatedFly then
                                if isFalling(currentTarget) and isAboveVoid(currentTarget) then
                                    fallCheckTimer = fallCheckTimer + 0.1
                                    
                                    if fallCheckTimer >= 0.5 then
                                        activateFly()
                                        fallCheckTimer = 0
                                    end
                                else
                                    fallCheckTimer = 0
                                end
                            else
                                fallCheckTimer = 0
                            end
                            
                            task.wait(0.1)
                        end
                    end)
                end
                
                AutoWhisper:Clean(playersService.PlayerAdded:Connect(function()
                    task.wait(0.5)
                    local newList = getTeammateList()
                    if PlayerDropdown then
                        PlayerDropdown:Change(newList)
                        
                        if #newList > 0 then
                            if not PlayerDropdown.Value or PlayerDropdown.Value == "" or not table.find(newList, PlayerDropdown.Value) then
                                PlayerDropdown:SetValue(newList[1])
                            end
                        end
                    end
                end))
                
                AutoWhisper:Clean(playersService.PlayerRemoving:Connect(function(player)
                    task.wait(0.5)
                    local newList = getTeammateList()
                    if PlayerDropdown then
                        PlayerDropdown:Change(newList)
                        
                        if #newList > 0 then
                            if not PlayerDropdown.Value or PlayerDropdown.Value == "" or not table.find(newList, PlayerDropdown.Value) then
                                PlayerDropdown:SetValue(newList[1])
                            end
                        end
                    end
                    
                    if currentTarget == player then
                        currentTarget = nil
                        currentMountedPlayer = nil
                    end
                end))
                
                AutoWhisper:Clean(lplr:GetAttributeChangedSignal('Team'):Connect(function()
                    task.wait(0.5)
                    local newList = getTeammateList()
                    if PlayerDropdown then
                        PlayerDropdown:Change(newList)
                        
                        if #newList > 0 then
                            if not PlayerDropdown.Value or PlayerDropdown.Value == "" or not table.find(newList, PlayerDropdown.Value) then
                                PlayerDropdown:SetValue(newList[1])
                            end
                        end
                    end
                    currentTarget = nil
                    currentMountedPlayer = nil
                    hasActivatedFly = false
                end))
                
            else
                running = false
                healRunning = false
                flyRunning = false
                currentTarget = nil
                currentMountedPlayer = nil
                hasActivatedFly = false
                fallCheckTimer = 0
            end
        end,
        Tooltip = "Automatically mount bird to teammate, heal them, and save from void"
    })
    
    PlayerDropdown = AutoWhisper:CreateDropdown({
        Name = "Mount Target",
        List = {},
        Function = function(val)
            if val then
                local targetPlayer = playersService:FindFirstChild(val)
                if targetPlayer then
                    currentTarget = targetPlayer
                end
            end
        end,
        Tooltip = "Select teammate to mount owl to"
    })
    
    RefreshButton = AutoWhisper:CreateButton({
        Name = "Refresh Teammates",
        Function = function()
            task.spawn(function()
                local newList = getTeammateList()
                
                if PlayerDropdown then
                    pcall(function()
                        PlayerDropdown:Change(newList)
                        
                        if #newList > 0 then
                            if not PlayerDropdown.Value or PlayerDropdown.Value == "" or not table.find(newList, PlayerDropdown.Value) then
                                PlayerDropdown:SetValue(newList[1])
                            else
                                PlayerDropdown:SetValue(PlayerDropdown.Value)
                            end
                        end
                    end)
                end
                
                notif("Auto Whisper", string.format("Refreshed teammate list (%d teammates)", #newList), 2)
            end)
        end,
        Tooltip = "Manually refresh the teammate list"
    })
    
    LimitToItem = AutoWhisper:CreateToggle({
        Name = "Limit to Owl Orb",
        Default = true,
        Function = function(val)
        end,
        Tooltip = "Only mount owl when holding owl_orb item"
    })
    
    AutoHeal = AutoWhisper:CreateToggle({
        Name = "Auto Heal",
        Default = true,
        Function = function(val)
            if AutoHealSlider and AutoHealSlider.Object then
                AutoHealSlider.Object.Visible = val
            end
            
            if AutoWhisper.Enabled then
                if val then
                    healRunning = true
                    task.spawn(function()
                        while healRunning and AutoHeal.Enabled do
                            if currentTarget and currentMountedPlayer == currentTarget then
                                local health, maxHealth = getTargetHealth(currentTarget)
                                local healthPercent = (health / maxHealth) * 100
                                
                                if healthPercent < AutoHealSlider.Value and healthPercent < 90 then
                                    healTarget()
                                    task.wait(8.5)
                                end
                            end
                            
                            task.wait(0.5)
                        end
                    end)
                else
                    healRunning = false
                end
            end
        end,
        Tooltip = "Automatically heal target when health drops below threshold"
    })
    
    AutoHealSlider = AutoWhisper:CreateSlider({
        Name = "Heal Threshold",
        Min = 1,
        Max = 100,
        Default = 50,
        Suffix = "%",
        Tooltip = "Heal when target's health drops below this percentage (stops at 90%)"
    })
    
    AutoFly = AutoWhisper:CreateToggle({
        Name = "Auto Fly",
        Default = true,
        Function = function(val)
            if AutoWhisper.Enabled then
                if val then
                    flyRunning = true
                    hasActivatedFly = false
                    fallCheckTimer = 0
                    
                    task.spawn(function()
                        while flyRunning and AutoFly.Enabled do
                            if currentTarget and currentMountedPlayer == currentTarget and not hasActivatedFly then
                                if isFalling(currentTarget) and isAboveVoid(currentTarget) then
                                    fallCheckTimer = fallCheckTimer + 0.1
                                    
                                    if fallCheckTimer >= 0.5 then
                                        activateFly()
                                        fallCheckTimer = 0
                                    end
                                else
                                    fallCheckTimer = 0
                                end
                            else
                                fallCheckTimer = 0
                            end
                            
                            task.wait(0.1)
                        end
                    end)
                else
                    flyRunning = false
                    hasActivatedFly = false
                    fallCheckTimer = 0
                end
            end
        end,
        Tooltip = "Automatically activate lift when target is falling into void"
    })
end)

run(function()
    local Eldertree
    local CollectionToggle
    local Animation
    local CollectionDelay
    local DelaySlider
    local RangeSlider
    local ESPToggle
    local ESPNotify
    local ESPBackground
    local ESPColor
    local SwordCheck
    
    local Folder = Instance.new('Folder')
    Folder.Parent = vape.gui
    local Reference = {}
    local lastNotification = 0
    local spawnQueue = {}
    local notificationCooldown = 1
    local collectionRunning = false

    local function sendNotification(count)
        notif("Eldertree ESP", string.format("%d orbs spawned", count), 3)
    end

    local function processSpawnQueue()
        if #spawnQueue > 0 then
            local currentTime = tick()
            if currentTime - lastNotification >= notificationCooldown then
                sendNotification(#spawnQueue)
                lastNotification = currentTime
                spawnQueue = {}
            else
                task.delay(notificationCooldown - (currentTime - lastNotification), function()
                    if #spawnQueue > 0 then
                        sendNotification(#spawnQueue)
                        spawnQueue = {}
                    end
                end)
            end
        end
    end

    local function isHoldingSword()
        if not store.hand or not store.hand.tool then return false end
        local meta = bedwars.ItemMeta[store.hand.tool.Name]
        return meta and meta.sword
    end

    local function getProperImage()
        return bedwars.getIcon({itemType = 'natures_essence_1'}, true)
    end

    local function Added(v)
        if Reference[v] then return end
        
        local billboard = Instance.new('BillboardGui')
        billboard.Parent = Folder
        billboard.Name = 'treeOrb'
        billboard.StudsOffsetWorldSpace = Vector3.new(0, 3, 0)
        billboard.Size = UDim2.fromOffset(36, 36)
        billboard.AlwaysOnTop = true
        billboard.ClipsDescendants = false
        billboard.Adornee = v
        
        local blur = addBlur(billboard)
        blur.Visible = ESPBackground.Enabled
        
        local image = Instance.new('ImageLabel')
        image.Size = UDim2.fromOffset(36, 36)
        image.Position = UDim2.fromScale(0.5, 0.5)
        image.AnchorPoint = Vector2.new(0.5, 0.5)
        image.BackgroundColor3 = Color3.fromHSV(ESPColor.Hue, ESPColor.Sat, ESPColor.Value)
        image.BackgroundTransparency = 1 - (ESPBackground.Enabled and ESPColor.Opacity or 0)
        image.BorderSizePixel = 0
        image.Image = getProperImage()
        image.Parent = billboard
        
        local uicorner = Instance.new('UICorner')
        uicorner.CornerRadius = UDim.new(0, 4)
        uicorner.Parent = image
        
        Reference[v] = billboard
        
        if ESPNotify.Enabled then
            table.insert(spawnQueue, {item = 'orb', time = tick()})
            processSpawnQueue()
        end
    end

    local function Removed(v)
        if Reference[v] then
            Reference[v]:Destroy()
            Reference[v] = nil
        end
    end

    local function setupESP()
        for _, v in collectionService:GetTagged('treeOrb') do
            if v:IsA("Model") and v.PrimaryPart then
                Added(v.PrimaryPart)
            end
        end

        Eldertree:Clean(collectionService:GetInstanceAddedSignal('treeOrb'):Connect(function(v)
            if v:IsA("Model") and v.PrimaryPart then
                task.wait(0.1)
                Added(v.PrimaryPart)
            end
        end))

        Eldertree:Clean(collectionService:GetInstanceRemovedSignal('treeOrb'):Connect(function(v)
            if v.PrimaryPart then
                Removed(v.PrimaryPart)
            end
        end))
        
        Eldertree:Clean(runService.RenderStepped:Connect(function()
            if not ESPToggle.Enabled then return end
            
            for v, billboard in pairs(Reference) do
                if not v or not v.Parent then
                    Removed(v)
                    continue
                end

                local shouldShow = true

				if SwordCheck.Enabled and isHoldingSword() then
					shouldShow = false
				end

                billboard.Enabled = shouldShow
            end
        end))
    end

	local function collectOrb(orb)
		if not orb or not orb.Parent then return false end
		
		local treeOrbSecret = orb:GetAttribute('TreeOrbSecret')
		if not treeOrbSecret then return false end
		
		if entitylib.isAlive then
			bedwars.GameAnimationUtil:playAnimation(lplr, bedwars.AnimationType.PUNCH)
			bedwars.ViewmodelController:playAnimation(bedwars.AnimationType.FP_USE_ITEM)
			bedwars.SoundManager:playSound(bedwars.SoundList.CROP_HARVEST)
		end
		
		local success = bedwars.Client:Get('ConsumeTreeOrb'):CallServer({
			treeOrbSecret = treeOrbSecret
		})
		
		if success then
			orb:Destroy()
			return true
		end
		return false
	end

    local function startCollection()
        collectionRunning = true
        task.spawn(function()
            while collectionRunning and Eldertree.Enabled and CollectionToggle.Enabled do
                if not entitylib.isAlive then 
                    task.wait(0.1) 
                    continue 
                end
                
                local localPosition = entitylib.character.RootPart.Position
                local range = RangeSlider.Value
                local orbsFound = false
                
                for _, v in collectionService:GetTagged('treeOrb') do
                    if not collectionRunning or not Eldertree.Enabled or not CollectionToggle.Enabled then 
                        break 
                    end
                    
                    if v:IsA("Model") and v.PrimaryPart then
                        local orbPos = v.PrimaryPart.Position
                        local distance = (localPosition - orbPos).Magnitude
                        
                        if distance <= range then
                            orbsFound = true
                            
                            if CollectionDelay.Enabled and DelaySlider.Value > 0 then
                                task.wait(DelaySlider.Value)
                            end
                            
                            if collectOrb(v) then
                                task.wait(0.1)
                            end
                        end
                    end
                end
                
                if not orbsFound then
                    task.wait(0.2)
                else
                    task.wait(0.1)
                end
            end
            collectionRunning = false
        end)
    end

    Eldertree = vape.Categories.Kits:CreateModule({
        Name = 'AutoEldertree',
        Function = function(callback)
            if callback then
                if ESPToggle.Enabled then 
                    setupESP() 
                end
                
                if CollectionToggle.Enabled then
                    startCollection()
                end
            else
                collectionRunning = false
                Folder:ClearAllChildren()
                table.clear(Reference)
                table.clear(spawnQueue)
                lastNotification = 0
            end
        end,
        Tooltip = 'automatically collects tree orbs and esp'
    })
    
    CollectionToggle = Eldertree:CreateToggle({
        Name = 'Auto Collect',
        Default = true,
        Tooltip = 'automatically collect tree orbs',
        Function = function(callback)
            if Animation and Animation.Object then Animation.Object.Visible = callback end
            if CollectionDelay and CollectionDelay.Object then CollectionDelay.Object.Visible = callback end
            if DelaySlider and DelaySlider.Object then DelaySlider.Object.Visible = (callback and CollectionDelay.Enabled) end
            if RangeSlider and RangeSlider.Object then RangeSlider.Object.Visible = callback end
            
            if callback and Eldertree.Enabled then
                startCollection()
            else
                collectionRunning = false
            end
        end
    })
    
    Animation = Eldertree:CreateToggle({
        Name = 'Animation',
        Default = true,
        Tooltip = 'play collection animation and sound'
    })
    
    CollectionDelay = Eldertree:CreateToggle({
        Name = 'Collection Delay',
        Default = false,
        Tooltip = 'add delay before collecting orbs',
        Function = function(callback)
            if DelaySlider and DelaySlider.Object then
                DelaySlider.Object.Visible = callback
            end
        end
    })
    
    DelaySlider = Eldertree:CreateSlider({
        Name = 'Delay',
        Min = 0,
        Max = 2,
        Default = 0.5,
        Decimal = 10,
        Suffix = 's',
        Tooltip = 'delay in seconds before collecting'
    })
    
    RangeSlider = Eldertree:CreateSlider({
        Name = 'Range',
        Min = 1, 
        Max = 20,
        Default = 10,
        Decimal = 1,
        Suffix = ' studs',
        Tooltip = 'control distance you want to collect orbs'
    })

    ESPToggle = Eldertree:CreateToggle({
        Name = 'Eldertree ESP',
        Default = false,
        Tooltip = 'shows tree orb locations',
        Function = function(callback)
            if ESPNotify and ESPNotify.Object then ESPNotify.Object.Visible = callback end
            if ESPBackground and ESPBackground.Object then ESPBackground.Object.Visible = callback end
            if ESPColor and ESPColor.Object then ESPColor.Object.Visible = callback end
            if SwordCheck and SwordCheck.Object then SwordCheck.Object.Visible = callback end
            
            if Eldertree.Enabled then
                if callback then 
                    setupESP() 
                else
                    Folder:ClearAllChildren()
                    table.clear(Reference)
                end
            end
        end
    })
    
    ESPNotify = Eldertree:CreateToggle({
        Name = 'Notify',
        Default = false,
        Tooltip = 'get notifications when orbs spawn'
    })
    
    ESPBackground = Eldertree:CreateToggle({
        Name = 'Background',
        Default = true,
        Function = function(callback)
            if ESPColor and ESPColor.Object then ESPColor.Object.Visible = callback end
            for _, v in Reference do
                if v and v:FindFirstChild("ImageLabel") then
                    v.ImageLabel.BackgroundTransparency = 1 - (callback and ESPColor.Opacity or 0)
                    if v:FindFirstChild("Blur") then
                        v.Blur.Visible = callback
                    end
                end
            end
        end
    })
    
    ESPColor = Eldertree:CreateColorSlider({
        Name = 'Background Color',
        DefaultValue = 0,
        DefaultOpacity = 0.5,
        Function = function(hue, sat, val, opacity)
            for _, v in Reference do
                if v and v:FindFirstChild("ImageLabel") then
                    v.ImageLabel.BackgroundColor3 = Color3.fromHSV(hue, sat, val)
                    v.ImageLabel.BackgroundTransparency = 1 - opacity
                end
            end
        end,
        Darker = true
    })
    SwordCheck = Eldertree:CreateToggle({
        Name = 'Sword Check',
        Default = false,
        Tooltip = 'only show esp when holding a sword'
    })
end)

run(function()
    local StarCollector
    local CollectionToggle
    local Animation
    local CollectionDelay
    local DelaySlider
    local RangeSlider
    local ESPToggle
    local ESPNotify
    local ESPBackground
    local ESPColor
    local SwordCheck
    local Folder = Instance.new('Folder')
    Folder.Parent = vape.gui
    local Reference = {}
    local lastNotification = 0
    local spawnQueue = {}
    local notificationCooldown = 1
    local collectionRunning = false

    local function sendNotification(count)
        notif("Star ESP", string.format("%d stars spawned", count), 3)
    end

    local function processSpawnQueue()
        if #spawnQueue > 0 then
            local currentTime = tick()
            if currentTime - lastNotification >= notificationCooldown then
                sendNotification(#spawnQueue)
                lastNotification = currentTime
                spawnQueue = {}
            else
                task.delay(notificationCooldown - (currentTime - lastNotification), function()
                    if #spawnQueue > 0 then
                        sendNotification(#spawnQueue)
                        spawnQueue = {}
                    end
                end)
            end
        end
    end

    local function isHoldingSword()
        if not store.hand or not store.hand.tool then return false end
        local meta = bedwars.ItemMeta[store.hand.tool.Name]
        return meta and meta.sword
    end

    local function getProperImage(v)
        local parent = v.Parent
        if parent and parent:IsA("Model") then
            local modelName = parent.Name
            if modelName == "CritStar" then
                return bedwars.getIcon({itemType = 'crit_star'}, true)
            elseif modelName == "VitalityStar" then
                return bedwars.getIcon({itemType = 'vitality_star'}, true)
            elseif modelName:find("vitality") or modelName:lower():find("vitality") then
                return bedwars.getIcon({itemType = 'vitality_star'}, true)
            elseif modelName:find("crit") or modelName:lower():find("crit") then
                return bedwars.getIcon({itemType = 'crit_star'}, true)
            end
        end
        return bedwars.getIcon({itemType = 'crit_star'}, true)
    end

    local function Added(v)
        if Reference[v] then return end
        
        local billboard = Instance.new('BillboardGui')
        billboard.Parent = Folder
        billboard.Name = 'stars'
        billboard.StudsOffsetWorldSpace = Vector3.new(0, 3, 0)
        billboard.Size = UDim2.fromOffset(36, 36)
        billboard.AlwaysOnTop = true
        billboard.ClipsDescendants = false
        billboard.Adornee = v
        
        local blur = addBlur(billboard)
        blur.Visible = ESPBackground.Enabled
        
        local image = Instance.new('ImageLabel')
        image.Size = UDim2.fromOffset(36, 36)
        image.Position = UDim2.fromScale(0.5, 0.5)
        image.AnchorPoint = Vector2.new(0.5, 0.5)
        image.BackgroundColor3 = Color3.fromHSV(ESPColor.Hue, ESPColor.Sat, ESPColor.Value)
        image.BackgroundTransparency = 1 - (ESPBackground.Enabled and ESPColor.Opacity or 0)
        image.BorderSizePixel = 0
        image.Image = getProperImage(v)
        image.Parent = billboard
        
        local uicorner = Instance.new('UICorner')
        uicorner.CornerRadius = UDim.new(0, 4)
        uicorner.Parent = image
        
        Reference[v] = billboard
        
        if ESPNotify.Enabled then
            table.insert(spawnQueue, {item = 'star', time = tick()})
            processSpawnQueue()
        end
    end

    local function Removed(v)
        if Reference[v] then
            Reference[v]:Destroy()
            Reference[v] = nil
        end
    end

    local function setupESP()
        for _, v in collectionService:GetTagged('stars') do
            if v:IsA("Model") and v.PrimaryPart then
                Added(v.PrimaryPart)
            end
        end

        StarCollector:Clean(collectionService:GetInstanceAddedSignal('stars'):Connect(function(v)
            if v:IsA("Model") and v.PrimaryPart then
                task.wait(0.1)
                Added(v.PrimaryPart)
            end
        end))

        StarCollector:Clean(collectionService:GetInstanceRemovedSignal('stars'):Connect(function(v)
            if v.PrimaryPart then
                Removed(v.PrimaryPart)
            end
        end))
        
        StarCollector:Clean(runService.RenderStepped:Connect(function()
            if not ESPToggle.Enabled then return end
            
            for v, billboard in pairs(Reference) do
                if not v or not v.Parent then
                    Removed(v)
                    continue
                end

                local shouldShow = true

				if SwordCheck.Enabled and isHoldingSword() then
					shouldShow = false
				end

                billboard.Enabled = shouldShow
            end
        end))
    end

    local function collectStar(star)
        if not star or not star.Parent then return false end
        
        if Animation.Enabled and entitylib.isAlive then
            bedwars.GameAnimationUtil:playAnimation(lplr, bedwars.AnimationType.PUNCH)
            bedwars.ViewmodelController:playAnimation(bedwars.AnimationType.FP_USE_ITEM)
            bedwars.SoundManager:playSound(bedwars.SoundList.CROP_HARVEST)
        end
        
        bedwars.StarCollectorController:collectEntity(lplr, star, star.Name)
        
        return true
    end

    local function startCollection()
        collectionRunning = true
        task.spawn(function()
            while collectionRunning and StarCollector.Enabled and CollectionToggle.Enabled do
                if not entitylib.isAlive then 
                    task.wait(0.1) 
                    continue 
                end
                
                local localPosition = entitylib.character.RootPart.Position
                local range = RangeSlider.Value
                local starsFound = false
                
                for _, v in collectionService:GetTagged('stars') do
                    if not collectionRunning or not StarCollector.Enabled or not CollectionToggle.Enabled then 
                        break 
                    end
                    
                    if v:IsA("Model") and v.PrimaryPart then
                        local starPos = v.PrimaryPart.Position
                        local distance = (localPosition - starPos).Magnitude
                        
                        if distance <= range then
                            starsFound = true
                            
                            if CollectionDelay.Enabled and DelaySlider.Value > 0 then
                                task.wait(DelaySlider.Value)
                            end
                            
                            if collectStar(v) then
                                task.wait(0.1)
                            end
                        end
                    end
                end
                
                if not starsFound then
                    task.wait(0.2)
                else
                    task.wait(0.1)
                end
            end
            collectionRunning = false
        end)
    end

    StarCollector = vape.Categories.Kits:CreateModule({
        Name = 'AutoStar',
        Function = function(callback)
            if callback then
                if ESPToggle.Enabled then 
                    setupESP() 
                end
                
                if CollectionToggle.Enabled then
                    startCollection()
                end
            else
                collectionRunning = false
                Folder:ClearAllChildren()
                table.clear(Reference)
                table.clear(spawnQueue)
                lastNotification = 0
            end
        end,
        Tooltip = 'automatically collects stars and esp'
    })
    
    CollectionToggle = StarCollector:CreateToggle({
        Name = 'Auto Collect',
        Default = true,
        Tooltip = 'automatically collect stars',
        Function = function(callback)
            if Animation and Animation.Object then Animation.Object.Visible = callback end
            if CollectionDelay and CollectionDelay.Object then CollectionDelay.Object.Visible = callback end
            if DelaySlider and DelaySlider.Object then DelaySlider.Object.Visible = (callback and CollectionDelay.Enabled) end
            if RangeSlider and RangeSlider.Object then RangeSlider.Object.Visible = callback end
            
            if callback and StarCollector.Enabled then
                startCollection()
            else
                collectionRunning = false
            end
        end
    })
    
    Animation = StarCollector:CreateToggle({
        Name = 'Animation',
        Default = true,
        Tooltip = 'play collection animation and sound'
    })
    
    CollectionDelay = StarCollector:CreateToggle({
        Name = 'Collection Delay',
        Default = false,
        Tooltip = 'add delay before collecting stars',
        Function = function(callback)
            if DelaySlider and DelaySlider.Object then
                DelaySlider.Object.Visible = callback
            end
        end
    })
    
    DelaySlider = StarCollector:CreateSlider({
        Name = 'Delay',
        Min = 0,
        Max = 2,
        Default = 0.5,
        Decimal = 10,
        Suffix = 's',
        Tooltip = 'delay in seconds before collecting'
    })
    
    RangeSlider = StarCollector:CreateSlider({
        Name = 'Range',
        Min = 1, 
        Max = 20,
        Default = 10,
        Decimal = 1,
        Suffix = ' studs',
        Tooltip = 'control distance you want to collect stars'
    })
    
    ESPToggle = StarCollector:CreateToggle({
        Name = 'Star ESP',
        Default = false,
        Tooltip = 'shows star locations',
        Function = function(callback)
            if ESPNotify and ESPNotify.Object then ESPNotify.Object.Visible = callback end
            if ESPBackground and ESPBackground.Object then ESPBackground.Object.Visible = callback end
            if ESPColor and ESPColor.Object then ESPColor.Object.Visible = callback end
            if SwordCheck and SwordCheck.Object then SwordCheck.Object.Visible = callback end
            
            if StarCollector.Enabled then
                if callback then 
                    setupESP() 
                else
                    Folder:ClearAllChildren()
                    table.clear(Reference)
                end
            end
        end
    })
    
    ESPNotify = StarCollector:CreateToggle({
        Name = 'Notify',
        Default = false,
        Tooltip = 'get notifications when stars spawn'
    })
    
    ESPBackground = StarCollector:CreateToggle({
        Name = 'Background',
        Default = true,
        Function = function(callback)
            if ESPColor and ESPColor.Object then ESPColor.Object.Visible = callback end
            for _, v in Reference do
                if v and v:FindFirstChild("ImageLabel") then
                    v.ImageLabel.BackgroundTransparency = 1 - (callback and ESPColor.Opacity or 0)
                    if v:FindFirstChild("Blur") then
                        v.Blur.Visible = callback
                    end
                end
            end
        end
    })
    
    ESPColor = StarCollector:CreateColorSlider({
        Name = 'Background Color',
        DefaultValue = 0,
        DefaultOpacity = 0.5,
        Function = function(hue, sat, val, opacity)
            for _, v in Reference do
                if v and v:FindFirstChild("ImageLabel") then
                    v.ImageLabel.BackgroundColor3 = Color3.fromHSV(hue, sat, val)
                    v.ImageLabel.BackgroundTransparency = 1 - opacity
                end
            end
        end,
        Darker = true
    })
    SwordCheck = StarCollector:CreateToggle({
        Name = 'Sword Check',
        Default = false,
        Tooltip = 'only show esp when holding a sword'
    })
end)

run(function()
    local Melody
    local SelfHeal
    local TeammateHeal
    local RangeSlider
    local healRunning = false
    local lastHealTime = 0
    local healCooldown = 1

    local function getItem(itemName)
        if not entitylib.isAlive then return false end
        
        local inventory = store.inventory
        if inventory and inventory.inventory and inventory.inventory.hand then
            local handItem = inventory.inventory.hand
            if handItem and handItem.itemType == itemName then
                return true
            end
        end
        return false
    end

    local function getLowestHealthTeammate()
        if not entitylib.isAlive then return nil end
        
        local localPosition = entitylib.character.RootPart.Position
        local range = RangeSlider.Value
        local lowestHp = math.huge
        local targetEntity = nil
        
        for _, v in entitylib.List do
            if v.Player and v.Player ~= lplr and v.Player:GetAttribute('Team') == lplr:GetAttribute('Team') then
                local distance = (localPosition - v.RootPart.Position).Magnitude
                
                if distance <= range and v.Health < lowestHp and v.Health < v.MaxHealth then
                    lowestHp = v.Health
                    targetEntity = v
                end
            end
        end
        
        return targetEntity
    end

    local function shouldSelfHeal()
        if not entitylib.isAlive then return false end
        
        local currentHealth = lplr.Character:GetAttribute('Health') or 0
        local maxHealth = lplr.Character:GetAttribute('MaxHealth') or 100
        
        return currentHealth < maxHealth
    end

    local function performHeal(target)
        local currentTime = tick()
        if currentTime - lastHealTime < healCooldown then
            return false
        end
        
        if not getItem('guitar') then
            return false
        end
        
        bedwars.Client:Get(remotes.GuitarHeal):SendToServer({
            healTarget = target
        })
        
        lastHealTime = currentTime
        return true
    end

    local function startHealing()
        healRunning = true
        task.spawn(function()
            while healRunning and Melody.Enabled do
                if not entitylib.isAlive then
                    task.wait(0.1)
                    continue
                end
                
                if not getItem('guitar') then
                    task.wait(0.2)
                    continue
                end
                
                local healed = false
                
                if SelfHeal.Enabled and shouldSelfHeal() then
                    if performHeal(lplr.Character) then
                        healed = true
                    end
                end
                
                if not healed and TeammateHeal.Enabled then
                    local teammate = getLowestHealthTeammate()
                    if teammate then
                        if performHeal(teammate.Character) then
                            healed = true
                        end
                    end
                end
                
                task.wait(0.1)
            end
            healRunning = false
        end)
    end

    Melody = vape.Categories.Kits:CreateModule({
        Name = 'AutoMelody',
        Function = function(callback)
            if callback then
                lastHealTime = 0
                startHealing()
            else
                healRunning = false
                lastHealTime = 0
            end
        end,
        Tooltip = 'Automatically heals yourself and teammates with guitar'
    })
    
    SelfHeal = Melody:CreateToggle({
        Name = 'Self Heal',
        Default = true,
        Tooltip = 'Automatically heal yourself when damaged'
    })
    
    TeammateHeal = Melody:CreateToggle({
        Name = 'Teammate Heal',
        Default = true,
        Tooltip = 'Automatically heal teammates when damaged',
        Function = function(callback)
            if RangeSlider and RangeSlider.Object then
                RangeSlider.Object.Visible = callback
            end
        end
    })
    
    RangeSlider = Melody:CreateSlider({
        Name = 'Range',
        Min = 1,
        Max = 51,
        Default = 30,
        Decimal = 1,
        Suffix = ' studs',
        Tooltip = 'Maximum distance to heal teammates'
    })
end)

run(function()
    local Zeno
    local Targets
    local TargetPriority
    local HealthMode
    local ArmorMode
    local LightningStrike
    local LightningStorm
    local AutoShockwave
    local ShockwaveRange
    local AbilityRange
    local abilityRunning = false
    local lastAbilityUse = 0
    local lastShockwaveUse = 0
    local damageTracker = {}
    local rayCheck = RaycastParams.new()
    rayCheck.FilterType = Enum.RaycastFilterType.Include
    rayCheck.FilterDescendantsInstances = {workspace:FindFirstChild('Map') or workspace}
    
    local armors = {
        'none',
        'leather_chestplate',
        'iron_chestplate',
        'diamond_chestplate',
        'emerald_chestplate'
    }
    
    local function getArmorTier(player)
        if not player or not store.inventories[player] then return 0 end
        local inventory = store.inventories[player]
        local chestplate = inventory.armor and inventory.armor[5]
        if not chestplate or chestplate == 'empty' then return 1 end
        return table.find(armors, chestplate.itemType) or 1
    end
    
    local function isEnemy(ent)
        if not ent then return false end
        
        if ent.Player then
            local myTeam = lplr:GetAttribute('Team')
            local theirTeam = ent.Player:GetAttribute('Team')
            if not myTeam or not theirTeam or myTeam == theirTeam then
                return false
            end
            return select(2, whitelist:get(ent.Player))
        elseif ent.NPC then
            local npcTeam = ent.Character:GetAttribute('Team')
            if npcTeam then
                local myTeam = lplr:GetAttribute('Team')
                return myTeam ~= npcTeam
            end
            return true
        end
        
        return false
    end
    
    local function trackDamage(entity, damage)
        local key = entity.Player and entity.Player.UserId or tostring(entity)
        if not damageTracker[key] then
            damageTracker[key] = 0
        end
        damageTracker[key] = damageTracker[key] + (damage or 1)
    end
    
    local function getMostDamagedEntity()
        local highestDamage = 0
        local targetKey = nil
        
        for key, damage in pairs(damageTracker) do
            if damage > highestDamage then
                highestDamage = damage
                targetKey = key
            end
        end
        
        if not targetKey then return nil end
        
        for _, ent in entitylib.List do
            local key = ent.Player and ent.Player.UserId or tostring(ent)
            if key == targetKey and ent.RootPart and isEnemy(ent) then
                return ent
            end
        end
        
        return nil
    end
    
    local function getTargetByPriority(originPos, range)
        if TargetPriority.Value == 'Damaged' then
            local target = getMostDamagedEntity()
            if target and target.RootPart then
                local distance = (target.RootPart.Position - originPos).Magnitude
                if distance <= range then
                    return target
                end
            end
        end
        
        local validTargets = {}
        
        for _, ent in entitylib.List do
            if ent.Player and not isEnemy(ent) then continue end
            if ent.NPC and not isEnemy(ent) then continue end
            if not Targets.Players.Enabled and ent.Player then continue end
            if not Targets.NPCs.Enabled and ent.NPC then continue end
            if not ent.Character or not ent.RootPart then continue end
            
            local distance = (ent.RootPart.Position - originPos).Magnitude
            if distance > range then continue end
            
            if Targets.Walls.Enabled then
                local ray = workspace:Raycast(originPos, (ent.RootPart.Position - originPos), rayCheck)
                if ray then continue end
            end
            
            table.insert(validTargets, ent)
        end
        
        if #validTargets == 0 then return nil end
        
        if TargetPriority.Value == 'Health' then
            table.sort(validTargets, function(a, b)
                local healthA = (a.Character:GetAttribute("Health") or a.Humanoid.Health)
                local healthB = (b.Character:GetAttribute("Health") or b.Humanoid.Health)
                if HealthMode.Value == 'Lowest' then
                    return healthA < healthB
                else
                    return healthA > healthB
                end
            end)
        elseif TargetPriority.Value == 'Armor' then
            table.sort(validTargets, function(a, b)
                local armorA = a.Player and getArmorTier(a.Player) or 1
                local armorB = b.Player and getArmorTier(b.Player) or 1
                if ArmorMode.Value == 'Weakest' then
                    return armorA < armorB
                else
                    return armorA > armorB
                end
            end)
        else
            table.sort(validTargets, function(a, b)
                local distA = (a.RootPart.Position - originPos).Magnitude
                local distB = (b.RootPart.Position - originPos).Magnitude
                return distA < distB
            end)
        end
        
        return validTargets[1]
    end

    local function isHoldingWizardStaff()
        if not store.hand or not store.hand.tool then return false end
        local itemType = store.hand.tooltype or store.hand.tool.Name
        return itemType and (itemType:find("wizard_staff") or itemType:find("zeno"))
    end
    
    local function useAbility(abilityType, targetPos)
        local success = pcall(function()
            local remote = game:GetService("ReplicatedStorage"):WaitForChild("events-@easy-games/game-core:shared/game-core-networking@getEvents.Events"):WaitForChild("useAbility")
            remote:FireServer(abilityType, {
                target = targetPos
            })
        end)
        
        if success then
            lastAbilityUse = tick()
        end
        
        return success
    end
    
    local function performShockwave()
        if not AutoShockwave.Enabled then return false end
        if not entitylib.isAlive then return false end
        if not isHoldingWizardStaff() then return false end
        
        local currentTime = tick()
        if (currentTime - lastShockwaveUse) < 1 then
            return false
        end
        
        local originPos = entitylib.character.RootPart.Position
        local shockRange = ShockwaveRange.Value
        
        local nearbyEnemies = 0
        for _, ent in entitylib.List do
            if ent.RootPart then
                local isValidEnemy = false
                
                if Targets.Players.Enabled and ent.Player and ent.Player ~= lplr then
                    isValidEnemy = isEnemy(ent)
                elseif Targets.NPCs.Enabled and ent.NPC then
                    isValidEnemy = isEnemy(ent)
                end
                
                if isValidEnemy then
                    local distance = (ent.RootPart.Position - originPos).Magnitude
                    if distance <= shockRange then
                        nearbyEnemies = nearbyEnemies + 1
                    end
                end
            end
        end
        
        if nearbyEnemies > 0 then
            local success = pcall(function()
                game:GetService("ReplicatedStorage"):WaitForChild("events-@easy-games/game-core:shared/game-core-networking@getEvents.Events"):WaitForChild("useAbility"):FireServer("SHOCKWAVE", {
                    target = Vector3.zero
                })
            end)
            
            if success then
                lastShockwaveUse = currentTime
                return true
            end
        end
        
        return false
    end

    local function performLightningAbility()
        if not entitylib.isAlive then return false end
        if not isHoldingWizardStaff() then return false end

        local originPos = entitylib.character.RootPart.Position
        local range = AbilityRange.Value
        local target = getTargetByPriority(originPos, range)
        if not target or not target.RootPart then return false end
        if not isEnemy(target) then return false end
        local targetPos = target.RootPart.Position

        local usedAny = false

        if LightningStorm.Enabled then
            if bedwars.AbilityController:canUseAbility("LIGHTNING_STORM") then
                trackDamage(target, 4)
                useAbility("LIGHTNING_STORM", targetPos)
                usedAny = true
            end
        end

        if LightningStrike.Enabled then
            if bedwars.AbilityController:canUseAbility("LIGHTNING_STRIKE") then
                trackDamage(target, 1)
                useAbility("LIGHTNING_STRIKE", targetPos)
                usedAny = true
            end
        end

        return usedAny
    end
    
    local function startAbilityLoop()
        abilityRunning = true
        task.spawn(function()
            while abilityRunning and Zeno.Enabled do
                if not entitylib.isAlive then
                    task.wait(0.1)
                    continue
                end
                
                local usedShockwave = performShockwave()
                
                if not usedShockwave then
                    performLightningAbility()
                end
                
                task.wait(0.01)
            end
            abilityRunning = false
        end)
    end
    
    Zeno = vape.Categories.Kits:CreateModule({
        Name = 'AutoZeno',
        Function = function(callback)
            if callback then
                lastAbilityUse = 0
                lastShockwaveUse = 0
                damageTracker = {}
                startAbilityLoop()
            else
                abilityRunning = false
                lastAbilityUse = 0
                lastShockwaveUse = 0
                damageTracker = {}
            end
        end,
        Tooltip = 'Automatically uses Zeno wizard abilities on ENEMIES only'
    })
    
    Targets = Zeno:CreateTargets({
        Players = true,
        NPCs = false,
        Walls = true
    })
    
    local methods = {'Distance', 'Health', 'Armor', 'Damaged'}
    
    TargetPriority = Zeno:CreateDropdown({
        Name = 'Target Priority',
        List = methods,
        Default = 'Distance',
        Tooltip = 'How to prioritize targets',
        Function = function(val)
            if HealthMode and HealthMode.Object then
                HealthMode.Object.Visible = (val == 'Health')
            end
            if ArmorMode and ArmorMode.Object then
                ArmorMode.Object.Visible = (val == 'Armor')
            end
        end
    })
    
    HealthMode = Zeno:CreateDropdown({
        Name = 'Health Mode',
        List = {'Lowest', 'Highest'},
        Default = 'Lowest',
        Visible = false,
        Tooltip = 'Target lowest or highest health players'
    })
    
    ArmorMode = Zeno:CreateDropdown({
        Name = 'Armor Mode',
        List = {'Weakest', 'Strongest'},
        Default = 'Weakest',
        Visible = false,
        Tooltip = 'Target weakest or strongest armored players'
    })
    
    LightningStrike = Zeno:CreateToggle({
        Name = 'Lightning Strike',
        Default = true,
        Tooltip = 'Use Lightning Strike ability'
    })
    
    LightningStorm = Zeno:CreateToggle({
        Name = 'Lightning Storm',
        Default = true,
        Tooltip = 'Use Lightning Storm ability (higher priority)'
    })
    
    AutoShockwave = Zeno:CreateToggle({
        Name = 'Auto Shockwave',
        Default = false,
        Tooltip = 'Automatically use shockwave when enemies are nearby',
        Function = function(callback)
            if ShockwaveRange and ShockwaveRange.Object then
                ShockwaveRange.Object.Visible = callback
            end
        end
    })
    
    ShockwaveRange = Zeno:CreateSlider({
        Name = 'Shockwave Range',
        Min = 1,
        Max = 12,
        Default = 8,
        Suffix = ' studs',
        Visible = false,
        Tooltip = 'Range to activate shockwave'
    })
    
    AbilityRange = Zeno:CreateSlider({
        Name = 'Ability Range',
        Min = 1,
        Max = 50,
        Default = 30,
        Suffix = ' studs',
        Tooltip = 'Max range for lightning ability'
    })
end)

run(function()
    local GeneratorESP
    DiamondToggle = nil
    EmeraldToggle = nil
    TeamGenToggle = nil
    ShowOwnTeamGen = nil
    ShowEnemyTeamGen = nil
    local UIStyle
    local CollectionService = game:GetService("CollectionService")
    local RunService = game:GetService("RunService")
    local Reference = {}
    local Folder = Instance.new('Folder')
    Folder.Parent = vape.gui
    local CompactFolder = Instance.new('Folder')
    CompactFolder.Parent = vape.gui
    local teamColors = {
        [1] = {name = "Blue",   color = Color3.fromRGB(85, 150, 255)},
        [2] = {name = "Orange", color = Color3.fromRGB(255, 150, 50)},
        [3] = {name = "Pink",   color = Color3.fromRGB(255, 100, 200)},
        [4] = {name = "Yellow", color = Color3.fromRGB(255, 255, 50)}
    }

    local generatorTypes = {
        diamond = {
            keywords = {'diamond'},
            color = Color3.fromRGB(85, 200, 255),
            icon = 'diamond',
            displayName = 'Diamond',
            isTeamGen = false
        },
        emerald = {
            keywords = {'emerald'},
            color = Color3.fromRGB(0, 255, 100),
            icon = 'emerald',
            displayName = 'Emerald',
            isTeamGen = false
        }
    }

    local compactUI = Instance.new('ScreenGui')
    compactUI.Name = 'GeneratorCompactUI'
    compactUI.Parent = vape.gui
    compactUI.Enabled = false
    compactUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    compactUI.DisplayOrder = 10
    compactUI.ResetOnSpawn = false

    local mainFrame = Instance.new('Frame')
    mainFrame.Name = 'MainFrame'
    mainFrame.Parent = compactUI
    mainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    mainFrame.BackgroundTransparency = 0.3
    mainFrame.BorderSizePixel = 0
    mainFrame.Position = UDim2.new(1, -130, 0.5, -50)
    mainFrame.Size = UDim2.new(0, 120, 0, 100)
    mainFrame.AnchorPoint = Vector2.new(0, 0.5)

    local uicorner = Instance.new('UICorner')
    uicorner.CornerRadius = UDim.new(0, 8)
    uicorner.Parent = mainFrame

    local title = Instance.new('TextLabel')
    title.Name = 'Title'
    title.Parent = mainFrame
    title.BackgroundTransparency = 1
    title.Size = UDim2.new(1, 0, 0, 25)
    title.Position = UDim2.new(0, 0, 0, 5)
    title.Text = "GEN ESP"
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.TextSize = 14
    title.Font = Enum.Font.GothamBold
    title.TextStrokeTransparency = 0.5
    title.TextStrokeColor3 = Color3.new(0, 0, 0)

    local diamondFrame = Instance.new('Frame')
    diamondFrame.Name = 'DiamondFrame'
    diamondFrame.Parent = mainFrame
    diamondFrame.BackgroundTransparency = 1
    diamondFrame.Size = UDim2.new(1, -20, 0, 25)
    diamondFrame.Position = UDim2.new(0, 10, 0, 35)

    local diamondIcon = Instance.new('ImageLabel')
    diamondIcon.Name = 'DiamondIcon'
    diamondIcon.Parent = diamondFrame
    diamondIcon.BackgroundTransparency = 1
    diamondIcon.Size = UDim2.new(0, 18, 0, 18)
    diamondIcon.Position = UDim2.new(0, 0, 0.5, -9)
    diamondIcon.Image = bedwars.getIcon({itemType = 'diamond'}, true)

    local diamondTimer = Instance.new('TextLabel')
    diamondTimer.Name = 'DiamondTimer'
    diamondTimer.Parent = diamondFrame
    diamondTimer.BackgroundTransparency = 1
    diamondTimer.Size = UDim2.new(1, -25, 1, 0)
    diamondTimer.Position = UDim2.new(0, 25, 0, 0)
    diamondTimer.Text = "00"
    diamondTimer.TextColor3 = Color3.fromRGB(85, 200, 255)
    diamondTimer.TextSize = 18
    diamondTimer.Font = Enum.Font.GothamBold
    diamondTimer.TextXAlignment = Enum.TextXAlignment.Left

    local emeraldFrame = Instance.new('Frame')
    emeraldFrame.Name = 'EmeraldFrame'
    emeraldFrame.Parent = mainFrame
    emeraldFrame.BackgroundTransparency = 1
    emeraldFrame.Size = UDim2.new(1, -20, 0, 25)
    emeraldFrame.Position = UDim2.new(0, 10, 0, 65)

    local emeraldIcon = Instance.new('ImageLabel')
    emeraldIcon.Name = 'EmeraldIcon'
    emeraldIcon.Parent = emeraldFrame
    emeraldIcon.BackgroundTransparency = 1
    emeraldIcon.Size = UDim2.new(0, 18, 0, 18)
    emeraldIcon.Position = UDim2.new(0, 0, 0.5, -9)
    emeraldIcon.Image = bedwars.getIcon({itemType = 'emerald'}, true)

    local emeraldTimer = Instance.new('TextLabel')
    emeraldTimer.Name = 'EmeraldTimer'
    emeraldTimer.Parent = emeraldFrame
    emeraldTimer.BackgroundTransparency = 1
    emeraldTimer.Size = UDim2.new(1, -25, 1, 0)
    emeraldTimer.Position = UDim2.new(0, 25, 0, 0)
    emeraldTimer.Text = "00"
    emeraldTimer.TextColor3 = Color3.fromRGB(0, 255, 100)
    emeraldTimer.TextSize = 18
    emeraldTimer.Font = Enum.Font.GothamBold
    emeraldTimer.TextXAlignment = Enum.TextXAlignment.Left

    local diamondTimes = {}
    local emeraldTimes = {}

    local function getMyTeamId()
        local myTeam = lplr:GetAttribute('Team')
        if myTeam == nil then return nil end
        return tonumber(myTeam)
    end

    local function getGeneratorTeamId(generatorId)
        local teamNum = string.match(generatorId, "^(%d+)_generator")
        if teamNum then
            return tonumber(teamNum)
        end
        return nil
    end

    local function isTeamGenerator(generatorId)
        return string.match(generatorId, "^%d+_generator") ~= nil
    end

    local function getGeneratorType(generatorId)
        local idLower = string.lower(generatorId)

        if isTeamGenerator(generatorId) then
            return 'teamgen', {
                color = Color3.fromRGB(200, 200, 200),
                icon = 'iron',
                displayName = 'Team Gen',
                isTeamGen = true
            }
        end

        for genType, config in pairs(generatorTypes) do
            for _, keyword in ipairs(config.keywords) do
                if idLower:find(keyword) then
                    return genType, config
                end
            end
        end
        return nil, nil
    end

    local function isGeneratorEnabled(genType, teamId)
        if genType == 'diamond' then
            return DiamondToggle.Enabled
        elseif genType == 'emerald' then
            return EmeraldToggle.Enabled
        elseif genType == 'teamgen' then
            if not TeamGenToggle.Enabled then return false end
            local myTeamId = getMyTeamId()
            if not myTeamId or not teamId then return TeamGenToggle.Enabled end
            if teamId == myTeamId then
                return ShowOwnTeamGen.Enabled
            else
                return ShowEnemyTeamGen.Enabled
            end
        end
        return false
    end

    local function getProperIcon(iconType)
        local icon = bedwars.getIcon({itemType = iconType}, true)
        if not icon or icon == "" then return nil end
        return icon
    end

    local function getTierText(generatorAdornee)
        if not generatorAdornee then return nil end
        if generatorAdornee.Name ~= 'GeneratorAdornee' then return nil end
        local reactTree = generatorAdornee:FindFirstChild('RoactTree')
        if not reactTree then return nil end
        local teamApp = reactTree:FindFirstChild('TeamOreGeneratorApp')
        if not teamApp then return nil end
        local globalGen = teamApp:FindFirstChild('GlobalOreGenerator')
        if globalGen then
            for _, child in pairs(globalGen:GetDescendants()) do
                if child:IsA('TextLabel') then
                    local text = child.Text
                    if text:find("Tier") or text:match("^[IVX]+$") or text == "0" then
                        return child
                    end
                end
            end
        end
        local teamGenMain = teamApp:FindFirstChild('TeamGenMain')
        if teamGenMain then
            for _, child in pairs(teamGenMain:GetDescendants()) do
                if child:IsA('TextLabel') then
                    local text = child.Text
                    if text:find("Tier") or text:match("^[IVX]+$") or text == "0" then
                        return child
                    end
                end
            end
        end
        return nil
    end

    local function extractTierLevel(tierText)
        if not tierText or tierText == "" then return "0" end
        if tierText == "0" then return "0" end
        local tierMatch = tierText:match("Tier%s+([IVX]+)")
        if tierMatch then return tierMatch end
        if tierText:match("^[IVX]+$") then return tierText end
        local numTier = tierText:match("Tier%s+(%d+)")
        if numTier then
            local num = tonumber(numTier)
            if num == 0 then return "0"
            elseif num == 1 then return "I"
            elseif num == 2 then return "II"
            elseif num == 3 then return "III"
            end
        end
        return "0"
    end

    local function getCountdownText(generatorAdornee)
        if not generatorAdornee then return nil end
        if generatorAdornee.Name ~= 'GeneratorAdornee' then return nil end
        local reactTree = generatorAdornee:FindFirstChild('RoactTree')
        if not reactTree then return nil end
        local teamApp = reactTree:FindFirstChild('TeamOreGeneratorApp')
        if not teamApp then return nil end
        local globalGen = teamApp:FindFirstChild('GlobalOreGenerator')
        if not globalGen then return nil end
        local countdown = globalGen:FindFirstChild('Countdown')
        if not countdown then return nil end
        local textLabel = countdown:FindFirstChild('Text')
        if not textLabel then
            if countdown:IsA('TextLabel') then return countdown end
            return nil
        end
        return textLabel
    end

    local function extractSecondsFromText(text)
        if not text or text == "" then return 0 end
        local seconds = text:match("%[(%d+)%]")
        if seconds then return tonumber(seconds) or 0 end
        local justNumber = text:match("(%d+)")
        if justNumber then return tonumber(justNumber) or 0 end
        return 0
    end

    local function getResourceCount(position, resourceType)
        local count = 0
        for _, drop in pairs(CollectionService:GetTagged('ItemDrop')) do
            if drop:FindFirstChild('Handle') then
                local dropName = drop.Name:lower()
                if dropName:find(resourceType) then
                    local dist = (drop.Handle.Position - position).Magnitude
                    if dist <= 10 then
                        local amount = drop:GetAttribute('Amount') or 1
                        count = count + amount
                    end
                end
            end
        end
        return count
    end

    local function updateCompactUI()
        if not GeneratorESP.Enabled or UIStyle.Value ~= 'Compact' then
            compactUI.Enabled = false
            return
        end
        compactUI.Enabled = true
        local bestDiamondTime = math.huge
        local bestEmeraldTime = math.huge
        for generatorAdornee, ref in pairs(Reference) do
            if ref and not ref.isTeamGen and generatorAdornee and generatorAdornee.Parent then
                local countdownText = getCountdownText(generatorAdornee)
                if countdownText and countdownText.Text then
                    local timeLeft = extractSecondsFromText(countdownText.Text)
                    if ref.genType == 'diamond' and timeLeft > 0 and timeLeft < bestDiamondTime then
                        bestDiamondTime = timeLeft
                    elseif ref.genType == 'emerald' and timeLeft > 0 and timeLeft < bestEmeraldTime then
                        bestEmeraldTime = timeLeft
                    end
                end
            end
        end
        diamondTimes[1] = bestDiamondTime ~= math.huge and bestDiamondTime or 0
        emeraldTimes[1] = bestEmeraldTime ~= math.huge and bestEmeraldTime or 0
        if bestDiamondTime == math.huge then
            diamondTimer.Text = "00"
        else
            diamondTimer.Text = string.format("%02d", bestDiamondTime)
            if bestDiamondTime <= 5 then
                diamondTimer.TextColor3 = Color3.fromRGB(255, 50, 50)
            elseif bestDiamondTime <= 10 then
                diamondTimer.TextColor3 = Color3.fromRGB(255, 165, 0)
            else
                diamondTimer.TextColor3 = Color3.fromRGB(85, 200, 255)
            end
        end
        if bestEmeraldTime == math.huge then
            emeraldTimer.Text = "00"
        else
            emeraldTimer.Text = string.format("%02d", bestEmeraldTime)
            if bestEmeraldTime <= 5 then
                emeraldTimer.TextColor3 = Color3.fromRGB(255, 50, 50)
            elseif bestEmeraldTime <= 10 then
                emeraldTimer.TextColor3 = Color3.fromRGB(255, 165, 0)
            else
                emeraldTimer.TextColor3 = Color3.fromRGB(0, 255, 100)
            end
        end
    end

    local function clearAllESP()
        Folder:ClearAllChildren()
        table.clear(Reference)
        compactUI.Enabled = false
    end

    local function createESP(generatorAdornee, genType, config, position, teamId)
        if not isGeneratorEnabled(genType, teamId) then return end
        if Reference[generatorAdornee] then return end

        if UIStyle.Value == 'Compact' then
            Reference[generatorAdornee] = {
                genType = genType,
                position = position,
                teamId = teamId,
                isTeamGen = config.isTeamGen
            }
            return
        end

        local displayColor = config.color
        local teamName = nil
        if config.isTeamGen and teamId and teamColors[teamId] then
            displayColor = teamColors[teamId].color
            teamName = teamColors[teamId].name
        end

        local billboard = Instance.new('BillboardGui')
        billboard.Parent = Folder
        billboard.Name = 'generator-esp-' .. genType
        billboard.AlwaysOnTop = true
        billboard.ClipsDescendants = false
        billboard.Adornee = generatorAdornee

        if config.isTeamGen then
            billboard.Size = UDim2.fromOffset(180, 55)
            billboard.StudsOffsetWorldSpace = Vector3.new(0, 5, 0)
        else
            billboard.Size = UDim2.fromOffset(80, 30)
            billboard.StudsOffsetWorldSpace = Vector3.new(0, 4, 0)
        end

        local blur = addBlur(billboard)
        blur.Visible = true

        if config.isTeamGen and teamName then
            local dot = Instance.new('Frame')
            dot.Name = 'TeamDot'
            dot.Parent = billboard
            dot.Size = UDim2.fromOffset(8, 8)
            dot.Position = UDim2.new(0, 10, 0, 5)
            dot.BackgroundColor3 = displayColor
            dot.BorderSizePixel = 0
            local dotCorner = Instance.new('UICorner')
            dotCorner.CornerRadius = UDim.new(1, 0)
            dotCorner.Parent = dot

            local teamLabel = Instance.new('TextLabel')
            teamLabel.Name = 'TeamLabel'
            teamLabel.Parent = billboard
            teamLabel.BackgroundTransparency = 1
            teamLabel.Size = UDim2.new(1, 0, 0, 18)
            teamLabel.Position = UDim2.new(0, 0, 0, 0)
            teamLabel.Text = teamName
            teamLabel.TextColor3 = displayColor
            teamLabel.TextSize = 13
            teamLabel.Font = Enum.Font.GothamBold
            teamLabel.TextStrokeTransparency = 0.4
            teamLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
            teamLabel.TextXAlignment = Enum.TextXAlignment.Center
        end

        local frame = Instance.new('Frame')
        frame.Size = config.isTeamGen and UDim2.new(1, 0, 0, 35) or UDim2.fromScale(1, 1)
        frame.Position = config.isTeamGen and UDim2.new(0, 0, 0, 20) or UDim2.new(0, 0, 0, 0)
        frame.BackgroundColor3 = Color3.new(0, 0, 0)
        frame.BackgroundTransparency = 0.3
        frame.BorderSizePixel = 0
        frame.Parent = billboard

        if config.isTeamGen and teamId and teamColors[teamId] then
            local stripe = Instance.new('Frame')
            stripe.Name = 'TeamStripe'
            stripe.Parent = frame
            stripe.Size = UDim2.new(0, 3, 1, 0)
            stripe.Position = UDim2.new(0, 0, 0, 0)
            stripe.BackgroundColor3 = displayColor
            stripe.BorderSizePixel = 0
            local stripeCorner = Instance.new('UICorner')
            stripeCorner.CornerRadius = UDim.new(0, 3)
            stripeCorner.Parent = stripe
        end

        local uicorner2 = Instance.new('UICorner')
        uicorner2.CornerRadius = UDim.new(0, 6)
        uicorner2.Parent = frame

        if config.isTeamGen then
            local tierLabel = Instance.new('TextLabel')
            tierLabel.Name = 'Tier'
            tierLabel.Size = UDim2.new(0, 25, 1, 0)
            tierLabel.Position = UDim2.new(0, 8, 0, 0)
            tierLabel.BackgroundTransparency = 1
            tierLabel.Text = "0"
            tierLabel.TextColor3 = Color3.fromRGB(255, 255, 100)
            tierLabel.TextSize = 16
            tierLabel.Font = Enum.Font.GothamBold
            tierLabel.TextStrokeTransparency = 0.5
            tierLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
            tierLabel.Parent = frame

            local resources = {
                {name = 'iron',    color = Color3.fromRGB(200, 200, 200), icon = 'iron',    xOffset = 35},
                {name = 'diamond', color = Color3.fromRGB(85, 200, 255),  icon = 'diamond', xOffset = 85},
                {name = 'emerald', color = Color3.fromRGB(0, 255, 100),   icon = 'emerald', xOffset = 135}
            }

            local resourceLabels = {}
            for _, resource in ipairs(resources) do
                local iconImage = getProperIcon(resource.icon)
                if iconImage then
                    local image = Instance.new('ImageLabel')
                    image.Size = UDim2.fromOffset(18, 18)
                    image.Position = UDim2.new(0, resource.xOffset, 0.5, 0)
                    image.AnchorPoint = Vector2.new(0, 0.5)
                    image.BackgroundTransparency = 1
                    image.Image = iconImage
                    image.Parent = frame
                end
                local countLabel = Instance.new('TextLabel')
                countLabel.Name = resource.name .. '_count'
                countLabel.Size = UDim2.new(0, 25, 1, 0)
                countLabel.Position = UDim2.new(0, resource.xOffset + 20, 0, 0)
                countLabel.BackgroundTransparency = 1
                countLabel.Text = "0"
                countLabel.TextColor3 = resource.color
                countLabel.TextSize = 16
                countLabel.Font = Enum.Font.GothamBold
                countLabel.TextStrokeTransparency = 0.5
                countLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
                countLabel.TextXAlignment = Enum.TextXAlignment.Left
                countLabel.Parent = frame
                resourceLabels[resource.name] = countLabel
            end

            Reference[generatorAdornee] = {
                billboard = billboard,
                tierLabel = tierLabel,
                ironLabel = resourceLabels.iron,
                diamondLabel = resourceLabels.diamond,
                emeraldLabel = resourceLabels.emerald,
                genType = genType,
                position = position,
                teamId = teamId,
                isTeamGen = true
            }
        else
            local iconImage = getProperIcon(config.icon)
            if iconImage then
                local image = Instance.new('ImageLabel')
                image.Size = UDim2.fromOffset(20, 20)
                image.Position = UDim2.new(0, 5, 0.5, 0)
                image.AnchorPoint = Vector2.new(0, 0.5)
                image.BackgroundTransparency = 1
                image.Image = iconImage
                image.Parent = frame
            end
            local timerLabel = Instance.new('TextLabel')
            timerLabel.Name = 'Timer'
            timerLabel.Size = UDim2.new(0, 30, 1, 0)
            timerLabel.Position = UDim2.new(0.5, 0, 0, 0)
            timerLabel.AnchorPoint = Vector2.new(0.5, 0)
            timerLabel.BackgroundTransparency = 1
            timerLabel.Text = "00"
            timerLabel.TextColor3 = displayColor
            timerLabel.TextSize = 18
            timerLabel.Font = Enum.Font.GothamBold
            timerLabel.TextStrokeTransparency = 0.5
            timerLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
            timerLabel.Parent = frame
            local amountLabel = Instance.new('TextLabel')
            amountLabel.Name = 'Amount'
            amountLabel.Size = UDim2.new(0, 20, 1, 0)
            amountLabel.Position = UDim2.new(1, -20, 0, 0)
            amountLabel.BackgroundTransparency = 1
            amountLabel.Text = "0"
            amountLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            amountLabel.TextSize = 16
            amountLabel.Font = Enum.Font.GothamBold
            amountLabel.TextStrokeTransparency = 0.5
            amountLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
            amountLabel.Parent = frame
            Reference[generatorAdornee] = {
                billboard = billboard,
                timerLabel = timerLabel,
                amountLabel = amountLabel,
                genType = genType,
                position = position,
                teamId = teamId,
                isTeamGen = false
            }
        end
    end

    local function updateESP(generatorAdornee)
        local ref = Reference[generatorAdornee]
        if not ref then return end
        if UIStyle.Value == 'Compact' then return end

        if ref.isTeamGen then
            if ref.tierLabel then
                local tierTextLabel = getTierText(generatorAdornee)
                if tierTextLabel and tierTextLabel.Text then
                    ref.tierLabel.Text = extractTierLevel(tierTextLabel.Text)
                else
                    ref.tierLabel.Text = "0"
                end
            end
            if ref.ironLabel then
                ref.ironLabel.Text = tostring(getResourceCount(ref.position, 'iron'))
            end
            if ref.diamondLabel then
                ref.diamondLabel.Text = tostring(getResourceCount(ref.position, 'diamond'))
            end
            if ref.emeraldLabel then
                ref.emeraldLabel.Text = tostring(getResourceCount(ref.position, 'emerald'))
            end
        else
            local countdownText = getCountdownText(generatorAdornee)
            if countdownText and countdownText.Text then
                local timeLeft = extractSecondsFromText(countdownText.Text)
                if ref.timerLabel then
                    ref.timerLabel.Text = string.format("%02d", timeLeft)
                    if timeLeft <= 5 then
                        ref.timerLabel.TextColor3 = Color3.fromRGB(255, 50, 50)
                    elseif timeLeft <= 10 then
                        ref.timerLabel.TextColor3 = Color3.fromRGB(255, 165, 0)
                    else
                        ref.timerLabel.TextColor3 = generatorTypes[ref.genType].color
                    end
                end
            else
                if ref.timerLabel then
                    ref.timerLabel.Text = "00"
                    ref.timerLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
                end
            end
            if ref.amountLabel then
                ref.amountLabel.Text = tostring(getResourceCount(ref.position, ref.genType))
            end
        end
    end

    local function processGeneratorAdornee(obj)
        if obj.Name ~= 'GeneratorAdornee' then return end
        local ok, generatorId = pcall(function() return obj:GetAttribute('Id') end)
        if not ok then return end
        if generatorId == nil then return end
        if type(generatorId) ~= 'string' then return end
        if generatorId == '' then return end

        local position = obj:GetPivot().Position
        local genType, config = getGeneratorType(generatorId)
        if not genType or not config then return end

        local teamId = getGeneratorTeamId(generatorId)
        if isGeneratorEnabled(genType, teamId) then
            createESP(obj, genType, config, position, teamId)
        end
    end

    local function findAllGenerators()
        for _, obj in pairs(workspace:GetDescendants()) do
            pcall(processGeneratorAdornee, obj)
        end
    end

    local function refreshESP()
        clearAllESP()
        if GeneratorESP.Enabled then
            findAllGenerators()
        end
    end

    local updateTimer = 0

    GeneratorESP = vape.Categories.Render:CreateModule({
        Name = 'GeneratorESP',
        Function = function(callback)
            if callback then
                findAllGenerators()

                GeneratorESP:Clean(workspace.DescendantAdded:Connect(function(obj)
                    if not GeneratorESP.Enabled then return end
                    task.wait(0.2)
                    pcall(processGeneratorAdornee, obj)
                end))

                GeneratorESP:Clean(RunService.Heartbeat:Connect(function(dt)
                    if not GeneratorESP.Enabled then return end
                    updateTimer = updateTimer + dt
                    if updateTimer < 0.2 then return end
                    updateTimer = 0
                    for generatorAdornee, ref in pairs(Reference) do
                        if generatorAdornee and generatorAdornee.Parent then
                            updateESP(generatorAdornee)
                        else
                            if ref.billboard then ref.billboard:Destroy() end
                            Reference[generatorAdornee] = nil
                        end
                    end
                    updateCompactUI()
                end))

                GeneratorESP:Clean(workspace.DescendantRemoving:Connect(function(obj)
                    if not GeneratorESP.Enabled then return end
                    if Reference[obj] then
                        if Reference[obj].billboard then Reference[obj].billboard:Destroy() end
                        Reference[obj] = nil
                    end
                end))
            else
                clearAllESP()
            end
        end,
        Tooltip = 'ESP for generators showing timer and item counts'
    })

    UIStyle = GeneratorESP:CreateDropdown({
        Name = 'UI Style',
        List = {'Original', 'Compact'},
        Default = 'Original',
        Function = function() refreshESP() end,
        Tooltip = 'Choose between original billboard ESP or compact side UI'
    })

    DiamondToggle = GeneratorESP:CreateToggle({
        Name = 'Diamond',
        Function = function() refreshESP() end,
        Default = true
    })

    EmeraldToggle = GeneratorESP:CreateToggle({
        Name = 'Emerald',
        Function = function() refreshESP() end,
        Default = true
    })

    TeamGenToggle = GeneratorESP:CreateToggle({
        Name = 'Team Generators',
        Function = function(callback)
            if ShowOwnTeamGen then ShowOwnTeamGen.Object.Visible = callback end
            if ShowEnemyTeamGen then ShowEnemyTeamGen.Object.Visible = callback end
            refreshESP()
        end,
        Default = true
    })

    ShowOwnTeamGen = GeneratorESP:CreateToggle({
        Name = 'Show Own Team',
        Function = function() refreshESP() end,
        Default = false,
        Visible = true
    })

    ShowEnemyTeamGen = GeneratorESP:CreateToggle({
        Name = 'Show Enemy Teams',
        Function = function() refreshESP() end,
        Default = true,
        Visible = true
    })
end)
run(function()
    local Gingerbread
    local LimitToItems
    local GingerESP
    local ESPBackground
    local ESPColor = {}
    local BreakDelay
    local BreakDelaySlider
    local AutoSwitch
    local SwitchMode
    
    local Folder = Instance.new('Folder')
    Folder.Parent = vape.gui
    local espCache = {}
    local lastBreakTime = 0
    local lastPlaceTime = 0
    local placeCheckConnection
    local justPlacedGumdrop = false
    local lastPlacedPosition = nil
    
    _G.gingerLock = _G.gingerLock or false
    
    local function getPickaxeSlot()
        for i, v in store.inventory.hotbar do
            if v.item and bedwars.ItemMeta[v.item.itemType] then
                local meta = bedwars.ItemMeta[v.item.itemType]
                if meta.breakBlock then
                    return i - 1
                end
            end
        end
        return nil
    end
    
    local function getGumdropSlot()
        for i, v in store.inventory.hotbar do
            if v.item and v.item.itemType == "gumdrop_bounce_pad" then
                return i - 1
            end
        end
        return nil
    end
    
    local function isFirstPerson()
        if not (lplr.Character and lplr.Character:FindFirstChild("Head")) then return false end
        return (lplr.Character.Head.Position - gameCamera.CFrame.Position).Magnitude < 2
    end
    
    local function getPredictedPosition()
        if not (lplr.Character and lplr.Character.PrimaryPart) then
            return nil
        end
        local root = lplr.Character.PrimaryPart
        local velocity = root.AssemblyLinearVelocity
        local horizontalVelocity = Vector3.new(velocity.X, 0, velocity.Z)
        local speed = horizontalVelocity.Magnitude
        if speed < 1 then
            return root.Position
        end
        local predictionTime = math.clamp(speed / 40, 0.15, 0.35)
        local prediction = root.Position + (horizontalVelocity * predictionTime)
        
        return prediction
    end
    
    local function tryPlaceGumdrop()
        if not AutoSwitch.Enabled or _G.gingerLock then
            return
        end
        
        if not (lplr.Character and lplr.Character.PrimaryPart) then
            return
        end
        
        local inFirstPerson = isFirstPerson()
        if SwitchMode.Value == 'First Person' and not inFirstPerson then
            return
        elseif SwitchMode.Value == 'Third Person' and inFirstPerson then
            return
        end
        
        local velocity = lplr.Character.PrimaryPart.AssemblyLinearVelocity.Y
        if velocity >= -5 then
            return
        end
        
        local gumdropSlot = getGumdropSlot()
        if not gumdropSlot then
            return
        end
        
        local root = lplr.Character.PrimaryPart
        
        local targetPos = getPredictedPosition()
        if not targetPos then
            targetPos = root.Position
        end
        
        local checkPos = targetPos - Vector3.new(0, 3, 0)
        local groundBlockPos = nil
        
        for i = 1, 16 do
            local testPos = checkPos - Vector3.new(0, 3 * (i - 1), 0)
            local block, blockpos = getPlacedBlock(roundPos(testPos))
            if block then
                groundBlockPos = blockpos * 3
                break
            end
        end
        
        if not groundBlockPos then
            return
        end
        
        local distanceToGround = root.Position.Y - groundBlockPos.Y
        if distanceToGround < 9 or distanceToGround > 18 then
            return
        end
        local placePos = groundBlockPos + Vector3.new(0, 3, 0)
        if lastPlacedPosition and (lastPlacedPosition - placePos).Magnitude < 1 then
            return
        end
        if getPlacedBlock(placePos) then
            return
        end
        
        _G.gingerLock = true
        local originalSlot = store.inventory.hotbarSlot
        
        if hotbarSwitch(gumdropSlot) then
            task.wait(0.03)
            
            local success = pcall(function()
                bedwars.placeBlock(placePos, "gumdrop_bounce_pad", false)
            end)
            
            if success then
                lastPlaceTime = tick()
                justPlacedGumdrop = true
                lastPlacedPosition = placePos
                
                task.wait(0.03)
                local pickaxeSlot = getPickaxeSlot()
                if pickaxeSlot then
                    hotbarSwitch(pickaxeSlot)
                    
                    task.wait(0.08)
                    
                    local placedBlock = getPlacedBlock(placePos)
                    if placedBlock and placedBlock.Name == "gumdrop_bounce_pad" then
                        task.spawn(bedwars.breakBlock, placedBlock, false, nil, true)
                        lastBreakTime = tick()
                    end
                end
            end
        end
        
        _G.gingerLock = false
    end
    
    local function createESP(block)
        if not block or espCache[block] then return end
        
        local billboard = Instance.new('BillboardGui')
        billboard.Parent = Folder
        billboard.Name = 'GingerbreadESP'
        billboard.StudsOffsetWorldSpace = Vector3.new(0, 3, 0)
        billboard.Size = UDim2.fromOffset(40, 40)
        billboard.AlwaysOnTop = true
        billboard.Adornee = block
        
        local blur = addBlur(billboard)
        blur.Visible = ESPBackground.Enabled
        
        local image = Instance.new('ImageLabel')
        image.Size = UDim2.fromOffset(40, 40)
        image.Position = UDim2.fromScale(0.5, 0.5)
        image.AnchorPoint = Vector2.new(0.5, 0.5)
        image.BackgroundColor3 = Color3.fromHSV(ESPColor.Hue, ESPColor.Sat, ESPColor.Value)
        image.BackgroundTransparency = 1 - (ESPBackground.Enabled and ESPColor.Opacity or 0)
        image.BorderSizePixel = 0
        image.Image = bedwars.getIcon({itemType = 'gumdrop_bounce_pad'}, true) or ""
        image.Parent = billboard
        
        local uicorner = Instance.new('UICorner')
        uicorner.CornerRadius = UDim.new(0, 4)
        uicorner.Parent = image
        
        espCache[block] = billboard
    end
    
    local function removeESP(block)
        if espCache[block] then
            espCache[block]:Destroy()
            espCache[block] = nil
        end
    end
    
    local function findMyGumdrops()
        for _, block in workspace:GetDescendants() do
            if block:IsA("Part") and block.Name == 'gumdrop_bounce_pad' then
                if block:GetAttribute('PlacedByUserId') == lplr.UserId then
                    createESP(block)
                end
            end
        end
    end
    
    Gingerbread = vape.Categories.Kits:CreateModule({
        Name = 'AutoGinger',
        Function = function(callback)
            if callback then
                local old = bedwars.LaunchPadController.attemptLaunch
                bedwars.LaunchPadController.attemptLaunch = function(...)
                    local res = {old(...)}
                    local self, block = ...
                    
                    if true then
                        if block:GetAttribute('PlacedByUserId') == lplr.UserId and 
                           (block.Position - entitylib.character.RootPart.Position).Magnitude < 30 then
                            
                            local handItem = store.inventory.inventory.hand
                            local isHoldingPick = false
                            if handItem then
                                local itemMeta = bedwars.ItemMeta[handItem.itemType]
                                if itemMeta and itemMeta.breakBlock then
                                    isHoldingPick = true
                                end
                            end

                            local cameraAllowed = true
                            if AutoSwitch.Enabled then
                                local inFirstPerson = isFirstPerson()
                                if SwitchMode.Value == 'First Person' and not inFirstPerson then
                                    cameraAllowed = false
                                elseif SwitchMode.Value == 'Third Person' and inFirstPerson then
                                    cameraAllowed = false
                                end
                            end

                            if isHoldingPick then
                                local currentTime = tick()
                                local shouldBreak = true
                                
                                if not AutoSwitch.Enabled and BreakDelay.Enabled and not justPlacedGumdrop then
                                    if (currentTime - lastBreakTime) < BreakDelaySlider.Value then
                                        shouldBreak = false
                                    end
                                end
                                
                                if shouldBreak then
                                    task.spawn(bedwars.breakBlock, block, false, nil, true)
                                    lastBreakTime = currentTime
                                    justPlacedGumdrop = false
                                end
                            elseif AutoSwitch.Enabled and cameraAllowed and not _G.gingerLock then
                                local pickaxeSlot = getPickaxeSlot()
                                if pickaxeSlot then
                                    _G.gingerLock = true
                                    task.spawn(function()
                                        local originalSlot = store.inventory.hotbarSlot
                                        if hotbarSwitch(pickaxeSlot) then
                                            task.wait(0.03)
                                            task.spawn(bedwars.breakBlock, block, false, nil, true)
                                            lastBreakTime = tick()
                                            justPlacedGumdrop = false
                                        end
                                        _G.gingerLock = false
                                    end)
                                end
                            elseif LimitToItems.Enabled then
                                return unpack(res)
                            end
                        end
                    end
                    
                    return unpack(res)
                end
                
                if AutoSwitch.Enabled then
                    placeCheckConnection = runService.RenderStepped:Connect(function()
                        if not _G.gingerLock and entitylib.isAlive and tick() - lastPlaceTime > 0.15 then
                            tryPlaceGumdrop()
                        end
                    end)
                    
                    Gingerbread:Clean(function()
                        if placeCheckConnection then
                            placeCheckConnection:Disconnect()
                            placeCheckConnection = nil
                        end
                    end)
                end
                
                Gingerbread:Clean(function()
                    bedwars.LaunchPadController.attemptLaunch = old
                    if placeCheckConnection then
                        placeCheckConnection:Disconnect()
                        placeCheckConnection = nil
                    end
                end)
                
                if GingerESP.Enabled then
                    findMyGumdrops()
                    
                    Gingerbread:Clean(workspace.DescendantAdded:Connect(function(descendant)
                        if descendant:IsA("Part") and descendant.Name == 'gumdrop_bounce_pad' then
                            task.wait(0.1)
                            if descendant:GetAttribute('PlacedByUserId') == lplr.UserId then
                                createESP(descendant)
                            end
                        end
                    end))
                    
                    Gingerbread:Clean(workspace.DescendantRemoving:Connect(function(descendant)
                        if descendant:IsA("Part") and descendant.Name == 'gumdrop_bounce_pad' then
                            removeESP(descendant)
                        end
                    end))
                end
            else
                Folder:ClearAllChildren()
                table.clear(espCache)
                lastBreakTime = 0
                lastPlaceTime = 0
                justPlacedGumdrop = false
                lastPlacedPosition = nil
                _G.gingerLock = false
                if placeCheckConnection then
                    placeCheckConnection:Disconnect()
                    placeCheckConnection = nil
                end
            end
        end,
        Tooltip = 'Advanced gumdrop loop with movement prediction'
    })
    
    LimitToItems = Gingerbread:CreateToggle({
        Name = 'Limit to Items',
        Default = false,
        Tooltip = 'Only break gumdrops when holding a pickaxe'
    })
    
    GingerESP = Gingerbread:CreateToggle({
        Name = 'Ginger ESP',
        Default = false,
        Function = function(callback)
            if ESPBackground and ESPBackground.Object then 
                ESPBackground.Object.Visible = callback 
            end
            if ESPColor and ESPColor.Object then 
                ESPColor.Object.Visible = callback 
            end
            
            if callback and Gingerbread.Enabled then
                findMyGumdrops()
            else
                Folder:ClearAllChildren()
                table.clear(espCache)
            end
        end,
        Tooltip = 'Shows ESP on your placed gumdrops'
    })
    
    ESPBackground = Gingerbread:CreateToggle({
        Name = 'ESP Background',
        Default = true,
        Visible = false,
        Function = function(callback)
            for _, billboard in espCache do
                if billboard.ImageLabel then
                    billboard.ImageLabel.BackgroundTransparency = 1 - (callback and ESPColor.Opacity or 0)
                    if billboard.Blur then
                        billboard.Blur.Visible = callback
                    end
                end
            end
        end
    })
    
    ESPColor = Gingerbread:CreateColorSlider({
        Name = 'ESP Color',
        DefaultValue = 0.44,
        DefaultOpacity = 0.5,
        Visible = false,
        Function = function(hue, sat, val, opacity)
            for _, billboard in espCache do
                if billboard.ImageLabel then
                    billboard.ImageLabel.BackgroundColor3 = Color3.fromHSV(hue, sat, val)
                    billboard.ImageLabel.BackgroundTransparency = 1 - opacity
                end
            end
        end,
        Darker = true
    })
    
    BreakDelay = Gingerbread:CreateToggle({
        Name = 'Break Delay',
        Default = false,
        Function = function(callback)
            if BreakDelaySlider and BreakDelaySlider.Object then
                BreakDelaySlider.Object.Visible = callback and not AutoSwitch.Enabled
            end
        end,
        Tooltip = 'Add delay before breaking gumdrops'
    })
    
    BreakDelaySlider = Gingerbread:CreateSlider({
        Name = 'Delay',
        Min = 0,
        Max = 2,
        Default = 0.5,
        Decimal = 10,
        Suffix = 's',
        Visible = false,
        Tooltip = 'Delay in seconds before breaking'
    })
    
    AutoSwitch = Gingerbread:CreateToggle({
        Name = 'Auto-Switch',
        Default = false,
        Function = function(callback)
            if SwitchMode and SwitchMode.Object then
                SwitchMode.Object.Visible = callback
            end
            if BreakDelay and BreakDelay.Object then
                BreakDelay.Object.Visible = not callback
            end
            if BreakDelaySlider and BreakDelaySlider.Object then
                BreakDelaySlider.Object.Visible = (not callback) and BreakDelay.Enabled
            end
        end,
        Tooltip = 'Auto-switch, break, and place with smart movement prediction'
    })
    
    SwitchMode = Gingerbread:CreateDropdown({
        Name = 'Camera Mode',
        List = {'Both', 'First Person', 'Third Person'},
        Default = 'Both',
        Visible = false,
        Tooltip = 'Which camera mode to work in'
    })
end)

run(function()
    local Beekeeper
    local CollectionToggle
	local LimitToNet
	local maxBeehiveLevel = 10
    local maxedBeehives = {}
    local maxedNotificationSent = {}
    local CollectionDelay
    local DelaySlider
    local RangeSlider
    local ESPToggle
    local BeesESP
    local BeesNotify
    local BeesBackground
    local BeesColor
    local BeehiveESP
    local ShowOtherBeehives
    local BeehiveBackground
    local BeehiveColor
    local AutoDeposit
    local DepositDelay
    local DepositDelaySlider
    local DepositRange
    local ESPLimitToNet  
    local collectionRunning = false
    local depositRunning = false
    local BeesFolder = Instance.new('Folder')
    BeesFolder.Parent = vape.gui
    local BeehiveFolder = Instance.new('Folder')
    BeehiveFolder.Parent = vape.gui
    local BeesReference = {}
    local BeehiveReference = {}
    local lastNotification = 0
    local spawnQueue = {}
    local notificationCooldown = 1

    local function sendNotification(count)
        notif("Bee ESP", string.format("%d bees spawned", count), 3)
    end

    local function processSpawnQueue()
        if #spawnQueue > 0 then
            local currentTime = tick()
            if currentTime - lastNotification >= notificationCooldown then
                sendNotification(#spawnQueue)
                lastNotification = currentTime
                spawnQueue = {}
            else
                task.delay(notificationCooldown - (currentTime - lastNotification), function()
                    if #spawnQueue > 0 then
                        sendNotification(#spawnQueue)
                        spawnQueue = {}
                    end
                end)
            end
        end
    end

    local function getBeeIcon()
        return bedwars.getIcon({itemType = 'bee'}, true)
    end

    local function AddedBee(v)
        if BeesReference[v] then return end
        local model = v.Parent
        if model then
            if model.Name:find("TamedBee") or model:FindFirstChild("TamedBee") then
                return 
            end
            
            if model:GetAttribute("IsTamed") or model:GetAttribute("Tamed") then
                return 
            end
            
            for _, tag in pairs(collectionService:GetTags(model)) do
                if tag:lower():find("tamed") then
                    return 
                end
            end
        end
        
        local billboard = Instance.new('BillboardGui')
        billboard.Parent = BeesFolder
        billboard.Name = 'bee'
        billboard.StudsOffsetWorldSpace = Vector3.new(0, 3, 0)
        billboard.Size = UDim2.fromOffset(36, 36)
        billboard.AlwaysOnTop = true
        billboard.ClipsDescendants = false
        billboard.Adornee = v
        
        local blur = addBlur(billboard)
        blur.Visible = BeesBackground.Enabled
        
        local image = Instance.new('ImageLabel')
        image.Size = UDim2.fromOffset(36, 36)
        image.Position = UDim2.fromScale(0.5, 0.5)
        image.AnchorPoint = Vector2.new(0.5, 0.5)
        image.BackgroundColor3 = Color3.fromHSV(BeesColor.Hue, BeesColor.Sat, BeesColor.Value)
        image.BackgroundTransparency = 1 - (BeesBackground.Enabled and BeesColor.Opacity or 0)
        image.BorderSizePixel = 0
        image.Image = getBeeIcon()
        image.Parent = billboard
        
        local uicorner = Instance.new('UICorner')
        uicorner.CornerRadius = UDim.new(0, 4)
        uicorner.Parent = image
        
        BeesReference[v] = billboard
        
        if BeesNotify.Enabled then
            table.insert(spawnQueue, {item = 'bee', time = tick()})
            processSpawnQueue()
        end
    end

    local function RemovedBee(v)
        if BeesReference[v] then
            BeesReference[v]:Destroy()
            BeesReference[v] = nil
        end
    end

    local function isMyBeehive(beehive)
        if not beehive then return false end
        local placedBy = beehive:GetAttribute("PlacedByUserId")
        return placedBy and placedBy == lplr.UserId
    end
    
    local function getBeehiveOwnerName(beehive)
        if not beehive then return "Unknown" end
        local placedBy = beehive:GetAttribute("PlacedByUserId")
        if not placedBy then return "Unknown" end
        
        local player = game.Players:GetPlayerByUserId(placedBy)
        if player then
            return player.Name
        end
        
        return "Player"
    end

    local function AddedBeehive(beehive)
        local isOwn = isMyBeehive(beehive)
        
        if not isOwn and not (ShowOtherBeehives and ShowOtherBeehives.Enabled) then 
            return 
        end
        
        if BeehiveReference[beehive] then return end
        
        local level = beehive:GetAttribute("Level") or 0
        local isMaxed = level >= maxBeehiveLevel and isOwn
        
        if isMaxed and isOwn then
            maxedBeehives[beehive] = true
        end
        
        local ownerName = isOwn and nil or getBeehiveOwnerName(beehive)
        local hasOwnerName = ownerName ~= nil
        
        local billboard = Instance.new('BillboardGui')
        billboard.Parent = BeehiveFolder
        billboard.Name = 'beehive-esp'
        billboard.StudsOffsetWorldSpace = Vector3.new(0, 4, 0)
        billboard.Size = isMaxed and UDim2.fromOffset(90, 40) or (hasOwnerName and UDim2.fromOffset(120, 40) or UDim2.fromOffset(80, 30))
        billboard.AlwaysOnTop = true
        billboard.ClipsDescendants = false
        billboard.Adornee = beehive
        
        local blur = addBlur(billboard)
        blur.Visible = BeehiveBackground.Enabled
        
        local frame = Instance.new('Frame')
        frame.Size = UDim2.fromScale(1, 1)
        frame.BackgroundColor3 = isMaxed and Color3.fromRGB(255, 50, 50) or Color3.fromHSV(BeehiveColor.Hue, BeehiveColor.Sat, BeehiveColor.Value)
        frame.BackgroundTransparency = 1 - (BeehiveBackground.Enabled and (isMaxed and 0.5 or BeehiveColor.Opacity) or 0)
        frame.BorderSizePixel = 0
        frame.Parent = billboard
        
        local uicorner = Instance.new('UICorner')
        uicorner.CornerRadius = UDim.new(0, 6)
        uicorner.Parent = frame
        
        if hasOwnerName then
            local nameLabel = Instance.new('TextLabel')
            nameLabel.Name = 'OwnerName'
            nameLabel.Size = UDim2.new(1, 0, 0.4, 0)
            nameLabel.Position = UDim2.new(0, 0, 0, -20)
            nameLabel.BackgroundTransparency = 1
            nameLabel.Text = ownerName
            nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            nameLabel.TextSize = 12
            nameLabel.Font = Enum.Font.GothamBold
            nameLabel.TextStrokeTransparency = 0.5
            nameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
            nameLabel.Parent = billboard
        end
        
        local homeImage = Instance.new('TextLabel')
        homeImage.Size = UDim2.fromOffset(20, 20)
        homeImage.Position = UDim2.new(0, 5, 0.5, 0)
        homeImage.AnchorPoint = Vector2.new(0, 0.5)
        homeImage.BackgroundTransparency = 1
        homeImage.Text = isOwn and "" or ""
        homeImage.TextSize = 16
        homeImage.Parent = frame
        
        local beeImage = Instance.new('ImageLabel')
        beeImage.Size = UDim2.fromOffset(18, 18)
        beeImage.Position = UDim2.new(0.5, -5, 0.5, 0)
        beeImage.AnchorPoint = Vector2.new(0, 0.5)
        beeImage.BackgroundTransparency = 1
        beeImage.Image = getBeeIcon()
        beeImage.Parent = frame
        
        local levelLabel = Instance.new('TextLabel')
        levelLabel.Name = 'Level'
        levelLabel.Size = UDim2.new(0, 25, 1, 0)
        levelLabel.Position = UDim2.new(1, -30, 0, 0)
        levelLabel.BackgroundTransparency = 1
        levelLabel.Text = tostring(level)
        levelLabel.TextColor3 = isMaxed and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(255, 255, 255)
        levelLabel.TextSize = 16
        levelLabel.Font = Enum.Font.GothamBold
        levelLabel.TextStrokeTransparency = 0.5
        levelLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
        levelLabel.Parent = frame
        
        if isMaxed and isOwn then
            local maxText = Instance.new('TextLabel')
            maxText.Name = 'MaxText'
            maxText.Size = UDim2.new(1, 0, 0.4, 0)
            maxText.Position = UDim2.new(0, 0, 0, hasOwnerName and -40 or -20)
            maxText.BackgroundTransparency = 1
            maxText.Text = "MAX"
            maxText.TextColor3 = Color3.fromRGB(255, 50, 50)
            maxText.TextSize = 12
            maxText.Font = Enum.Font.GothamBold
            maxText.TextStrokeTransparency = 0.5
            maxText.TextStrokeColor3 = Color3.new(0, 0, 0)
            maxText.Parent = billboard
        end
        
        BeehiveReference[beehive] = {
            billboard = billboard,
            levelLabel = levelLabel,
            beehive = beehive,
            isMaxed = isMaxed,
            isOwn = isOwn
        }
        
        local function updateLevel()
            local level = beehive:GetAttribute("Level") or 0
            local isMaxed = level >= maxBeehiveLevel and isOwn
            
            if isMaxed and isOwn then
                maxedBeehives[beehive] = true
                
                if not maxedNotificationSent[beehive] then
                    notif("Bee Keeper", "Beehive is full (MAX)", 3)
                    maxedNotificationSent[beehive] = true
                end
                
                if BeehiveReference[beehive] and BeehiveReference[beehive].billboard then
                    local maxText = BeehiveReference[beehive].billboard:FindFirstChild("MaxText")
                    if not maxText then
                        maxText = Instance.new('TextLabel')
                        maxText.Name = 'MaxText'
                        maxText.Size = UDim2.new(1, 0, 0.4, 0)
                        maxText.Position = UDim2.new(0, 0, 0, hasOwnerName and -40 or -20)
                        maxText.BackgroundTransparency = 1
                        maxText.Text = "MAX"
                        maxText.TextColor3 = Color3.fromRGB(255, 50, 50)
                        maxText.TextSize = 12
                        maxText.Font = Enum.Font.GothamBold
                        maxText.TextStrokeTransparency = 0.5
                        maxText.TextStrokeColor3 = Color3.new(0, 0, 0)
                        maxText.Parent = BeehiveReference[beehive].billboard
                    end
                    
                    local frame = BeehiveReference[beehive].billboard:FindFirstChild("Frame")
                    if frame then
                        frame.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
                        frame.BackgroundTransparency = 1 - (BeehiveBackground.Enabled and 0.5 or 0)
                    end
                end
            else
                if isOwn then
                    maxedBeehives[beehive] = nil
                    maxedNotificationSent[beehive] = nil
                end
                
                if BeehiveReference[beehive] and BeehiveReference[beehive].billboard then
                    local maxText = BeehiveReference[beehive].billboard:FindFirstChild("MaxText")
                    if maxText then
                        maxText:Destroy()
                    end
                    
                    local frame = BeehiveReference[beehive].billboard:FindFirstChild("Frame")
                    if frame then
                        frame.BackgroundColor3 = Color3.fromHSV(BeehiveColor.Hue, BeehiveColor.Sat, BeehiveColor.Value)
                        frame.BackgroundTransparency = 1 - (BeehiveBackground.Enabled and BeehiveColor.Opacity or 0)
                    end
                end
            end
            
            if BeehiveReference[beehive] and BeehiveReference[beehive].levelLabel then
                BeehiveReference[beehive].levelLabel.Text = tostring(level)
            end
            
            if BeehiveReference[beehive] then
                BeehiveReference[beehive].isMaxed = isMaxed
            end
        end
        
        updateLevel()
        
        if isOwn then
            Beekeeper:Clean(beehive:GetAttributeChangedSignal("Level"):Connect(updateLevel))
        else
            Beekeeper:Clean(beehive:GetAttributeChangedSignal("Level"):Connect(function()
                local level = beehive:GetAttribute("Level") or 0
                if BeehiveReference[beehive] and BeehiveReference[beehive].levelLabel then
                    BeehiveReference[beehive].levelLabel.Text = tostring(level)
                end
            end))
        end
    end


    local function RemovedBeehive(beehive)
        if BeehiveReference[beehive] then
            BeehiveReference[beehive].billboard:Destroy()
            BeehiveReference[beehive] = nil
        end
    end

    local function setupBeesESP()
        for _, v in collectionService:GetTagged('bee') do
            if v:IsA("Model") and v.PrimaryPart then
                if not v.Name:find("TamedBee") and not v:FindFirstChild("TamedBee") then
                    AddedBee(v.PrimaryPart)
                end
            end
        end

        Beekeeper:Clean(collectionService:GetInstanceAddedSignal('bee'):Connect(function(v)
            if v:IsA("Model") and v.PrimaryPart then
                task.wait(0.1)
                if not v.Name:find("TamedBee") and not v:FindFirstChild("TamedBee") then
                    AddedBee(v.PrimaryPart)
                end
            end
        end))

        Beekeeper:Clean(collectionService:GetInstanceRemovedSignal('bee'):Connect(function(v)
            if v.PrimaryPart then
                RemovedBee(v.PrimaryPart)
            end
        end))
        

    end

    local function setupBeehiveESP()
        for _, beehive in collectionService:GetTagged('beehive') do
            AddedBeehive(beehive)
        end

        Beekeeper:Clean(collectionService:GetInstanceAddedSignal('beehive'):Connect(function(beehive)
            task.wait(0.1)
            AddedBeehive(beehive)
        end))

        Beekeeper:Clean(collectionService:GetInstanceRemovedSignal('beehive'):Connect(function(beehive)
            RemovedBeehive(beehive)
        end))
    end

    local function isHoldingBeeNet()
        if not store.hand or not store.hand.tool then return false end
        return store.hand.tool.Name == 'bee_net' or store.hand.tool.Name == 'bee-net'
    end

    local function startCollection()
        collectionRunning = true
        task.spawn(function()
            while collectionRunning and Beekeeper.Enabled and CollectionToggle.Enabled do
                if not entitylib.isAlive then 
                    task.wait(0.1) 
                    continue 
                end
                
                if LimitToNet.Enabled and not isHoldingBeeNet() then
                    task.wait(0.5)
                    continue
                end
                
                local localPosition = entitylib.character.RootPart.Position
                local range = RangeSlider.Value
                local beesFound = false
                
                for _, v in collectionService:GetTagged('bee') do
                    if not collectionRunning or not Beekeeper.Enabled or not CollectionToggle.Enabled then 
                        break 
                    end
                    
                    if LimitToNet.Enabled and not isHoldingBeeNet() then
                        break
                    end
                    
                    if v:IsA("Model") and v.PrimaryPart then
                        local beePos = v.PrimaryPart.Position
                        local distance = (localPosition - beePos).Magnitude
                        
                        if distance <= range then
                            beesFound = true
                            
                            if CollectionDelay.Enabled and DelaySlider.Value > 0 then
                                task.wait(DelaySlider.Value)
                            end
                            
                            if LimitToNet.Enabled and not isHoldingBeeNet() then
                                break
                            end
                            
                            local beeId = v:GetAttribute('BeeId')
                            if beeId then
                                bedwars.Client:Get(remotes.BeePickup):SendToServer({beeId = beeId})
                                task.wait(0.1)
                            end
                        end
                    end
                end
                
                if not beesFound then
                    task.wait(0.2)
                else
                    task.wait(0.1)
                end
            end
            collectionRunning = false
        end)
    end

    local function startDeposit()
        depositRunning = true
        task.spawn(function()
            while depositRunning and Beekeeper.Enabled and AutoDeposit.Enabled do
                if not entitylib.isAlive then 
                    task.wait(0.1) 
                    continue 
                end
                
                local currentTool = store.hand and store.hand.tool
                if not currentTool or currentTool.Name ~= 'bee' then
                    task.wait(0.1)
                    continue
                end
                
                local localPosition = entitylib.character.RootPart.Position
                local range = DepositRange.Value
                local depositedThisCycle = false
                
                local availableBeehives = {}
                for _, beehive in collectionService:GetTagged('beehive') do
                    if isMyBeehive(beehive) and not maxedBeehives[beehive] then
                        local beehivePos = beehive.Position
                        local distance = (localPosition - beehivePos).Magnitude
                        
                        if distance <= range then
                            table.insert(availableBeehives, {
                                beehive = beehive,
                                distance = distance
                            })
                        end
                    end
                end
                
                table.sort(availableBeehives, function(a, b)
                    return a.distance < b.distance
                end)
                
                for _, beehiveData in ipairs(availableBeehives) do
                    if not depositRunning or not Beekeeper.Enabled or not AutoDeposit.Enabled then 
                        break 
                    end
                    local beehive = beehiveData.beehive
                    if maxedBeehives[beehive] then
                        continue
                    end
                    
                    local prompt = beehive:FindFirstChildOfClass("ProximityPrompt")
                    
                    if prompt and prompt.Enabled then
                        if DepositDelay.Enabled and DepositDelaySlider.Value > 0 then
                            local originalDuration = prompt.HoldDuration
                            prompt.HoldDuration = DepositDelaySlider.Value
                            
                            if fireproximityprompt then
                                fireproximityprompt(prompt)
                            else
                                prompt:InputHoldBegin()
                                task.wait(DepositDelaySlider.Value)
                                prompt:InputHoldEnd()
                            end
                            
                            task.wait(DepositDelaySlider.Value + 0.1)
                            prompt.HoldDuration = originalDuration
                        else
                            if fireproximityprompt then
                                fireproximityprompt(prompt)
                            else
                                prompt:InputHoldBegin()
                                prompt:InputHoldEnd()
                            end
                            task.wait(0.1)
                        end
                        
                        depositedThisCycle = true
                        break 
                    end
                end
                
                if not depositedThisCycle and #availableBeehives > 0 then
                    local allMaxed = true
                    for _, beehiveData in ipairs(availableBeehives) do
                        if not maxedBeehives[beehiveData.beehive] then
                            allMaxed = false
                            break
                        end
                    end
                    
                    if allMaxed then
                        notif("Bee Keeper", "All nearby beehives are full", 3)
                    end
                end
                
                task.wait(depositedThisCycle and 0.3 or 0.2)
            end
            depositRunning = false
        end)
    end

    Beekeeper = vape.Categories.Kits:CreateModule({
        Name = 'AutoBeekeeper',
        Function = function(callback)
            if callback then
                if ESPToggle.Enabled then
                    if BeesESP.Enabled then
                        setupBeesESP()
                    end
                    if BeehiveESP.Enabled then
                        setupBeehiveESP()
                    end
                end
                
                if CollectionToggle.Enabled then
                    startCollection()
                end
                
                if AutoDeposit.Enabled then
                    startDeposit()
                end
                
                Beekeeper:Clean(runService.RenderStepped:Connect(function()
                    if not ESPToggle.Enabled then return end
                    
                    for v, billboard in pairs(BeesReference) do
                        if not v or not v.Parent then
                            RemovedBee(v)
                            continue
                        end

                        local shouldShow = true

                        if ESPLimitToNet.Enabled and not isHoldingBeeNet() then
                            shouldShow = false
                        end

                        billboard.Enabled = shouldShow
                    end
                    
                    for beehive, ref in pairs(BeehiveReference) do
                        if not beehive or not beehive.Parent then
                            RemovedBeehive(beehive)
                            continue
                        end

                        local shouldShow = true

                        if ESPLimitToNet.Enabled and not isHoldingBeeNet() then
                            shouldShow = false
                        end

                        if ref.billboard then
                            ref.billboard.Enabled = shouldShow
                        end
                    end
                end))
            else
                collectionRunning = false
                depositRunning = false
                BeesFolder:ClearAllChildren()
                BeehiveFolder:ClearAllChildren()
                table.clear(BeesReference)
                table.clear(BeehiveReference)
                table.clear(spawnQueue)
                lastNotification = 0
            end
        end,
        Tooltip = 'Automatically collects bees and manages beehives'
    })
    
    CollectionToggle = Beekeeper:CreateToggle({
        Name = 'Auto Collect',
        Default = true,
        Tooltip = 'Automatically collect bees',
        Function = function(callback)
            if LimitToNet and LimitToNet.Object then LimitToNet.Object.Visible = callback end
            if CollectionDelay and CollectionDelay.Object then CollectionDelay.Object.Visible = callback end
            if DelaySlider and DelaySlider.Object then DelaySlider.Object.Visible = (callback and CollectionDelay.Enabled) end
            if RangeSlider and RangeSlider.Object then RangeSlider.Object.Visible = callback end
            
            if callback and Beekeeper.Enabled then
                startCollection()
            else
                collectionRunning = false
            end
        end
    })
    
    LimitToNet = Beekeeper:CreateToggle({
        Name = 'Limit to Net',
        Default = false,
        Tooltip = 'Only collect bees when holding bee net'
    })
    
    CollectionDelay = Beekeeper:CreateToggle({
        Name = 'Collection Delay',
        Default = false,
        Tooltip = 'Add delay before collecting bees',
        Function = function(callback)
            if DelaySlider and DelaySlider.Object then
                DelaySlider.Object.Visible = callback
            end
        end
    })
    
    DelaySlider = Beekeeper:CreateSlider({
        Name = 'Delay',
        Min = 0,
        Max = 2,
        Default = 0.5,
        Decimal = 10,
        Suffix = 's',
        Tooltip = 'Delay in seconds before collecting'
    })
    
    RangeSlider = Beekeeper:CreateSlider({
        Name = 'Range',
        Min = 1, 
        Max = 30,
        Default = 18,
        Decimal = 1,
        Suffix = ' studs',
        Tooltip = 'Control distance you want to collect bees'
    })
    
    ESPToggle = Beekeeper:CreateToggle({
        Name = 'ESP',
        Default = true,
        Tooltip = 'ESP for bees and beehives',
        Function = function(callback)
            if BeesESP and BeesESP.Object then BeesESP.Object.Visible = callback end
            if BeehiveESP and BeehiveESP.Object then BeehiveESP.Object.Visible = callback end
            if ESPLimitToNet and ESPLimitToNet.Object then ESPLimitToNet.Object.Visible = callback end  
            
            if Beekeeper.Enabled then
                if callback then
                    if BeesESP.Enabled then setupBeesESP() end
                    if BeehiveESP.Enabled then setupBeehiveESP() end
                else
                    BeesFolder:ClearAllChildren()
                    BeehiveFolder:ClearAllChildren()
                    table.clear(BeesReference)
                    table.clear(BeehiveReference)
                end
            end
        end
    })
    
    ESPLimitToNet = Beekeeper:CreateToggle({
        Name = 'Limit to Net',
        Default = false,
        Tooltip = 'Only show ESP when holding bee net'
    })
    
    BeesESP = Beekeeper:CreateToggle({
        Name = 'Bees',
        Default = false,
        Tooltip = 'Show bee locations',
        Function = function(callback)
            if BeesNotify and BeesNotify.Object then BeesNotify.Object.Visible = callback end
            if BeesBackground and BeesBackground.Object then BeesBackground.Object.Visible = callback end
            if BeesColor and BeesColor.Object then BeesColor.Object.Visible = callback end
            
            if Beekeeper.Enabled and ESPToggle.Enabled then
                if callback then setupBeesESP() else
                    BeesFolder:ClearAllChildren()
                    table.clear(BeesReference)
                end
            end
        end
    })
    
    BeesNotify = Beekeeper:CreateToggle({
        Name = 'Notify',
        Default = false,
        Tooltip = 'Get notifications when bees spawn'
    })
    
    BeesBackground = Beekeeper:CreateToggle({
        Name = 'Background',
        Default = true,
        Function = function(callback)
            if BeesColor and BeesColor.Object then BeesColor.Object.Visible = callback end
            for _, v in BeesReference do
                if v and v:FindFirstChild("ImageLabel") then
                    v.ImageLabel.BackgroundTransparency = 1 - (callback and BeesColor.Opacity or 0)
                    if v:FindFirstChild("Blur") then
                        v.Blur.Visible = callback
                    end
                end
            end
        end
    })
    
	BeesColor = Beekeeper:CreateColorSlider({
		Name = 'Background Color',
		DefaultValue = 0,
		DefaultOpacity = 0.5,
		Function = function(hue, sat, val, opacity)
			for _, v in BeesReference do
				if v and v:FindFirstChild("ImageLabel") then
					v.ImageLabel.BackgroundColor3 = Color3.fromHSV(hue, sat, val)
					v.ImageLabel.BackgroundTransparency = 1 - opacity
				end
			end
		end,
		Darker = true
	})
    
    BeehiveESP = Beekeeper:CreateToggle({
        Name = 'Beehives',
        Default = false,
        Tooltip = 'Show your beehive locations with bee count',
        Function = function(callback)
            if ShowOtherBeehives and ShowOtherBeehives.Object then ShowOtherBeehives.Object.Visible = callback end
            if BeehiveBackground and BeehiveBackground.Object then BeehiveBackground.Object.Visible = callback end
            if BeehiveColor and BeehiveColor.Object then BeehiveColor.Object.Visible = callback end
            
            if Beekeeper.Enabled and ESPToggle.Enabled then
                if callback then setupBeehiveESP() else
                    BeehiveFolder:ClearAllChildren()
                    table.clear(BeehiveReference)
                end
            end
        end
    })
    
    ShowOtherBeehives = Beekeeper:CreateToggle({
        Name = 'Show Others',
        Default = false,
        Tooltip = 'Show other players\' beehives with their usernames',
        Function = function(callback)
            if Beekeeper.Enabled and ESPToggle.Enabled and BeehiveESP.Enabled then
                BeehiveFolder:ClearAllChildren()
                table.clear(BeehiveReference)
                setupBeehiveESP()
            end
        end
    })
    
    BeehiveBackground = Beekeeper:CreateToggle({
        Name = 'Beehive Background',
        Default = true,
        Function = function(callback)
            if BeehiveColor and BeehiveColor.Object then BeehiveColor.Object.Visible = callback end
            for _, ref in BeehiveReference do
                if ref and ref.billboard then
                    local frame = ref.billboard:FindFirstChild("Frame")
                    if frame then
                        if ref.isMaxed and ref.isOwn then
                            frame.BackgroundTransparency = 1 - (callback and 0.5 or 0)
                        else
                            frame.BackgroundTransparency = 1 - (callback and BeehiveColor.Opacity or 0)
                        end
                    end
                    if ref.billboard:FindFirstChild("Blur") then
                        ref.billboard.Blur.Visible = callback
                    end
                end
            end
        end
    })
    
    BeehiveColor = Beekeeper:CreateColorSlider({
        Name = 'Beehive Color',
        DefaultValue = 0,
        DefaultOpacity = 0.5,
        Function = function(hue, sat, val, opacity)
            for _, ref in BeehiveReference do
                if ref and ref.billboard then
                    local frame = ref.billboard:FindFirstChild("Frame")
                    if frame and not (ref.isMaxed and ref.isOwn) then
                        frame.BackgroundColor3 = Color3.fromHSV(hue, sat, val)
                        frame.BackgroundTransparency = 1 - opacity
                    end
                end
            end
        end,
        Darker = true
    })
    
    AutoDeposit = Beekeeper:CreateToggle({
        Name = 'Auto Deposit',
        Default = false,
        Tooltip = 'Automatically deposit bees into your beehives',
        Function = function(callback)
            if DepositDelay and DepositDelay.Object then DepositDelay.Object.Visible = callback end
            if DepositDelaySlider and DepositDelaySlider.Object then DepositDelaySlider.Object.Visible = (callback and DepositDelay.Enabled) end
            if DepositRange and DepositRange.Object then DepositRange.Object.Visible = callback end
            
            if callback and Beekeeper.Enabled then
                startDeposit()
            else
                depositRunning = false
            end
        end
    })
    
    DepositDelay = Beekeeper:CreateToggle({
        Name = 'Deposit Delay',
        Default = false,
        Tooltip = 'Add delay before depositing bees',
        Function = function(callback)
            if DepositDelaySlider and DepositDelaySlider.Object then
                DepositDelaySlider.Object.Visible = callback
            end
        end
    })
    
    DepositDelaySlider = Beekeeper:CreateSlider({
        Name = 'Deposit Delay',
        Min = 0,
        Max = 2,
        Default = 0.5,
        Decimal = 10,
        Suffix = 's',
        Tooltip = 'Delay in seconds before depositing'
    })
    
    DepositRange = Beekeeper:CreateSlider({
        Name = 'Deposit Range',
        Min = 1,
        Max = 15,
        Default = 10,
        Decimal = 1,
        Suffix = ' studs',
        Tooltip = 'Range to deposit bees into beehives'
    })
end)

run(function()
	local ESP
	local Targets
	local Color
	local Method
	local BoundingBox
	local Filled
	local HealthBar
	local Name
	local DisplayName
	local Background
	local Teammates
	local Distance
	local DistanceLimit
	local SmartLegit
	local SmartLegitRange
	local Reference = {}
	local methodused
	local smartLegitEnabled = false
	local cachedNames = {}
	local cachedColors = {}
	local lastFrameCheck = 0
	local FRAME_SKIP = 2 
	local frameCounter = 0
	local tempVector2 = Vector2.new()
	local vec2new = Vector2.new
	local vec3new = Vector3.new
	local cfnew = CFrame.new
	local c3fromHSV = Color3.fromHSV
	local mathclamp = math.clamp
	local mathfloor = math.floor
	
	local function ESPWorldToViewport(pos)
		local newpos = gameCamera:WorldToViewportPoint(gameCamera.CFrame:pointToWorldSpace(gameCamera.CFrame:PointToObjectSpace(pos)))
		return vec2new(newpos.X, newpos.Y)
	end
	
	local cachedRangeCheck = false
	local lastRangeCheckTime = 0
	local RANGE_CHECK_INTERVAL = 0.1 
	
	local function isAnyTargetInRange()
		if not entitylib.isAlive then return false end
		
		local currentTime = tick()
		if currentTime - lastRangeCheckTime < RANGE_CHECK_INTERVAL then
			return cachedRangeCheck
		end
		
		lastRangeCheckTime = currentTime
		local myPos = entitylib.character.RootPart.Position
		local range = SmartLegitRange.Value
		local rangeSq = range * range 
		
		for ent, _ in Reference do
			if not ent or not ent.RootPart then continue end
			if Teammates.Enabled and (not ent.Targetable) and (not ent.Friend) then continue end
			if not Targets.Players.Enabled and ent.Player then continue end
			if not Targets.NPCs.Enabled and ent.NPC then continue end
			
			local distSq = (myPos - ent.RootPart.Position).Magnitude
			distSq = distSq * distSq 
			if distSq <= rangeSq then
				cachedRangeCheck = true
				return true
			end
		end
		
		cachedRangeCheck = false
		return false
	end
	
	local function setAllVisibility(visible)
		for ent, EntityESP in Reference do
			for _, obj in EntityESP do
				obj.Visible = visible
			end
		end
	end
	
	local function getCachedName(ent)
		local cacheKey = ent.Player or ent.Character
		if cachedNames[cacheKey] then
			return cachedNames[cacheKey]
		end
		
		local name = ent.Player and whitelist:tag(ent.Player, true)..(DisplayName.Enabled and ent.Player.DisplayName or ent.Player.Name) or ent.Character.Name
		cachedNames[cacheKey] = name
		return name
	end
	
	local function getCachedColor(ent)
		if cachedColors[ent] then
			return cachedColors[ent]
		end
		local color = entitylib.getEntityColor(ent) or c3fromHSV(Color.Hue, Color.Sat, Color.Value)
		cachedColors[ent] = color
		return color
	end
	
	local ESPAdded = {
		Drawing2D = function(ent)
			if not Targets.Players.Enabled and ent.Player then return end
			if not Targets.NPCs.Enabled and ent.NPC then return end
			if Teammates.Enabled and (not ent.Targetable) and (not ent.Friend) then return end
			if vape.ThreadFix then
				setthreadidentity(8)
			end
			local EntityESP = {}
			EntityESP.Main = Drawing.new('Square')
			EntityESP.Main.Transparency = BoundingBox.Enabled and 1 or 0
			EntityESP.Main.ZIndex = 2
			EntityESP.Main.Filled = false
			EntityESP.Main.Thickness = 1
			EntityESP.Main.Color = getCachedColor(ent)

			if BoundingBox.Enabled then
				EntityESP.Border = Drawing.new('Square')
				EntityESP.Border.Transparency = 0.35
				EntityESP.Border.ZIndex = 1
				EntityESP.Border.Thickness = 1
				EntityESP.Border.Filled = false
				EntityESP.Border.Color = Color3.new()
				EntityESP.Border2 = Drawing.new('Square')
				EntityESP.Border2.Transparency = 0.35
				EntityESP.Border2.ZIndex = 1
				EntityESP.Border2.Thickness = 1
				EntityESP.Border2.Filled = Filled.Enabled
				EntityESP.Border2.Color = Color3.new()
			end

			if HealthBar.Enabled then
				EntityESP.HealthLine = Drawing.new('Line')
				EntityESP.HealthLine.Thickness = 1
				EntityESP.HealthLine.ZIndex = 2
				EntityESP.HealthLine.Color = c3fromHSV(mathclamp(ent.Health / ent.MaxHealth, 0, 1) / 2.5, 0.89, 0.75)
				EntityESP.HealthBorder = Drawing.new('Line')
				EntityESP.HealthBorder.Thickness = 3
				EntityESP.HealthBorder.Transparency = 0.35
				EntityESP.HealthBorder.ZIndex = 1
				EntityESP.HealthBorder.Color = Color3.new()
			end
			
			if Name.Enabled then
				if Background.Enabled then
					EntityESP.TextBKG = Drawing.new('Square')
					EntityESP.TextBKG.Transparency = 0.35
					EntityESP.TextBKG.ZIndex = 0
					EntityESP.TextBKG.Thickness = 1
					EntityESP.TextBKG.Filled = true
					EntityESP.TextBKG.Color = Color3.new()
				end
				EntityESP.Drop = Drawing.new('Text')
				EntityESP.Drop.Color = Color3.new()
				EntityESP.Drop.Text = getCachedName(ent)
				EntityESP.Drop.ZIndex = 1
				EntityESP.Drop.Center = true
				EntityESP.Drop.Size = 20
				EntityESP.Text = Drawing.new('Text')
				EntityESP.Text.Text = EntityESP.Drop.Text
				EntityESP.Text.ZIndex = 2
				EntityESP.Text.Color = EntityESP.Main.Color
				EntityESP.Text.Center = true
				EntityESP.Text.Size = 20
			end
			Reference[ent] = EntityESP
		end,
		Drawing3D = function(ent)
			if not Targets.Players.Enabled and ent.Player then return end
			if not Targets.NPCs.Enabled and ent.NPC then return end
			if Teammates.Enabled and (not ent.Targetable) and (not ent.Friend) then return end
			if vape.ThreadFix then
				setthreadidentity(8)
			end
			local EntityESP = {}
			EntityESP.Line1 = Drawing.new('Line')
			EntityESP.Line2 = Drawing.new('Line')
			EntityESP.Line3 = Drawing.new('Line')
			EntityESP.Line4 = Drawing.new('Line')
			EntityESP.Line5 = Drawing.new('Line')
			EntityESP.Line6 = Drawing.new('Line')
			EntityESP.Line7 = Drawing.new('Line')
			EntityESP.Line8 = Drawing.new('Line')
			EntityESP.Line9 = Drawing.new('Line')
			EntityESP.Line10 = Drawing.new('Line')
			EntityESP.Line11 = Drawing.new('Line')
			EntityESP.Line12 = Drawing.new('Line')

			local color = getCachedColor(ent)
			for _, v in EntityESP do
				v.Thickness = 1
				v.Color = color
			end

			Reference[ent] = EntityESP
		end,
		DrawingSkeleton = function(ent)
			if not Targets.Players.Enabled and ent.Player then return end
			if not Targets.NPCs.Enabled and ent.NPC then return end
			if Teammates.Enabled and (not ent.Targetable) and (not ent.Friend) then return end
			if vape.ThreadFix then
				setthreadidentity(8)
			end
			local EntityESP = {}
			EntityESP.Head = Drawing.new('Line')
			EntityESP.HeadFacing = Drawing.new('Line')
			EntityESP.Torso = Drawing.new('Line')
			EntityESP.UpperTorso = Drawing.new('Line')
			EntityESP.LowerTorso = Drawing.new('Line')
			EntityESP.LeftArm = Drawing.new('Line')
			EntityESP.RightArm = Drawing.new('Line')
			EntityESP.LeftLeg = Drawing.new('Line')
			EntityESP.RightLeg = Drawing.new('Line')

			local color = getCachedColor(ent)
			for _, v in EntityESP do
				v.Thickness = 2
				v.Color = color
			end

			Reference[ent] = EntityESP
		end
	}
	
	local ESPRemoved = {
		Drawing2D = function(ent)
			local EntityESP = Reference[ent]
			if EntityESP then
				if vape.ThreadFix then
					setthreadidentity(8)
				end
				Reference[ent] = nil
				cachedNames[ent.Player or ent.Character] = nil
				cachedColors[ent] = nil
				for _, v in EntityESP do
					pcall(function()
						v.Visible = false
						v:Remove()
					end)
				end
			end
		end
	}
	ESPRemoved.Drawing3D = ESPRemoved.Drawing2D
	ESPRemoved.DrawingSkeleton = ESPRemoved.Drawing2D
	
	local ESPUpdated = {
		Drawing2D = function(ent)
			local EntityESP = Reference[ent]
			if EntityESP then
				if vape.ThreadFix then
					setthreadidentity(8)
				end
				
				if EntityESP.HealthLine then
					EntityESP.HealthLine.Color = c3fromHSV(mathclamp(ent.Health / ent.MaxHealth, 0, 1) / 2.5, 0.89, 0.75)
				end

				if EntityESP.Text then
					cachedNames[ent.Player or ent.Character] = nil
					local newName = getCachedName(ent)
					EntityESP.Text.Text = newName
					EntityESP.Drop.Text = newName
				end
			end
		end
	}
	
	local ColorFunc = {
		Drawing2D = function(hue, sat, val)
			local color = c3fromHSV(hue, sat, val)
			cachedColors = {}
			for i, v in Reference do
				local entityColor = getCachedColor(i)
				v.Main.Color = entityColor
				if v.Text then
					v.Text.Color = entityColor
				end
			end
		end,
		Drawing3D = function(hue, sat, val)
			local color = c3fromHSV(hue, sat, val)
			cachedColors = {}
			for i, v in Reference do
				local playercolor = getCachedColor(i)
				for _, v2 in v do
					v2.Color = playercolor
				end
			end
		end
	}
	ColorFunc.DrawingSkeleton = ColorFunc.Drawing3D
	
	local ESPLoop = {
		Drawing2D = function()
			frameCounter = frameCounter + 1
			if frameCounter % FRAME_SKIP ~= 0 then
				return
			end
			
			local hideAll = smartLegitEnabled and isAnyTargetInRange()
			local myRootPart = entitylib.isAlive and entitylib.character.RootPart
			local myPos = myRootPart and myRootPart.Position
			local distanceEnabled = Distance.Enabled
			local distMin = distanceEnabled and DistanceLimit.ValueMin or 0
			local distMax = distanceEnabled and DistanceLimit.ValueMax or math.huge
			
			for ent, EntityESP in Reference do
				if hideAll then
					for _, obj in EntityESP do
						obj.Visible = false
					end
					continue
				end
				
				if distanceEnabled and myPos then
					local dist = (myPos - ent.RootPart.Position).Magnitude
					if dist < distMin or dist > distMax then
						for _, obj in EntityESP do
							obj.Visible = false
						end
						continue
					end
				end

				local rootPos, rootVis = gameCamera:WorldToViewportPoint(ent.RootPart.Position)
				for _, obj in EntityESP do
					obj.Visible = rootVis
				end
				if not rootVis then continue end

				local camLookVector = gameCamera.CFrame.LookVector
				local hipHeight = ent.HipHeight
				local entRootPos = ent.RootPart.Position
				
				local topPos = gameCamera:WorldToViewportPoint((CFrame.lookAlong(entRootPos, camLookVector) * cfnew(2, hipHeight, 0)).p)
				local bottomPos = gameCamera:WorldToViewportPoint((CFrame.lookAlong(entRootPos, camLookVector) * cfnew(-2, -hipHeight - 1, 0)).p)
				
				local sizex, sizey = topPos.X - bottomPos.X, topPos.Y - bottomPos.Y
				local posx, posy = rootPos.X - sizex / 2, rootPos.Y - sizey / 2
				
				EntityESP.Main.Position = vec2new(mathfloor(posx), mathfloor(posy))
				EntityESP.Main.Size = vec2new(mathfloor(sizex), mathfloor(sizey))
				
				if EntityESP.Border then
					EntityESP.Border.Position = vec2new(mathfloor(posx - 1), mathfloor(posy + 1))
					EntityESP.Border.Size = vec2new(mathfloor(sizex + 2), mathfloor(sizey - 2))
					EntityESP.Border2.Position = vec2new(mathfloor(posx + 1), mathfloor(posy - 1))
					EntityESP.Border2.Size = vec2new(mathfloor(sizex - 2), mathfloor(sizey + 2))
				end

				if EntityESP.HealthLine then
					local healthRatio = mathclamp(ent.Health / ent.MaxHealth, 0, 1)
					local healthposy = sizey * healthRatio
					EntityESP.HealthLine.Visible = ent.Health > 0
					EntityESP.HealthLine.From = vec2new(mathfloor(posx - 6), mathfloor(posy + (sizey - (sizey - healthposy))))
					EntityESP.HealthLine.To = vec2new(mathfloor(posx - 6), mathfloor(posy))
					EntityESP.HealthBorder.From = vec2new(mathfloor(posx - 6), mathfloor(posy + 1))
					EntityESP.HealthBorder.To = vec2new(mathfloor(posx - 6), mathfloor(posy + sizey - 1))
				end

				if EntityESP.Text then
					EntityESP.Text.Position = vec2new(mathfloor(posx + (sizex / 2)), mathfloor(posy + (sizey - 28)))
					EntityESP.Drop.Position = EntityESP.Text.Position + vec2new(1, 1)
					if EntityESP.TextBKG then
						local textBounds = EntityESP.Text.TextBounds
						EntityESP.TextBKG.Size = textBounds + vec2new(8, 4)
						EntityESP.TextBKG.Position = EntityESP.Text.Position - vec2new(4 + (textBounds.X / 2), 0)
					end
				end
			end
		end,
		Drawing3D = function()
			frameCounter = frameCounter + 1
			if frameCounter % FRAME_SKIP ~= 0 then
				return
			end
			
			local hideAll = smartLegitEnabled and isAnyTargetInRange()
			local myRootPart = entitylib.isAlive and entitylib.character.RootPart
			local myPos = myRootPart and myRootPart.Position
			local distanceEnabled = Distance.Enabled
			local distMin = distanceEnabled and DistanceLimit.ValueMin or 0
			local distMax = distanceEnabled and DistanceLimit.ValueMax or math.huge
			
			for ent, EntityESP in Reference do
				if hideAll then
					for _, obj in EntityESP do
						obj.Visible = false
					end
					continue
				end
				
				if distanceEnabled and myPos then
					local dist = (myPos - ent.RootPart.Position).Magnitude
					if dist < distMin or dist > distMax then
						for _, obj in EntityESP do
							obj.Visible = false
						end
						continue
					end
				end

				local _, rootVis = gameCamera:WorldToViewportPoint(ent.RootPart.Position)
				for _, obj in EntityESP do
					obj.Visible = rootVis
				end
				if not rootVis then continue end

				local entRootPos = ent.RootPart.Position
				local hipHeight = ent.HipHeight
				
				local v1_5 = vec3new(1.5, hipHeight, 1.5)
				local v2_5 = vec3new(1.5, -hipHeight, 1.5)
				local v3_5 = vec3new(-1.5, hipHeight, 1.5)
				local v4_5 = vec3new(-1.5, -hipHeight, 1.5)
				local v5_5 = vec3new(1.5, hipHeight, -1.5)
				local v6_5 = vec3new(1.5, -hipHeight, -1.5)
				local v7_5 = vec3new(-1.5, hipHeight, -1.5)
				local v8_5 = vec3new(-1.5, -hipHeight, -1.5)
				
				local point1 = ESPWorldToViewport(entRootPos + v1_5)
				local point2 = ESPWorldToViewport(entRootPos + v2_5)
				local point3 = ESPWorldToViewport(entRootPos + v3_5)
				local point4 = ESPWorldToViewport(entRootPos + v4_5)
				local point5 = ESPWorldToViewport(entRootPos + v5_5)
				local point6 = ESPWorldToViewport(entRootPos + v6_5)
				local point7 = ESPWorldToViewport(entRootPos + v7_5)
				local point8 = ESPWorldToViewport(entRootPos + v8_5)
				
				EntityESP.Line1.From = point1
				EntityESP.Line1.To = point2
				EntityESP.Line2.From = point3
				EntityESP.Line2.To = point4
				EntityESP.Line3.From = point5
				EntityESP.Line3.To = point6
				EntityESP.Line4.From = point7
				EntityESP.Line4.To = point8
				EntityESP.Line5.From = point1
				EntityESP.Line5.To = point3
				EntityESP.Line6.From = point1
				EntityESP.Line6.To = point5
				EntityESP.Line7.From = point5
				EntityESP.Line7.To = point7
				EntityESP.Line8.From = point7
				EntityESP.Line8.To = point3
				EntityESP.Line9.From = point2
				EntityESP.Line9.To = point4
				EntityESP.Line10.From = point2
				EntityESP.Line10.To = point6
				EntityESP.Line11.From = point6
				EntityESP.Line11.To = point8
				EntityESP.Line12.From = point8
				EntityESP.Line12.To = point4
			end
		end,
		DrawingSkeleton = function()
			frameCounter = frameCounter + 1
			if frameCounter % FRAME_SKIP ~= 0 then
				return
			end
			
			local hideAll = smartLegitEnabled and isAnyTargetInRange()
			local myRootPart = entitylib.isAlive and entitylib.character.RootPart
			local myPos = myRootPart and myRootPart.Position
			local distanceEnabled = Distance.Enabled
			local distMin = distanceEnabled and DistanceLimit.ValueMin or 0
			local distMax = distanceEnabled and DistanceLimit.ValueMax or math.huge
			
			for ent, EntityESP in Reference do
				if hideAll then
					for _, obj in EntityESP do
						obj.Visible = false
					end
					continue
				end
				
				if distanceEnabled and myPos then
					local dist = (myPos - ent.RootPart.Position).Magnitude
					if dist < distMin or dist > distMax then
						for _, obj in EntityESP do
							obj.Visible = false
						end
						continue
					end
				end

				local _, rootVis = gameCamera:WorldToViewportPoint(ent.RootPart.Position)
				for _, obj in EntityESP do
					obj.Visible = rootVis
				end
				if not rootVis then continue end
				
				local rigcheck = ent.Humanoid.RigType == Enum.HumanoidRigType.R6
				pcall(function()
					local offset = rigcheck and cfnew(0, -0.8, 0) or CFrame.identity
					local torsoName = rigcheck and 'Torso' or 'UpperTorso'
					local leftArmName = rigcheck and 'Left Arm' or 'LeftHand'
					local rightArmName = rigcheck and 'Right Arm' or 'RightHand'
					local leftLegName = rigcheck and 'Left Leg' or 'LeftFoot'
					local rightLegName = rigcheck and 'Right Leg' or 'RightFoot'
					
					local head = ESPWorldToViewport((ent.Head.CFrame).p)
					local headfront = ESPWorldToViewport((ent.Head.CFrame * cfnew(0, 0, -0.5)).p)
					local torso = ent.Character[torsoName].CFrame
					local toplefttorso = ESPWorldToViewport((torso * cfnew(-1.5, 0.8, 0)).p)
					local toprighttorso = ESPWorldToViewport((torso * cfnew(1.5, 0.8, 0)).p)
					local toptorso = ESPWorldToViewport((torso * cfnew(0, 0.8, 0)).p)
					local bottomtorso = ESPWorldToViewport((torso * cfnew(0, -0.8, 0)).p)
					local bottomlefttorso = ESPWorldToViewport((torso * cfnew(-0.5, -0.8, 0)).p)
					local bottomrighttorso = ESPWorldToViewport((torso * cfnew(0.5, -0.8, 0)).p)
					local leftarm = ESPWorldToViewport((ent.Character[leftArmName].CFrame * offset).p)
					local rightarm = ESPWorldToViewport((ent.Character[rightArmName].CFrame * offset).p)
					local leftleg = ESPWorldToViewport((ent.Character[leftLegName].CFrame * offset).p)
					local rightleg = ESPWorldToViewport((ent.Character[rightLegName].CFrame * offset).p)
					
					EntityESP.Head.From = toptorso
					EntityESP.Head.To = head
					EntityESP.HeadFacing.From = head
					EntityESP.HeadFacing.To = headfront
					EntityESP.UpperTorso.From = toplefttorso
					EntityESP.UpperTorso.To = toprighttorso
					EntityESP.Torso.From = toptorso
					EntityESP.Torso.To = bottomtorso
					EntityESP.LowerTorso.From = bottomlefttorso
					EntityESP.LowerTorso.To = bottomrighttorso
					EntityESP.LeftArm.From = toplefttorso
					EntityESP.LeftArm.To = leftarm
					EntityESP.RightArm.From = toprighttorso
					EntityESP.RightArm.To = rightarm
					EntityESP.LeftLeg.From = bottomlefttorso
					EntityESP.LeftLeg.To = leftleg
					EntityESP.RightLeg.From = bottomrighttorso
					EntityESP.RightLeg.To = rightleg
				end)
			end
		end
	}
	
	ESP = vape.Categories.Render:CreateModule({
		Name = 'ESP',
		Function = function(callback)
			if callback then
				frameCounter = 0
				cachedNames = {}
				cachedColors = {}
				methodused = 'Drawing'..Method.Value
				
				if ESPRemoved[methodused] then
					ESP:Clean(entitylib.Events.EntityRemoved:Connect(ESPRemoved[methodused]))
				end
				if ESPAdded[methodused] then
					for _, v in entitylib.List do
						if Reference[v] then
							ESPRemoved[methodused](v)
						end
						ESPAdded[methodused](v)
					end
					ESP:Clean(entitylib.Events.EntityAdded:Connect(function(ent)
						if Reference[ent] then
							ESPRemoved[methodused](ent)
						end
						ESPAdded[methodused](ent)
					end))
				end
				if ESPUpdated[methodused] then
					ESP:Clean(entitylib.Events.EntityUpdated:Connect(ESPUpdated[methodused]))
					for _, v in entitylib.List do
						ESPUpdated[methodused](v)
					end
				end
				if ColorFunc[methodused] then
					ESP:Clean(vape.Categories.Friends.ColorUpdate.Event:Connect(function()
						ColorFunc[methodused](Color.Hue, Color.Sat, Color.Value)
					end))
				end
				if ESPLoop[methodused] then
					ESP:Clean(runService.RenderStepped:Connect(ESPLoop[methodused]))
				end
			else
				smartLegitEnabled = false
				
				if ESPRemoved[methodused] then
					for i in Reference do
						ESPRemoved[methodused](i)
					end
				end
				
				cachedNames = {}
				cachedColors = {}
			end
		end,
		Tooltip = 'Extra Sensory Perception\nRenders an ESP on players.'
	})
	
	Targets = ESP:CreateTargets({
		Players = true,
		Function = function()
			if ESP.Enabled then
				ESP:Toggle()
				ESP:Toggle()
			end
		end
	})
	
	Method = ESP:CreateDropdown({
		Name = 'Mode',
		List = {'2D', '3D', 'Skeleton'},
		Function = function(val)
			if ESP.Enabled then
				ESP:Toggle()
				ESP:Toggle()
			end
			BoundingBox.Object.Visible = (val == '2D')
			Filled.Object.Visible = (val == '2D')
			HealthBar.Object.Visible = (val == '2D')
			Name.Object.Visible = (val == '2D')
			DisplayName.Object.Visible = Name.Object.Visible and Name.Enabled
			Background.Object.Visible = Name.Object.Visible and Name.Enabled
		end,
	})
	
	Color = ESP:CreateColorSlider({
		Name = 'Player Color',
		Function = function(hue, sat, val)
			if ESP.Enabled and ColorFunc[methodused] then
				ColorFunc[methodused](hue, sat, val)
			end
		end
	})
	
	BoundingBox = ESP:CreateToggle({
		Name = 'Bounding Box',
		Function = function()
			if ESP.Enabled then
				ESP:Toggle()
				ESP:Toggle()
			end
		end,
		Default = true,
		Darker = true
	})
	
	Filled = ESP:CreateToggle({
		Name = 'Filled',
		Function = function()
			if ESP.Enabled then
				ESP:Toggle()
				ESP:Toggle()
			end
		end,
		Darker = true
	})
	
	HealthBar = ESP:CreateToggle({
		Name = 'Health Bar',
		Function = function()
			if ESP.Enabled then
				ESP:Toggle()
				ESP:Toggle()
			end
		end,
		Darker = true
	})
	
	Name = ESP:CreateToggle({
		Name = 'Name',
		Function = function(callback)
			if ESP.Enabled then
				ESP:Toggle()
				ESP:Toggle()
			end
			DisplayName.Object.Visible = callback
			Background.Object.Visible = callback
		end,
		Darker = true
	})
	
	DisplayName = ESP:CreateToggle({
		Name = 'Use Displayname',
		Function = function()
			if ESP.Enabled then
				cachedNames = {} 
				ESP:Toggle()
				ESP:Toggle()
			end
		end,
		Default = true,
		Darker = true
	})
	
	Background = ESP:CreateToggle({
		Name = 'Show Background',
		Function = function()
			if ESP.Enabled then
				ESP:Toggle()
				ESP:Toggle()
			end
		end,
		Darker = true
	})
	
	Teammates = ESP:CreateToggle({
		Name = 'Priority Only',
		Function = function()
			if ESP.Enabled then
				ESP:Toggle()
				ESP:Toggle()
			end
		end,
		Default = true,
		Tooltip = 'Hides teammates & non targetable entities'
	})
	
	Distance = ESP:CreateToggle({
		Name = 'Distance Check',
		Function = function(callback)
			DistanceLimit.Object.Visible = callback
		end
	})
	
	DistanceLimit = ESP:CreateTwoSlider({
		Name = 'Player Distance',
		Min = 0,
		Max = 256,
		DefaultMin = 0,
		DefaultMax = 64,
		Darker = true,
		Visible = false
	})
	
	SmartLegit = ESP:CreateToggle({
		Name = 'Smart Legit ESP',
		Default = false,
		Tooltip = 'Hides all ESP when any target is within range',
		Function = function(callback)
			smartLegitEnabled = callback
			SmartLegitRange.Object.Visible = callback
			cachedRangeCheck = false
			lastRangeCheckTime = 0
		end
	})
	
	SmartLegitRange = ESP:CreateSlider({
		Name = 'Hide Range',
		Min = 1,
		Max = 200,
		Default = 30,
		Decimal = 1,
		Suffix = ' studs',
		Visible = false,
		Tooltip = 'ESP hides when a target is within this range'
	})
end)

run(function()
    local FarmerCletus
    local CollectionToggle
    local Animation
    local RangeSlider
    local ESPToggle
    local ESPNotify
    local ESPBackground
    local ESPColor
    local AutoBuyCarrot
    local CarrotAmount
    local CarrotBuyDelay
    local AutoBuyMelon
    local MelonAmount
    local MelonBuyDelay
    local AutoBuyPumpkin
    local PumpkinAmount
    local PumpkinBuyDelay
    local GUICheck
    
    local Folder = Instance.new('Folder')
    Folder.Parent = vape.gui
    local Reference = {}
    local lastNotification = 0
    local spawnQueue = {}
    local notificationCooldown = 1
    
    local buyRunning = {
        carrot = false,
        melon = false,
        pumpkin = false
    }
    
    local buyCount = {
        carrot = 0,
        melon = 0,
        pumpkin = 0
    }
    local function kitCollection(id, func, range, specific)
        local objs = type(id) == 'table' and id or collection(id, FarmerCletus)
        repeat
            if entitylib.isAlive then
                local localPosition = entitylib.character.RootPart.Position
                for _, v in objs do
                    if not FarmerCletus.Enabled then break end
                    local part = not v:IsA('Model') and v or v.PrimaryPart
                    if part and (part.Position - localPosition).Magnitude <= range then
                        func(v)
                    end
                end
            end
            task.wait(0.1)
        until not FarmerCletus.Enabled
    end

    local function sendNotification(count)
        notif("Crop ESP", string.format("%d crops spawned", count), 3)
    end

    local function processSpawnQueue()
        if #spawnQueue > 0 then
            local currentTime = tick()
            if currentTime - lastNotification >= notificationCooldown then
                sendNotification(#spawnQueue)
                lastNotification = currentTime
                spawnQueue = {}
            else
                task.delay(notificationCooldown - (currentTime - lastNotification), function()
                    if #spawnQueue > 0 then
                        sendNotification(#spawnQueue)
                        spawnQueue = {}
                    end
                end)
            end
        end
    end

    local function getProperImage(v)
        if v.Name == "carrot" then
            return bedwars.getIcon({itemType = 'carrot_seeds'}, true)
        elseif v.Name == "melon" then
            return bedwars.getIcon({itemType = 'melon_seeds'}, true)
        elseif v.Name == "pumpkin" then
            return bedwars.getIcon({itemType = 'pumpkin_seeds'}, true)
        end
        return bedwars.getIcon({itemType = 'carrot_seeds'}, true)
    end

    local function Added(v)
        if Reference[v] then return end
        
        local billboard = Instance.new('BillboardGui')
        billboard.Parent = Folder
        billboard.Name = 'crop'
        billboard.StudsOffsetWorldSpace = Vector3.new(0, 3, 0)
        billboard.Size = UDim2.fromOffset(36, 36)
        billboard.AlwaysOnTop = true
        billboard.ClipsDescendants = false
        billboard.Adornee = v
        
        local blur = addBlur(billboard)
        blur.Visible = ESPBackground.Enabled
        
        local image = Instance.new('ImageLabel')
        image.Size = UDim2.fromOffset(36, 36)
        image.Position = UDim2.fromScale(0.5, 0.5)
        image.AnchorPoint = Vector2.new(0.5, 0.5)
        image.BackgroundColor3 = Color3.fromHSV(ESPColor.Hue, ESPColor.Sat, ESPColor.Value)
        image.BackgroundTransparency = 1 - (ESPBackground.Enabled and ESPColor.Opacity or 0)
        image.BorderSizePixel = 0
        image.Image = getProperImage(v)
        image.Parent = billboard
        
        local uicorner = Instance.new('UICorner')
        uicorner.CornerRadius = UDim.new(0, 4)
        uicorner.Parent = image
        
        Reference[v] = billboard
        
        if ESPNotify.Enabled then
            table.insert(spawnQueue, {item = 'crop', time = tick()})
            processSpawnQueue()
        end
    end

    local function Removed(v)
        if Reference[v] then
            Reference[v]:Destroy()
            Reference[v] = nil
        end
    end

    local function findExistingCrops()
        for _, obj in pairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") and (obj.Name == "carrot" or obj.Name == "melon" or obj.Name == "pumpkin") then
                if obj.Parent == workspace or obj.Parent.Parent == workspace then
                    task.wait(0.1)
                    Added(obj)
                end
            end
        end
    end

    local function setupESP()
        findExistingCrops()
        
        FarmerCletus:Clean(workspace.DescendantAdded:Connect(function(obj)
            if obj:IsA("BasePart") and (obj.Name == "carrot" or obj.Name == "melon" or obj.Name == "pumpkin") then
                if obj.Parent == workspace or obj.Parent.Parent == workspace then
                    task.wait(0.1)
                    Added(obj)
                end
            end
        end))
        
        FarmerCletus:Clean(workspace.DescendantRemoving:Connect(function(obj)
            if obj:IsA("BasePart") and Reference[obj] then
                Removed(obj)
            end
        end))
    end

    local function getShopNPC()
        local shopFound = false
        if entitylib.isAlive then
            local localPosition = entitylib.character.RootPart.Position
            for _, v in store.shop do
                if (v.RootPart.Position - localPosition).Magnitude <= 20 then
                    shopFound = true
                    break
                end
            end
        end
        return shopFound
    end
    
    local function buyCarrot()
        pcall(function()
            local args = {
                {
                    shopItem = {
                        currency = "iron",
                        itemType = "carrot_seeds",
                        amount = 1,
                        price = 60,
                        category = "Combat",
                        requiresKit = {"farmer_cletus"}
                    },
                    shopId = "1_item_shop"
                }
            }
            game:GetService("ReplicatedStorage")
                :WaitForChild("rbxts_include")
                :WaitForChild("node_modules")
                :WaitForChild("@rbxts")
                :WaitForChild("net")
                :WaitForChild("out")
                :WaitForChild("_NetManaged")
                :WaitForChild("BedwarsPurchaseItem")
                :InvokeServer(unpack(args))
        end)
    end
    
    local function buyMelon()
        pcall(function()
            local args = {
                {
                    shopItem = {
                        currency = "emerald",
                        itemType = "melon_seeds",
                        amount = 1,
                        price = 2,
                        category = "Combat",
                        requiresKit = {"farmer_cletus"}
                    },
                    shopId = "1_item_shop"
                }
            }
            game:GetService("ReplicatedStorage")
                :WaitForChild("rbxts_include")
                :WaitForChild("node_modules")
                :WaitForChild("@rbxts")
                :WaitForChild("net")
                :WaitForChild("out")
                :WaitForChild("_NetManaged")
                :WaitForChild("BedwarsPurchaseItem")
                :InvokeServer(unpack(args))
        end)
    end
    
    local function buyPumpkin()
        pcall(function()
            local args = {
                {
                    shopItem = {
                        currency = "iron",
                        requiresKit = {"farmer_cletus"},
                        category = "Combat",
                        price = 100,
                        itemType = "pumpkin_seeds",
                        customDisplayName = "Pumpkin Seeds",
                        amount = 1
                    },
                    shopId = "1_item_shop"
                }
            }
            game:GetService("ReplicatedStorage")
                :WaitForChild("rbxts_include")
                :WaitForChild("node_modules")
                :WaitForChild("@rbxts")
                :WaitForChild("net")
                :WaitForChild("out")
                :WaitForChild("_NetManaged")
                :WaitForChild("BedwarsPurchaseItem")
                :InvokeServer(unpack(args))
        end)
    end
    
    local function startAutoBuy(cropType, buyFunc, amountSlider, delaySlider)
        buyRunning[cropType] = true
        buyCount[cropType] = 0
        
        task.spawn(function()
            while buyRunning[cropType] and FarmerCletus.Enabled do
                if buyCount[cropType] >= amountSlider.Value then
                    buyRunning[cropType] = false
                    break
                end
                
                local canBuy = true
                
                if GUICheck.Enabled then
                    canBuy = bedwars.AppController:isAppOpen('BedwarsItemShopApp')
                else
                    canBuy = getShopNPC()
                end
                
                if canBuy then
                    buyFunc()
                    buyCount[cropType] = buyCount[cropType] + 1
                end
                
                task.wait(delaySlider.Value)
            end
        end)
    end

    FarmerCletus = vape.Categories.Kits:CreateModule({
        Name = 'AutoFarmer',
        Function = function(callback)
            if callback then
                if ESPToggle.Enabled then
                    setupESP()
                end
                
                if CollectionToggle.Enabled then
                    task.spawn(function()
                        kitCollection('HarvestableCrop', function(v)
                            if Animation.Enabled then
                                bedwars.GameAnimationUtil:playAnimation(lplr.Character, bedwars.AnimationType.PUNCH)
                                bedwars.ViewmodelController:playAnimation(bedwars.AnimationType.FP_USE_ITEM)
                                bedwars.SoundManager:playSound(bedwars.SoundList.CROP_HARVEST)
                            end
                            bedwars.Client:Get('CropHarvest'):CallServer({
                                position = bedwars.BlockController:getBlockPosition(v.Position)
                            })
                        end, RangeSlider.Value, false)
                    end)
                end
                
                if AutoBuyCarrot.Enabled then
                    startAutoBuy('carrot', buyCarrot, CarrotAmount, CarrotBuyDelay)
                end
                if AutoBuyMelon.Enabled then
                    startAutoBuy('melon', buyMelon, MelonAmount, MelonBuyDelay)
                end
                if AutoBuyPumpkin.Enabled then
                    startAutoBuy('pumpkin', buyPumpkin, PumpkinAmount, PumpkinBuyDelay)
                end
            else
                buyRunning.carrot = false
                buyRunning.melon = false
                buyRunning.pumpkin = false
                Folder:ClearAllChildren()
                table.clear(Reference)
                table.clear(spawnQueue)
                lastNotification = 0
            end
        end,
        Tooltip = 'Automatically collects crops and buys seeds'
    })
    
    CollectionToggle = FarmerCletus:CreateToggle({
        Name = 'Auto Collect',
        Default = true,
        Tooltip = 'Automatically collect crops',
        Function = function(callback)
            if Animation and Animation.Object then Animation.Object.Visible = callback end
            if RangeSlider and RangeSlider.Object then RangeSlider.Object.Visible = callback end
            
            if callback and FarmerCletus.Enabled then
                task.spawn(function()
                    kitCollection('HarvestableCrop', function(v)
                        if Animation.Enabled then
                            bedwars.GameAnimationUtil:playAnimation(lplr.Character, bedwars.AnimationType.PUNCH)
                            bedwars.ViewmodelController:playAnimation(bedwars.AnimationType.FP_USE_ITEM)
                            bedwars.SoundManager:playSound(bedwars.SoundList.CROP_HARVEST)
                        end
                        bedwars.Client:Get('CropHarvest'):CallServer({
                            position = bedwars.BlockController:getBlockPosition(v.Position)
                        })
                    end, RangeSlider.Value, false)
                end)
            end
        end
    })
    
    Animation = FarmerCletus:CreateToggle({
        Name = 'Animation',
        Default = true,
        Tooltip = 'Play animation and sound when collecting'
    })
    
    RangeSlider = FarmerCletus:CreateSlider({
        Name = 'Range',
        Min = 1,
        Max = 10,
        Default = 10,
        Decimal = 1,
        Suffix = ' studs',
        Tooltip = 'Control distance to collect crops'
    })
    
    ESPToggle = FarmerCletus:CreateToggle({
        Name = 'Crop ESP',
        Default = false,
        Tooltip = 'Shows your crop locations',
        Function = function(callback)
            if ESPNotify and ESPNotify.Object then ESPNotify.Object.Visible = callback end
            if ESPBackground and ESPBackground.Object then ESPBackground.Object.Visible = callback end
            if ESPColor and ESPColor.Object then ESPColor.Object.Visible = callback end
            
            if FarmerCletus.Enabled then
                if callback then
                    setupESP()
                else
                    Folder:ClearAllChildren()
                    table.clear(Reference)
                end
            end
        end
    })
    
    ESPNotify = FarmerCletus:CreateToggle({
        Name = 'Notify',
        Default = false,
        Tooltip = 'Get notifications when crops spawn'
    })
    
    ESPBackground = FarmerCletus:CreateToggle({
        Name = 'Background',
        Default = true,
        Function = function(callback)
            if ESPColor and ESPColor.Object then ESPColor.Object.Visible = callback end
            for _, v in Reference do
                if v and v:FindFirstChild("ImageLabel") then
                    v.ImageLabel.BackgroundTransparency = 1 - (callback and ESPColor.Opacity or 0)
                    if v:FindFirstChild("Blur") then
                        v.Blur.Visible = callback
                    end
                end
            end
        end
    })
    
    ESPColor = FarmerCletus:CreateColorSlider({
        Name = 'Background Color',
        DefaultValue = 0,
        DefaultOpacity = 0.5,
        Function = function(hue, sat, val, opacity)
            for _, v in Reference do
                if v and v:FindFirstChild("ImageLabel") then
                    v.ImageLabel.BackgroundColor3 = Color3.fromHSV(hue, sat, val)
                    v.ImageLabel.BackgroundTransparency = 1 - opacity
                end
            end
        end,
        Darker = true
    })
    
    AutoBuyCarrot = FarmerCletus:CreateToggle({
        Name = 'Auto Buy Carrot',
        Default = false,
        Tooltip = 'Automatically buy carrot seeds',
        Function = function(callback)
            if CarrotAmount and CarrotAmount.Object then CarrotAmount.Object.Visible = callback end
            if CarrotBuyDelay and CarrotBuyDelay.Object then CarrotBuyDelay.Object.Visible = callback end
            
            if FarmerCletus.Enabled then
                if callback then
                    startAutoBuy('carrot', buyCarrot, CarrotAmount, CarrotBuyDelay)
                else
                    buyRunning.carrot = false
                    buyCount.carrot = 0
                end
            end
        end
    })
    
    CarrotAmount = FarmerCletus:CreateSlider({
        Name = 'Carrot Amount',
        Min = 1,
        Max = 50,
        Default = 10,
        Tooltip = 'How many carrot seeds to buy'
    })
    
    CarrotBuyDelay = FarmerCletus:CreateSlider({
        Name = 'Carrot Delay',
        Min = 0.1,
        Max = 2,
        Default = 0.3,
        Decimal = 10,
        Suffix = 's',
        Tooltip = 'Delay between carrot purchases'
    })
    
    AutoBuyMelon = FarmerCletus:CreateToggle({
        Name = 'Auto Buy Melon',
        Default = false,
        Tooltip = 'Automatically buy melon seeds',
        Function = function(callback)
            if MelonAmount and MelonAmount.Object then MelonAmount.Object.Visible = callback end
            if MelonBuyDelay and MelonBuyDelay.Object then MelonBuyDelay.Object.Visible = callback end
            
            if FarmerCletus.Enabled then
                if callback then
                    startAutoBuy('melon', buyMelon, MelonAmount, MelonBuyDelay)
                else
                    buyRunning.melon = false
                    buyCount.melon = 0
                end
            end
        end
    })
    
    MelonAmount = FarmerCletus:CreateSlider({
        Name = 'Melon Amount',
        Min = 1,
        Max = 50,
        Default = 10,
        Tooltip = 'How many melon seeds to buy'
    })
    
    MelonBuyDelay = FarmerCletus:CreateSlider({
        Name = 'Melon Delay',
        Min = 0.1,
        Max = 2,
        Default = 0.3,
        Decimal = 10,
        Suffix = 's',
        Tooltip = 'Delay between melon purchases'
    })
    
    AutoBuyPumpkin = FarmerCletus:CreateToggle({
        Name = 'Auto Buy Pumpkin',
        Default = false,
        Tooltip = 'Automatically buy pumpkin seeds',
        Function = function(callback)
            if PumpkinAmount and PumpkinAmount.Object then PumpkinAmount.Object.Visible = callback end
            if PumpkinBuyDelay and PumpkinBuyDelay.Object then PumpkinBuyDelay.Object.Visible = callback end
            
            if FarmerCletus.Enabled then
                if callback then
                    startAutoBuy('pumpkin', buyPumpkin, PumpkinAmount, PumpkinBuyDelay)
                else
                    buyRunning.pumpkin = false
                    buyCount.pumpkin = 0
                end
            end
        end
    })
    
    PumpkinAmount = FarmerCletus:CreateSlider({
        Name = 'Pumpkin Amount',
        Min = 1,
        Max = 50,
        Default = 10,
        Tooltip = 'How many pumpkin seeds to buy'
    })
    
    PumpkinBuyDelay = FarmerCletus:CreateSlider({
        Name = 'Pumpkin Delay',
        Min = 0.1,
        Max = 2,
        Default = 0.3,
        Decimal = 10,
        Suffix = 's',
        Tooltip = 'Delay between pumpkin purchases'
    })
    
    GUICheck = FarmerCletus:CreateToggle({
        Name = 'GUI Check',
        Default = false,
        Tooltip = 'Only buy when shop GUI is open'
    })
end)

run(function()
    local Taliyah
    local CollectionToggle
    local Animation
    local CollectionDelay
    local DelaySlider
    local RangeSlider
    local ESPToggle
    local ESPNotify
    local ESPBackground
    local ESPColor
    local AutoBuyEgg
    local EggAmount
    local EggBuyDelay
    local AutoUpgrade
    local UpgradeAmount
    local UpgradeDelay
    local AutoSell
    local SellCurrency
    local SellAmount
    local SellDelay
    local GUICheck
	local ESPConnection1, ESPConnection2
    local Folder = Instance.new('Folder')
    Folder.Parent = vape.gui
    local Reference = {}
    local lastNotification = 0
    local spawnQueue = {}
    local notificationCooldown = 1
    local collectionRunning = false
    
    local buyRunning = {
        egg = false,
        upgrade = false,
        sell = false
    }
    
    local buyCount = {
        egg = 0,
        upgrade = 0,
        sell = 0
    }

    local function sendNotification(count)
        notif("Egg ESP", string.format("%d eggs spawned", count), 3)
    end

    local function processSpawnQueue()
        if #spawnQueue > 0 then
            local currentTime = tick()
            if currentTime - lastNotification >= notificationCooldown then
                sendNotification(#spawnQueue)
                lastNotification = currentTime
                spawnQueue = {}
            else
                task.delay(notificationCooldown - (currentTime - lastNotification), function()
                    if #spawnQueue > 0 then
                        sendNotification(#spawnQueue)
                        spawnQueue = {}
                    end
                end)
            end
        end
    end

    local function getProperImage(v)
        return bedwars.getIcon({itemType = 'chicken_egg'}, true)
    end

    local function Added(v)
        if Reference[v] then return end
        
        local billboard = Instance.new('BillboardGui')
        billboard.Parent = Folder
        billboard.Name = 'egg'
        billboard.StudsOffsetWorldSpace = Vector3.new(0, 3, 0)
        billboard.Size = UDim2.fromOffset(36, 36)
        billboard.AlwaysOnTop = true
        billboard.ClipsDescendants = false
        billboard.Adornee = v
        
        local blur = addBlur(billboard)
        blur.Visible = ESPBackground.Enabled
        
        local image = Instance.new('ImageLabel')
        image.Size = UDim2.fromOffset(36, 36)
        image.Position = UDim2.fromScale(0.5, 0.5)
        image.AnchorPoint = Vector2.new(0.5, 0.5)
        image.BackgroundColor3 = Color3.fromHSV(ESPColor.Hue, ESPColor.Sat, ESPColor.Value)
        image.BackgroundTransparency = 1 - (ESPBackground.Enabled and ESPColor.Opacity or 0)
        image.BorderSizePixel = 0
        image.Image = getProperImage(v)
        image.Parent = billboard
        
        local uicorner = Instance.new('UICorner')
        uicorner.CornerRadius = UDim.new(0, 4)
        uicorner.Parent = image
        
        Reference[v] = billboard
        
        if ESPNotify.Enabled then
            table.insert(spawnQueue, {item = 'egg', time = tick()})
            processSpawnQueue()
        end
    end

    local function Removed(v)
        if Reference[v] then
            Reference[v]:Destroy()
            Reference[v] = nil
        end
    end
    
    local function setupESP()
        if ESPConnection1 then
            ESPConnection1:Disconnect()
            ESPConnection1 = nil
        end
        if ESPConnection2 then
            ESPConnection2:Disconnect()
            ESPConnection2 = nil
        end
        
        Folder:ClearAllChildren()
        table.clear(Reference)
        
        task.spawn(function()
            for _, obj in pairs(workspace:GetDescendants()) do
                if obj:IsA("Model") and obj.Name == "EggEntity" then
                    if obj:GetAttribute("PlacedByUserId") then
                        Added(obj)
                    end
                end
            end
        end)
        
        ESPConnection1 = workspace.DescendantAdded:Connect(function(obj)
            if obj:IsA("Model") and obj.Name == "EggEntity" then
                task.wait(0.1)
                if obj:GetAttribute("PlacedByUserId") then
                    Added(obj)
                end
            end
        end)
        
        ESPConnection2 = workspace.DescendantRemoving:Connect(function(obj)
            if obj:IsA("Model") and obj.Name == "EggEntity" and Reference[obj] then
                Removed(obj)
            end
        end)
    end

    local function cleanupESP()
        if ESPConnection1 then
            ESPConnection1:Disconnect()
            ESPConnection1 = nil
        end
        if ESPConnection2 then
            ESPConnection2:Disconnect()
            ESPConnection2 = nil
        end
        
        Folder:ClearAllChildren()
        table.clear(Reference)
        table.clear(spawnQueue)
        lastNotification = 0
    end
	
    local function startCollection()
        collectionRunning = true
        task.spawn(function()
            while collectionRunning and Taliyah.Enabled and CollectionToggle.Enabled do
                if not entitylib.isAlive then 
                    task.wait(0.1) 
                    continue 
                end
                
                local localPosition = entitylib.character.RootPart.Position
                local range = RangeSlider.Value
                local eggsFound = false
                
                for _, v in collectionService:GetTagged('HarvestableCrop') do
                    if not collectionRunning or not Taliyah.Enabled or not CollectionToggle.Enabled then 
                        break 
                    end
                    
                    if v.Name == "chicken_egg_block" then
                        local distance = (localPosition - v.Position).Magnitude
                        
                        if distance <= range then
                            eggsFound = true
                            
                            if CollectionDelay.Enabled and DelaySlider.Value > 0 then
                                task.wait(DelaySlider.Value)
                            end
                            
                            local prompt = v:FindFirstChildOfClass("ProximityPrompt")
                            if prompt and prompt.Enabled then
                                if fireproximityprompt then
                                    fireproximityprompt(prompt)
                                else
                                    prompt:InputHoldBegin()
                                    task.wait(0.1)
                                    prompt:InputHoldEnd()
                                end
                                task.wait(0.1)
                            end
                        end
                    end
                end
                
                if not eggsFound then
                    task.wait(0.2)
                else
                    task.wait(0.1)
                end
            end
            collectionRunning = false
        end)
    end
    
    local function getShopNPC()
        local shopFound = false
        if entitylib.isAlive then
            local localPosition = entitylib.character.RootPart.Position
            for _, v in store.shop do
                if (v.RootPart.Position - localPosition).Magnitude <= 20 then
                    shopFound = true
                    break
                end
            end
        end
        return shopFound
    end
    
    local function getCurrentChickenPrice()
        local price = workspace:GetAttribute("ChickenPrice") or 35
        local currency = workspace:GetAttribute("ChickenCurrency") or "iron"
        return price, currency
    end
    
    local function getChickenSellInfo()
        local sellPrice = workspace:GetAttribute("ChickenPrice") or 1
        local sellCurrency = workspace:GetAttribute("ChickenCurrency") or "emerald"
        return sellPrice, sellCurrency
    end
    
    local function sellChicken()
        pcall(function()
            local sellPrice, sellCurrency = getChickenSellInfo()
            
            if not sellPrice or not sellCurrency then
                return
            end
            
            local selectedCurrency = SellCurrency.Value:lower()
            
            if selectedCurrency ~= sellCurrency then
                return
            end
            
            local args = {
                {
                    shopItem = {
                        itemType = "chicken_shop_item",
                        dontGiveItem = true,
                        price = 1,
                        customDisplayName = "Sell chicken for "..tostring(sellPrice).." "..sellCurrency,
                        currency = "chicken_deploy",
                        amount = 1,
                        sell = true,
                        requiresKit = {
                            "taliyah"
                        },
                        category = "Combat"
                    },
                    shopId = "1_item_shop"
                }
            }
            game:GetService("ReplicatedStorage")
                :WaitForChild("rbxts_include")
                :WaitForChild("node_modules")
                :WaitForChild("@rbxts")
                :WaitForChild("net")
                :WaitForChild("out")
                :WaitForChild("_NetManaged")
                :WaitForChild("BedwarsPurchaseItem")
                :InvokeServer(unpack(args))
        end)
    end
    
    local function upgradeNest()
        pcall(function()
            local args = {
                {
                    shopItem = {
                        itemType = "diamond_chicken_nest",
                        dontGiveItem = true,
                        price = 2,
                        prevTier = "iron_chicken_nest",
                        customDisplayName = "Diamond Nest",
                        currency = "emerald",
                        amount = 1,
                        tiered = true,
                        requiresKit = {
                            "taliyah"
                        },
                        nextTier = "emerald_chicken_nest",
                        category = "Combat"
                    },
                    shopId = "1_item_shop"
                }
            }
            game:GetService("ReplicatedStorage")
                :WaitForChild("rbxts_include")
                :WaitForChild("node_modules")
                :WaitForChild("@rbxts")
                :WaitForChild("net")
                :WaitForChild("out")
                :WaitForChild("_NetManaged")
                :WaitForChild("BedwarsPurchaseItem")
                :InvokeServer(unpack(args))
        end)
    end
    
    local function sellChicken()
        pcall(function()
            local sellPrice, sellCurrency = getChickenSellInfo()
            
            if not sellPrice or not sellCurrency then
                return
            end
            
            local selectedCurrency = SellCurrency.Value:lower()
            
            if selectedCurrency ~= sellCurrency then
                return
            end
            
            local args = {
                {
                    shopItem = {
                        itemType = "chicken_shop_item",
                        dontGiveItem = true,
                        price = 1,
                        customDisplayName = "Sell chicken for "..tostring(sellPrice).." "..sellCurrency,
                        currency = "chicken_deploy",
                        amount = 1,
                        sell = true,
                        requiresKit = {
                            "taliyah"
                        },
                        category = "Combat"
                    },
                    shopId = "1_item_shop"
                }
            }
            game:GetService("ReplicatedStorage")
                :WaitForChild("rbxts_include")
                :WaitForChild("node_modules")
                :WaitForChild("@rbxts")
                :WaitForChild("net")
                :WaitForChild("out")
                :WaitForChild("_NetManaged")
                :WaitForChild("BedwarsPurchaseItem")
                :InvokeServer(unpack(args))
        end)
    end

    local function buyEgg()
        pcall(function()
            local price, currency = getCurrentChickenPrice()
            local args = {
                {
                    shopItem = {
                        currency = currency,
                        itemType = "chicken_egg",
                        amount = 1,
                        price = price,
                        requiresKit = {
                            "taliyah"
                        },
                        customDisplayName = "Egg",
                        category = "Combat"
                    },
                    shopId = "1_item_shop"
                }
            }
            game:GetService("ReplicatedStorage")
                :WaitForChild("rbxts_include")
                :WaitForChild("node_modules")
                :WaitForChild("@rbxts")
                :WaitForChild("net")
                :WaitForChild("out")
                :WaitForChild("_NetManaged")
                :WaitForChild("BedwarsPurchaseItem")
                :InvokeServer(unpack(args))
        end)
    end
    
    local function startAutoBuy(buyType, buyFunc, amountSlider, delaySlider)
        buyRunning[buyType] = true
        buyCount[buyType] = 0
        
        task.spawn(function()
            while buyRunning[buyType] do
                if buyCount[buyType] >= amountSlider.Value then
                    buyRunning[buyType] = false
                    break
                end
                
                local canBuy = true
                
                if GUICheck.Enabled then
                    if bedwars.AppController:isAppOpen('BedwarsItemShopApp') then
                        canBuy = true
                    else
                        canBuy = false
                    end
                else
                    canBuy = getShopNPC()
                end
                
                if canBuy then
                    buyFunc()
                    buyCount[buyType] = buyCount[buyType] + 1
                end
                
                task.wait(delaySlider.Value)
            end
        end)
    end

    Taliyah = vape.Categories.Kits:CreateModule({
        Name = 'AutoTaliyah',
        Function = function(callback)
            if callback then
                if ESPToggle.Enabled then 
                    setupESP() 
                end
                
                if CollectionToggle.Enabled then
                    startCollection()
                end
                
                if AutoBuyEgg.Enabled then
                    startAutoBuy('egg', buyEgg, EggAmount, EggBuyDelay)
                end
                if AutoUpgrade.Enabled then
                    startAutoBuy('upgrade', upgradeNest, UpgradeAmount, UpgradeDelay)
                end
                if AutoSell.Enabled then
                    startAutoBuy('sell', sellChicken, SellAmount, SellDelay)
                end
            else
                collectionRunning = false
                buyRunning.egg = false
                buyRunning.upgrade = false
                buyRunning.sell = false
                cleanupESP() 
            end
        end,
        Tooltip = 'Automatically collects eggs and manages chickens'
    })
    
    CollectionToggle = Taliyah:CreateToggle({
        Name = 'Auto Collect',
        Default = true,
        Tooltip = 'Automatically collect eggs',
        Function = function(callback)
            if CollectionDelay and CollectionDelay.Object then CollectionDelay.Object.Visible = callback end
            if DelaySlider and DelaySlider.Object then DelaySlider.Object.Visible = (callback and CollectionDelay.Enabled) end
            if RangeSlider and RangeSlider.Object then RangeSlider.Object.Visible = callback end
            
            if callback and Taliyah.Enabled then
                startCollection()
            else
                collectionRunning = false
            end
        end
    })
    
    CollectionDelay = Taliyah:CreateToggle({
        Name = 'Collection Delay',
        Default = false,
        Tooltip = 'Add delay before collecting eggs',
        Visible = false,
        Function = function(callback)
            if DelaySlider and DelaySlider.Object then
                DelaySlider.Object.Visible = callback
            end
        end
    })
    
    DelaySlider = Taliyah:CreateSlider({
        Name = 'Delay',
        Min = 0,
        Max = 2,
        Default = 0.5,
        Decimal = 10,
        Suffix = 's',
        Tooltip = 'Delay in seconds before collecting',
        Visible = false
    })
    
    RangeSlider = Taliyah:CreateSlider({
        Name = 'Range',
        Min = 1, 
        Max = 30,
        Default = 10,
        Decimal = 1,
        Suffix = ' studs',
        Tooltip = 'Control distance to collect eggs',
        Visible = false
    })
    
    ESPToggle = Taliyah:CreateToggle({
        Name = 'Egg ESP',
        Default = false,
        Tooltip = 'Shows your egg locations',
        Function = function(callback)
            if ESPNotify and ESPNotify.Object then ESPNotify.Object.Visible = callback end
            if ESPBackground and ESPBackground.Object then ESPBackground.Object.Visible = callback end
            if ESPColor and ESPColor.Object then ESPColor.Object.Visible = callback end
            
            if Taliyah.Enabled then
                if callback then 
                    setupESP() 
                else
                    cleanupESP()
                end
            end
        end
    })
    
    ESPNotify = Taliyah:CreateToggle({
        Name = 'Notify',
        Default = false,
        Tooltip = 'Get notifications when eggs spawn',
        Visible = false
    })
    
    ESPBackground = Taliyah:CreateToggle({
        Name = 'Background',
        Default = true,
        Visible = false,
        Function = function(callback)
            if ESPColor and ESPColor.Object then ESPColor.Object.Visible = callback end
            for _, v in Reference do
                if v and v:FindFirstChild("ImageLabel") then
                    v.ImageLabel.BackgroundTransparency = 1 - (callback and ESPColor.Opacity or 0)
                    if v:FindFirstChild("Blur") then
                        v.Blur.Visible = callback
                    end
                end
            end
        end
    })
    
    ESPColor = Taliyah:CreateColorSlider({
        Name = 'Background Color',
        DefaultValue = 0,
        DefaultOpacity = 0.5,
        Visible = false,
        Function = function(hue, sat, val, opacity)
            for _, v in Reference do
                if v and v:FindFirstChild("ImageLabel") then
                    v.ImageLabel.BackgroundColor3 = Color3.fromHSV(hue, sat, val)
                    v.ImageLabel.BackgroundTransparency = 1 - opacity
                end
            end
        end,
        Darker = true
    })
    
    AutoBuyEgg = Taliyah:CreateToggle({
        Name = 'Auto Buy Egg',
        Default = false,
        Tooltip = 'Automatically buy chicken eggs',
        Function = function(callback)
            if EggAmount and EggAmount.Object then EggAmount.Object.Visible = callback end
            if EggBuyDelay and EggBuyDelay.Object then EggBuyDelay.Object.Visible = callback end
            
            if Taliyah.Enabled then
                if callback then
                    startAutoBuy('egg', buyEgg, EggAmount, EggBuyDelay)
                else
                    buyRunning.egg = false
                    buyCount.egg = 0
                end
            end
        end
    })
    
    EggAmount = Taliyah:CreateSlider({
        Name = 'Egg Amount',
        Min = 1,
        Max = 50,
        Default = 10,
        Tooltip = 'How many eggs to buy',
        Visible = false
    })
    
    EggBuyDelay = Taliyah:CreateSlider({
        Name = 'Egg Delay',
        Min = 0.1,
        Max = 2,
        Default = 0.3,
        Decimal = 10,
        Suffix = 's',
        Tooltip = 'Delay between egg purchases',
        Visible = false
    })
    
    AutoUpgrade = Taliyah:CreateToggle({
        Name = 'Auto Upgrade',
        Default = false,
        Tooltip = 'Automatically upgrade chicken nest',
        Function = function(callback)
            if UpgradeAmount and UpgradeAmount.Object then UpgradeAmount.Object.Visible = callback end
            if UpgradeDelay and UpgradeDelay.Object then UpgradeDelay.Object.Visible = callback end
            
            if Taliyah.Enabled then
                if callback then
                    startAutoBuy('upgrade', upgradeNest, UpgradeAmount, UpgradeDelay)
                else
                    buyRunning.upgrade = false
                    buyCount.upgrade = 0
                end
            end
        end
    })
    
    UpgradeAmount = Taliyah:CreateSlider({
        Name = 'Upgrade Amount',
        Min = 1,
        Max = 4,
        Default = 3,
        Tooltip = 'How many upgrades to purchase',
        Visible = false
    })
    
    UpgradeDelay = Taliyah:CreateSlider({
        Name = 'Upgrade Delay',
        Min = 0.1,
        Max = 2,
        Default = 0.5,
        Decimal = 10,
        Suffix = 's',
        Tooltip = 'Delay between upgrades',
        Visible = false
    })
    
    AutoSell = Taliyah:CreateToggle({
        Name = 'Auto Sell',
        Default = false,
        Tooltip = 'Automatically sell chickens for selected currency',
        Function = function(callback)
            if SellCurrency and SellCurrency.Object then SellCurrency.Object.Visible = callback end
            if SellAmount and SellAmount.Object then SellAmount.Object.Visible = callback end
            if SellDelay and SellDelay.Object then SellDelay.Object.Visible = callback end
            
            if Taliyah.Enabled then
                if callback then
                    startAutoBuy('sell', sellChicken, SellAmount, SellDelay)
                else
                    buyRunning.sell = false
                    buyCount.sell = 0
                end
            end
        end
    })
    
    SellCurrency = Taliyah:CreateDropdown({
        Name = 'Sell Currency',
        List = {'Emerald', 'Iron'},
        Default = 'Emerald',
        Tooltip = 'Only sell when chicken is selling for this currency',
        Visible = false
    })
    
    SellAmount = Taliyah:CreateSlider({
        Name = 'Sell Amount',
        Min = 1,
        Max = 50,
        Default = 10,
        Tooltip = 'How many chickens to sell',
        Visible = false
    })
    
    SellDelay = Taliyah:CreateSlider({
        Name = 'Sell Delay',
        Min = 0.1,
        Max = 2,
        Default = 0.3,
        Decimal = 10,
        Suffix = 's',
        Tooltip = 'Delay between selling chickens',
        Visible = false
    })
    
    GUICheck = Taliyah:CreateToggle({
        Name = 'GUI Check',
        Default = false,
        Tooltip = 'Only buy/sell/upgrade when shop GUI is open'
    })
end)

run(function()
    local Lian
    local AutoAbility
    local AutoUlt
    local RangeSlider
    local DelaySlider
    local UltEnemyCount
    local UltRange
    local MinSwordCount
    local UltCooldown
    
    Lian = vape.Categories.Kits:CreateModule({
        Name = 'AutoLian',
        Function = function(callback)
            if callback then
                task.spawn(function()
                    repeat
                        if entitylib.isAlive then
                            local swordCount = lplr:GetAttribute('SwordCount') or 0
                            
                            if swordCount >= MinSwordCount.Value then
                                if AutoUlt.Enabled and swordCount >= 3 then
                                    local nearbyEnemies = 0
                                    local localPos = entitylib.character.RootPart.Position
                                    
                                    for _, v in entitylib.List do
                                        if v.Targetable and (v.RootPart.Position - localPos).Magnitude <= UltRange.Value then
                                            nearbyEnemies = nearbyEnemies + 1
                                        end
                                    end
                                    
                                    if nearbyEnemies >= UltEnemyCount.Value then
                                        pcall(function()
                                            game:GetService("ReplicatedStorage")
                                                :WaitForChild("events-@easy-games/game-core:shared/game-core-networking@getEvents.Events")
                                                :WaitForChild("useAbility")
                                                :FireServer("DRAGON_SWORD_ULT")
                                        end)
                                        task.wait(UltCooldown.Value)
                                    end
                                end
                                
                                if AutoAbility.Enabled and swordCount > 0 then
                                    local plr = entitylib.EntityPosition({
                                        Range = RangeSlider.Value,
                                        Part = 'RootPart',
                                        Players = true,
                                        NPCs = true,
                                        Sort = sortmethods.Health
                                    })
                                    
                                    if plr and bedwars.AbilityController:canUseAbility('dragon_sword') then
                                        bedwars.AbilityController:useAbility('dragon_sword')
                                        task.wait(0.5)
                                    end
                                end
                            end
                        end
                        
                        task.wait(DelaySlider.Value)
                    until not Lian.Enabled
                end)
            end
        end,
        Tooltip = 'Auto use Dragon Sword abilities'
    })
    
    AutoAbility = Lian:CreateToggle({
        Name = 'Auto Ability',
        Default = true,
        Tooltip = 'Auto use dragon sword on nearest enemy'
    })
    
    AutoUlt = Lian:CreateToggle({
        Name = 'Auto Ultimate',
        Default = true,
        Tooltip = 'Auto use ult when conditions met'
    })
    
    RangeSlider = Lian:CreateSlider({
        Name = 'Ability Range',
        Min = 10,
        Max = 50,
        Default = 30,
        Suffix = ' studs',
        Tooltip = 'Range to use dragon sword ability'
    })
    
    DelaySlider = Lian:CreateSlider({
        Name = 'Delay',
        Min = 0.1,
        Max = 1,
        Default = 0.1,
        Decimal = 10,
        Suffix = 's'
    })
    
    UltEnemyCount = Lian:CreateSlider({
        Name = 'Ult Enemy Count',
        Min = 1,
        Max = 5,
        Default = 2,
        Tooltip = 'Enemies nearby needed to ult'
    })
    
    UltRange = Lian:CreateSlider({
        Name = 'Ult Range',
        Min = 10,
        Max = 50,
        Default = 30,
        Suffix = ' studs',
        Tooltip = 'Range to check for enemies before ulting'
    })
    
    MinSwordCount = Lian:CreateSlider({
        Name = 'Min Sword Count',
        Min = 1,
        Max = 3,
        Default = 1,
        Tooltip = 'Minimum swords before using abilities'
    })
    
    UltCooldown = Lian:CreateSlider({
        Name = 'Ult Cooldown',
        Min = 1,
        Max = 5,
        Default = 2,
        Suffix = 's',
        Tooltip = 'Wait time after using ult'
    })
end)

run(function()
    local Miner
    local CollectionToggle
    local DelaySlider
    local RangeSlider
    local ESPToggle
    local ESPBackground
    local ESPColor = {}
    local Folder = Instance.new('Folder')
    Folder.Parent = vape.gui
    local minerCache = {}
    local collectedPetrified = {}
    
    local function isOnMyTeam(petrifiedModel)
        if not petrifiedModel then return false end
        local myTeam = lplr:GetAttribute('Team')
        local theirTeam = petrifiedModel:GetAttribute('Team')
        
        if not theirTeam or not myTeam then return true end
        
        return theirTeam == myTeam
    end
    
    local function collectPetrified(v)
        local petrifyId = v:GetAttribute('PetrifyId')
        
        if not petrifyId or collectedPetrified[petrifyId] then return end
        if isOnMyTeam(v) then return end
        
        collectedPetrified[petrifyId] = true
        
        local animTrack
        pcall(function()
            animTrack = bedwars.GameAnimationUtil:playAnimation(lplr, bedwars.AnimationType.MINER_MINE_STONE)
        end)
        
        task.wait(DelaySlider.Value)
        
        if animTrack then
            pcall(function()
                animTrack:Stop()
                animTrack:Destroy()
            end)
        end
        
        pcall(function()
            bedwars.Client:Get(remotes.MinerDig):SendToServer({
                petrifyId = petrifyId
            })
        end)
        
        task.delay(2, function() collectedPetrified[petrifyId] = nil end)
    end
    
    local function Added(v, petrifiedModel)
        if isOnMyTeam(petrifiedModel) then return end
        if minerCache[petrifiedModel] then return end
        
        local billboard = Instance.new('BillboardGui')
        billboard.Parent = Folder
        billboard.Name = 'petrified-player'
        billboard.StudsOffsetWorldSpace = Vector3.new(0, 6, 0)
        billboard.Size = UDim2.fromOffset(100, 40)
        billboard.AlwaysOnTop = true
        billboard.ClipsDescendants = false
        billboard.Adornee = v
        
        local blur = addBlur(billboard)
        blur.Visible = ESPBackground.Enabled
        
        local frame = Instance.new('Frame')
        frame.Size = UDim2.fromScale(1, 1)
        frame.BackgroundColor3 = Color3.fromHSV(ESPColor.Hue, ESPColor.Sat, ESPColor.Value)
        frame.BackgroundTransparency = 1 - (ESPBackground.Enabled and ESPColor.Opacity or 0)
        frame.BorderSizePixel = 0
        frame.Parent = billboard
        
        local uicorner = Instance.new('UICorner')
        uicorner.CornerRadius = UDim.new(0, 4)
        uicorner.Parent = frame
        
        local text = Instance.new('TextLabel')
        text.Size = UDim2.fromScale(1, 1)
        text.Position = UDim2.fromScale(0.5, 0.5)
        text.AnchorPoint = Vector2.new(0.5, 0.5)
        text.BackgroundTransparency = 1
        text.Text = "Petrified: " .. petrifiedModel.Name
        text.TextColor3 = Color3.new(1, 1, 1)
        text.TextScaled = true
        text.Font = Enum.Font.GothamBold
        text.Parent = frame
        
        minerCache[petrifiedModel] = billboard
    end
    
    local function Removed(petrifiedModel)
        if minerCache[petrifiedModel] then
            minerCache[petrifiedModel]:Destroy()
            minerCache[petrifiedModel] = nil
        end
    end
    
    local function setupESP()
        for _, model in pairs(collectionService:GetTagged('petrified-player')) do
            if model.PrimaryPart then
                Added(model.PrimaryPart, model)
            end
        end
        
        Miner:Clean(collectionService:GetInstanceAddedSignal('petrified-player'):Connect(function(model)
            if model.PrimaryPart then
                Added(model.PrimaryPart, model)
            end
        end))
        
        Miner:Clean(collectionService:GetInstanceRemovedSignal('petrified-player'):Connect(function(model)
            Removed(model)
        end))
    end
    
    Miner = vape.Categories.Kits:CreateModule({
        Name = 'AutoMiner',
        Function = function(callback)
            if callback then
                task.spawn(function()
                    repeat
                        if entitylib.isAlive and CollectionToggle.Enabled then
                            for _, model in pairs(collectionService:GetTagged('petrified-player')) do
                                if model:IsA("Model") and model.PrimaryPart then
                                    if (entitylib.character.RootPart.Position - model.PrimaryPart.Position).Magnitude <= RangeSlider.Value then
                                        collectPetrified(model)
                                    end
                                end
                            end
                        end
                        task.wait(0.3)
                    until not Miner.Enabled
                end)
                
                if ESPToggle.Enabled then
                    setupESP()
                end
            else
                Folder:ClearAllChildren()
                table.clear(minerCache)
                table.clear(collectedPetrified)
            end
        end,
        Tooltip = 'Auto-collect petrified players with ESP'
    })
    
    CollectionToggle = Miner:CreateToggle({
        Name = 'Auto Collect',
        Default = true,
        Function = function(callback)
            if DelaySlider and DelaySlider.Object then DelaySlider.Object.Visible = callback end
            if RangeSlider and RangeSlider.Object then RangeSlider.Object.Visible = callback end
        end
    })
    
    DelaySlider = Miner:CreateSlider({
        Name = 'Delay',
        Min = 0, Max = 10, Default = 4, Suffix = ' seconds',
        Tooltip = 'Animation plays for this duration before collecting',
        Visible = false
    })
    
    RangeSlider = Miner:CreateSlider({
        Name = 'Range',
        Min = 1, Max = 30, Default = 12, Suffix = ' studs',
        Visible = false
    })
    
    ESPToggle = Miner:CreateToggle({
        Name = 'Petrified ESP',
        Default = false,
        Tooltip = 'Shows petrified player locations',
        Function = function(callback)
            if ESPBackground and ESPBackground.Object then ESPBackground.Object.Visible = callback end
            if ESPColor and ESPColor.Object then ESPColor.Object.Visible = (callback and ESPBackground.Enabled) end
            
            if Miner.Enabled then
                if callback then 
                    setupESP() 
                else
                    Folder:ClearAllChildren()
                    table.clear(minerCache)
                end
            end
        end
    })
    
    ESPBackground = Miner:CreateToggle({
        Name = 'Background',
        Default = true,
        Visible = false,
        Function = function(callback)
            if ESPColor and ESPColor.Object then ESPColor.Object.Visible = callback end
            for _, v in minerCache do
                if v and v:FindFirstChild("Frame") then
                    local blur = v:FindFirstChild("BlurEffect")
                    if blur then blur.Visible = callback end
                    v.Frame.BackgroundTransparency = 1 - (callback and ESPColor.Opacity or 0)
                end
            end
        end
    })
    
    ESPColor = Miner:CreateColorSlider({
        Name = 'Background Color',
        DefaultValue = 0,
        DefaultOpacity = 0.5,
        Visible = false,
        Function = function(hue, sat, val, opacity)
            for _, v in minerCache do
                if v and v:FindFirstChild("Frame") then
                    v.Frame.BackgroundColor3 = Color3.fromHSV(hue, sat, val)
                    v.Frame.BackgroundTransparency = 1 - opacity
                end
            end
        end,
        Darker = true
    })
end)

run(function()
    local Nazar
    local AutoEmpower
    local EmpowerTimeout
    local AutoConsume
    local HealThreshold
    local MinLifeForce
    local ConsumeDelay
    
    local empoweredMode = false
    local lastHitTime = 0
    local lastConsumeTime = 0
    
    local function enableEmpower()
        if not empoweredMode and bedwars.AbilityController:canUseAbility('enable_life_force_attack') then
            bedwars.AbilityController:useAbility('enable_life_force_attack')
            empoweredMode = true
        end
    end
    
    local function disableEmpower()
        if empoweredMode and bedwars.AbilityController:canUseAbility('disable_life_force_attack') then
            bedwars.AbilityController:useAbility('disable_life_force_attack')
            empoweredMode = false
        end
    end
    
    local function tryConsumeLifeForce()
        if not entitylib.isAlive then return end
        
        local currentTime = workspace:GetServerTimeNow()
        
        if (currentTime - lastConsumeTime) < ConsumeDelay.Value then
            return
        end
        
        local health = lplr.Character:GetAttribute('Health') or 100
        local maxHealth = lplr.Character:GetAttribute('MaxHealth') or 100
        local lifeForce = lplr:GetAttribute('LifeForce') or 0
        
        local healthPercent = health / maxHealth
        
        if healthPercent < (HealThreshold.Value / 100) and lifeForce >= MinLifeForce.Value and health < maxHealth then
            if bedwars.AbilityController:canUseAbility('consume_life_foce') then
                bedwars.AbilityController:useAbility('consume_life_foce')
                lastConsumeTime = currentTime
            end
        end
    end
    
    Nazar = vape.Categories.Kits:CreateModule({
        Name = 'AutoNazar',
        Function = function(callback)
            if callback then
                Nazar:Clean(vapeEvents.EntityDamageEvent.Event:Connect(function(damageTable)
                    if not entitylib.isAlive or not AutoEmpower.Enabled then return end
                    
                    local attacker = playersService:GetPlayerFromCharacter(damageTable.fromEntity)
                    local victim = playersService:GetPlayerFromCharacter(damageTable.entityInstance)
                    
                    if attacker == lplr and victim and victim ~= lplr then
                        lastHitTime = workspace:GetServerTimeNow()
                        enableEmpower()
                    end
                end))
                
                Nazar:Clean(vapeEvents.EntityDeathEvent.Event:Connect(function(deathTable)
                    if not entitylib.isAlive or not AutoEmpower.Enabled then return end
                    
                    local killer = playersService:GetPlayerFromCharacter(deathTable.fromEntity)
                    local killed = playersService:GetPlayerFromCharacter(deathTable.entityInstance)
                    
                    if killer == lplr and killed and killed ~= lplr then
                        disableEmpower()
                    end
                end))
                
                task.spawn(function()
                    repeat
                        if entitylib.isAlive then
                            local currentTime = workspace:GetServerTimeNow()
                            
                            if AutoEmpower.Enabled and empoweredMode and (currentTime - lastHitTime) >= EmpowerTimeout.Value then
                                disableEmpower()
                            end
                            
                            if AutoConsume.Enabled then
                                tryConsumeLifeForce()
                            end
                        else
                            if empoweredMode then
                                disableEmpower()
                            end
                        end
                        
                        task.wait(0.1)
                    until not Nazar.Enabled
                end)
            else
                if empoweredMode then
                    disableEmpower()
                end
                empoweredMode = false
                lastHitTime = 0
                lastConsumeTime = 0
            end
        end,
        Tooltip = 'Automatically manages Nazar abilities'
    })
    
    AutoEmpower = Nazar:CreateToggle({
        Name = 'Auto Empower',
        Default = true,
        Tooltip = 'Auto enable/disable empowered attacks on hit/kill',
        Function = function(callback)
            if EmpowerTimeout and EmpowerTimeout.Object then 
                EmpowerTimeout.Object.Visible = callback 
            end
        end
    })
    
    EmpowerTimeout = Nazar:CreateSlider({
        Name = 'Empower Timeout',
        Min = 1,
        Max = 10,
        Default = 3,
        Suffix = 's',
        Tooltip = 'Disable empower after this many seconds without hitting',
        Visible = false
    })
    
    AutoConsume = Nazar:CreateToggle({
        Name = 'Auto Consume',
        Default = true,
        Tooltip = 'Auto consume life force to heal when low HP',
        Function = function(callback)
            if HealThreshold and HealThreshold.Object then 
                HealThreshold.Object.Visible = callback 
            end
            if MinLifeForce and MinLifeForce.Object then 
                MinLifeForce.Object.Visible = callback 
            end
            if ConsumeDelay and ConsumeDelay.Object then 
                ConsumeDelay.Object.Visible = callback 
            end
        end
    })
    
    HealThreshold = Nazar:CreateSlider({
        Name = 'Heal Threshold',
        Min = 10,
        Max = 100,
        Default = 55,
        Suffix = '%',
        Tooltip = 'Consume life force when HP is below this %',
        Visible = false
    })
    
    MinLifeForce = Nazar:CreateSlider({
        Name = 'Min Life Force',
        Min = 1,
        Max = 100,
        Default = 25,
        Tooltip = 'Minimum life force required to heal',
        Visible = false
    })
    
    ConsumeDelay = Nazar:CreateSlider({
        Name = 'Consume Cooldown',
        Min = 0,
        Max = 10,
        Default = 3,
        Suffix = 's',
        Tooltip = 'Cooldown between consuming life force',
        Visible = false
    })
end)

run(function()
	local ServerSync
	local NetworkClient = cloneref(game:GetService("NetworkClient"))
	local NetworkSettings = settings():GetService("NetworkSettings")
	
	task.spawn(function()
		if not game:IsLoaded() then
			game.Loaded:Wait()
		end
		task.wait(1)
	end)
	
	local defaultLag = NetworkSettings.IncomingReplicationLag
	
	local function apply()
		pcall(function()
			NetworkSettings.IncomingReplicationLag = 0
		end)
		pcall(function()
			NetworkClient:SetOutgoingKBPSLimit(0)
		end)
	end
	
	local function restore()
		pcall(function()
			NetworkSettings.IncomingReplicationLag = defaultLag
		end)
	end
	
	ServerSync = vape.Categories.Legit:CreateModule({
		Name = "ServerSync",
		Function = function(callback)
			if callback then
				apply()
			else
				restore()
			end
		end,
		Tooltip = "Syncs your client to the server as fast as possible"
	})
end)

run(function()
	local KillFeedRemover
	
	local function SetFeed(enabled)
		local suc, res = pcall(function()
			lplr.PlayerGui.KillFeedGui.Enabled = enabled
		end)
		if not suc then
			repeat task.wait() until lplr.PlayerGui:FindFirstChild("KillFeedGui")
			lplr.PlayerGui.KillFeedGui.Enabled = enabled
		end
	end
	
	KillFeedRemover = vape.Categories.BoostFPS:CreateModule({
		Name = "KillFeedRemover",
		Function = function(callback)
			if callback then
				SetFeed(false)
			else
				SetFeed(true)
			end
		end,
		Tooltip = "Removes the kill feed interface"
	})
end)

run(function()
    local GodMode = {Enabled = false}
    local Range = 16
    local LowHPOnly = false
    local HPThreshold = 50
    local Delay = 1
    
    local lastDodgeTime = 0

    GodMode = vape.Categories.Blatant:CreateModule({
        Name = "GodMode",
        Function = function(call) 
            if call then
                GodMode:Clean(workspace.DescendantAdded:Connect(function(arrow)
                    if not GodMode.Enabled then return end
                    if not entitylib.isAlive then return end

                    if (arrow.Name == "crossbow_arrow" or arrow.Name == "arrow" or arrow.Name == "headhunter_arrow") and arrow:IsA("Model") then
                        if arrow:GetAttribute("ProjectileShooter") == lplr.UserId then return end

                        local root = arrow:FindFirstChildWhichIsA("BasePart")
                        if not root then return end

                        task.spawn(function()
                            while GodMode.Enabled and root and root.Parent and entitylib.isAlive do
                                local char = lplr.Character
                                local hrp = char and char:FindFirstChild("HumanoidRootPart")
                                if not hrp then break end

                                local dist = (hrp.Position - root.Position).Magnitude
                                if dist <= Range.Value then
                                    local currentTime = tick()
                                    if (currentTime - lastDodgeTime) >= Delay.Value then
                                        local orgPos = hrp.Position
                                        
                                        hrp.CFrame = CFrame.new(orgPos + Vector3.new(0, -230, 0))
                                        task.wait(0.2)
                                        
                                        if GodMode.Enabled and lplr.Character and lplr.Character:FindFirstChild("HumanoidRootPart") then
                                            lplr.Character.HumanoidRootPart.CFrame = CFrame.new(orgPos)
                                        end
                                        
                                        lastDodgeTime = tick()
                                        break
                                    end
                                end

                                task.wait(0.05)
                            end
                        end)
                    end
                end))
                
                task.spawn(function()
                    while GodMode.Enabled do
                        local root = lplr.Character and lplr.Character:FindFirstChild("HumanoidRootPart")
                        local humanoid = lplr.Character and lplr.Character:FindFirstChild("Humanoid")
                        
                        if root and humanoid then
                            local shouldDodge = true
                            if LowHPOnly.Enabled then
                                shouldDodge = humanoid.Health <= HPThreshold.Value
                            end
                            
                            local currentTime = tick()
                            if shouldDodge and (currentTime - lastDodgeTime) >= Delay.Value then
                                local orgPos = root.Position
                                local foundEnemy = false

                                for _, v in next, playersService:GetPlayers() do
                                    if v ~= lplr and v.Team ~= lplr.Team then
                                        local enemyChar = v.Character
                                        local enemyRoot = enemyChar and enemyChar:FindFirstChild("HumanoidRootPart")
                                        local enemyHum = enemyChar and enemyChar:FindFirstChild("Humanoid")
                                        if enemyRoot and enemyHum and enemyHum.Health > 0 then
                                            local dist = (root.Position - enemyRoot.Position).Magnitude
                                            if dist <= Range.Value then
                                                foundEnemy = true
                                                break
                                            end
                                        end
                                    end
                                end

                                if foundEnemy then
                                    root.CFrame = CFrame.new(orgPos + Vector3.new(0, -230, 0))
                                    task.wait(0.2)
                                    if GodMode.Enabled and lplr.Character and lplr.Character:FindFirstChild("HumanoidRootPart") then
                                        lplr.Character.HumanoidRootPart.CFrame = CFrame.new(orgPos)
                                    end
                                    lastDodgeTime = tick()
                                end
                            end
                        end
                        task.wait(0.2)
                    end
                end)
            end
        end,
        Tooltip = "Prevents you from dying (dodges players and projectiles)"
    })

    Range = GodMode:CreateSlider({
        Name = "Range",
        Min = 0,
        Max = 50,
        Default = 15,
        Function = function(val) Range.Value = val end
    })
    
    LowHPOnly = GodMode:CreateToggle({
        Name = "Low HP Only",
        Default = false,
        Function = function(val) 
            LowHPOnly.Enabled = val 
            HPThreshold.Object.Visible = val
        end
    })
    
    HPThreshold = GodMode:CreateSlider({
        Name = "HP Threshold",
        Min = 10,
        Max = 100,
        Default = 50,
        Function = function(val) HPThreshold.Value = val end
    })
    HPThreshold.Object.Visible = false
    
    Delay = GodMode:CreateSlider({
        Name = "Delay",
        Min = 0,
        Max = 10,
        Default = 1,
        Decimal = 10,
        Suffix = "s",
        Function = function(val) Delay.Value = val end
    })
end)

run(function()
    local DrillUtilities
    local DrillESP
    local TeamCheck
    local Background
    local Color = {}
    local Reference = {}
    local Folder = Instance.new('Folder')
    Folder.Parent = vape.gui
    local AutoAttack
    local AttackRange
    local attackRunning = false
    local lastAttackTime = 0
    local espConnections = {}
    
    local Players = game:GetService("Players")
    local lplr = Players.LocalPlayer
    local RunService = game:GetService("RunService")
    local Workspace = game:GetService("Workspace")
    
    local function isMyDrill(drill)
        if not drill then return false end
        local placerId = drill:GetAttribute("PlacedByUserId")
        return placerId and placerId == lplr.UserId
    end
    
    local function isTeammate(drill)
        if not TeamCheck.Enabled then return false end
        local placerId = drill:GetAttribute("PlacedByUserId")
        if placerId then
            local placer = Players:GetPlayerByUserId(placerId)
            if placer and placer.Team == lplr.Team then
                return true
            end
        end
        return false
    end
    
    local function getDrillInfo(drill)
        local itemType = drill:GetAttribute("ItemType")
        local health = drill:GetAttribute("Health") or 0
        local maxHealth = drill:GetAttribute("MaxHealth") or 750
        local amount = 0
        if itemType then
            amount = drill:GetAttribute(itemType) or 0
        end
        return itemType, amount, health, maxHealth
    end
    
    local function getProperIcon(iconType)
        if not iconType then return nil end
        if not bedwars or not bedwars.getIcon then
            return "rbxasset://textures/ui/GuiImagePlaceholder.png"
        end
        local success, icon = pcall(function()
            return bedwars.getIcon({itemType = iconType}, true)
        end)
        if not success or not icon or icon == "" then
            return "rbxasset://textures/ui/GuiImagePlaceholder.png"
        end
        return icon
    end
    
    local function createESP(drill)
        if isTeammate(drill) then return end
        if Reference[drill] then return end
        local head = drill:FindFirstChild("Head")
        if not head then return end
        
        local billboard = Instance.new('BillboardGui')
        billboard.Parent = Folder
        billboard.Name = 'drill-esp'
        billboard.StudsOffsetWorldSpace = Vector3.new(0, 3, 0)
        billboard.Size = UDim2.fromOffset(110, 26)
        billboard.AlwaysOnTop = true
        billboard.ClipsDescendants = false
        billboard.Adornee = head
        
        local blur = addBlur(billboard)
        blur.Visible = Background.Enabled
        
        local frame = Instance.new('Frame')
        frame.Size = UDim2.fromScale(1, 1)
        frame.BackgroundColor3 = Color3.fromHSV(Color.Hue, Color.Sat, Color.Value)
        frame.BackgroundTransparency = 1 - (Background.Enabled and Color.Opacity or 0.3)
        frame.BorderSizePixel = 0
        frame.Parent = billboard
        
        local uicorner = Instance.new('UICorner')
        uicorner.CornerRadius = UDim.new(0, 6)
        uicorner.Parent = frame
        
        local drillIcon = getProperIcon('drill')
        if drillIcon then
            local drillImage = Instance.new('ImageLabel')
            drillImage.Name = 'DrillIcon'
            drillImage.Size = UDim2.fromOffset(18, 18)
            drillImage.Position = UDim2.new(0, 4, 0.5, 0)
            drillImage.AnchorPoint = Vector2.new(0, 0.5)
            drillImage.BackgroundTransparency = 1
            drillImage.Image = drillIcon
            drillImage.Parent = frame
        end
        
        local healthLabel = Instance.new('TextLabel')
        healthLabel.Name = 'Health'
        healthLabel.Size = UDim2.new(0, 32, 1, 0)
        healthLabel.Position = UDim2.new(0, 25, 0, 0)
        healthLabel.BackgroundTransparency = 1
        healthLabel.Text = "750"
        healthLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        healthLabel.TextSize = 12
        healthLabel.Font = Enum.Font.GothamBold
        healthLabel.TextStrokeTransparency = 0.5
        healthLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
        healthLabel.TextXAlignment = Enum.TextXAlignment.Left
        healthLabel.Parent = frame
        
        local resourceImage = Instance.new('ImageLabel')
        resourceImage.Name = 'ResourceIcon'
        resourceImage.Size = UDim2.fromOffset(16, 16)
        resourceImage.Position = UDim2.new(0, 62, 0.5, 0)
        resourceImage.AnchorPoint = Vector2.new(0, 0.5)
        resourceImage.BackgroundTransparency = 1
        resourceImage.Image = ""
        resourceImage.Parent = frame
        
        local amountLabel = Instance.new('TextLabel')
        amountLabel.Name = 'Amount'
        amountLabel.Size = UDim2.new(0, 28, 1, 0)
        amountLabel.Position = UDim2.new(1, -30, 0, 0)
        amountLabel.BackgroundTransparency = 1
        amountLabel.Text = "0"
        amountLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        amountLabel.TextSize = 12
        amountLabel.Font = Enum.Font.GothamBold
        amountLabel.TextStrokeTransparency = 0.5
        amountLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
        amountLabel.TextXAlignment = Enum.TextXAlignment.Left
        amountLabel.Parent = frame
        
        Reference[drill] = {
            billboard = billboard,
            frame = frame,
            healthLabel = healthLabel,
            resourceImage = resourceImage,
            amountLabel = amountLabel
        }
    end
    
    local function updateESP(drill)
        local ref = Reference[drill]
        if not ref then return end
        local itemType, amount, health, maxHealth = getDrillInfo(drill)
        
        if ref.healthLabel then
            ref.healthLabel.Text = tostring(math.floor(health))
            local healthPercent = health / maxHealth
            if healthPercent > 0.6 then
                ref.healthLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
            elseif healthPercent > 0.3 then
                ref.healthLabel.TextColor3 = Color3.fromRGB(255, 165, 0)
            else
                ref.healthLabel.TextColor3 = Color3.fromRGB(255, 50, 50)
            end
        end
        
        if itemType then
            if ref.resourceImage then
                local resourceIcon = getProperIcon(itemType)
                if resourceIcon then
                    ref.resourceImage.Image = resourceIcon
                end
            end
            if ref.amountLabel then
                ref.amountLabel.Text = tostring(math.floor(amount))
            end
        else
            if ref.resourceImage then
                ref.resourceImage.Image = ""
            end
            if ref.amountLabel then
                ref.amountLabel.Text = "0"
            end
        end
    end
    
    local function findAllDrills()
        local drillGroup = Workspace:FindFirstChild("Drill")
        if drillGroup and drillGroup:IsA("Model") then
            if not isTeammate(drillGroup) then
                createESP(drillGroup)
            end
        end
        
        for _, obj in pairs(Workspace:GetDescendants()) do
            if obj:IsA("Model") and obj.Name == "Drill" and obj ~= drillGroup then
                if not isTeammate(obj) then
                    createESP(obj)
                end
            end
        end
    end
    
    local function refreshESP()
        Folder:ClearAllChildren()
        table.clear(Reference)
        if DrillESP.Enabled then
            findAllDrills()
        end
    end
    
    local function setupESPConnections()
        for _, conn in pairs(espConnections) do
            if conn and conn.Disconnect then
                conn:Disconnect()
            end
        end
        table.clear(espConnections)
        
        table.insert(espConnections, Workspace.DescendantAdded:Connect(function(obj)
            if not DrillESP.Enabled then return end
            if obj:IsA("Model") and obj.Name == "Drill" then
                task.wait(0.1)
                if not isTeammate(obj) then
                    createESP(obj)
                end
            end
        end))
        
        table.insert(espConnections, Workspace.DescendantRemoving:Connect(function(obj)
            if obj:IsA("Model") and obj.Name == "Drill" and Reference[obj] then
                if Reference[obj].billboard then
                    Reference[obj].billboard:Destroy()
                end
                Reference[obj] = nil
            end
        end))
        
        table.insert(espConnections, RunService.Heartbeat:Connect(function()
            if not DrillESP.Enabled then return end
            for drill, ref in pairs(Reference) do
                if drill and drill.Parent then
                    updateESP(drill)
                else
                    if ref.billboard then
                        ref.billboard:Destroy()
                    end
                    Reference[drill] = nil
                end
            end
        end))
    end
    
    local function disconnectESP()
        for _, conn in pairs(espConnections) do
            if conn and conn.Disconnect then
                conn:Disconnect()
            end
        end
        table.clear(espConnections)
    end
    
    local function getAttackData()
        if not entitylib.isAlive then return false end
        local hand = store.hand
        if not hand or not hand.tool then return false end
        if hand.tool.Name ~= "drill_controller" and hand.itemType ~= "drill_controller" then
            return false
        end
        return true
    end
    
    local function getEnemiesNearDrill(drill)
        local enemies = {}
        local head = drill:FindFirstChild("Head")
        if not head then return enemies end
        
        for _, player in Players:GetPlayers() do
            if player ~= lplr and player.Team ~= lplr.Team then
                local char = player.Character
                if char then
                    local humanoid = char:FindFirstChild("Humanoid")
                    local rootPart = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("RootPart")
                    if humanoid and humanoid.Health > 0 and rootPart then
                        local distance = (head.Position - rootPart.Position).Magnitude
                        if distance <= AttackRange.Value then
                            table.insert(enemies, {
                                player = player,
                                character = char,
                                position = rootPart.Position,
                                distance = distance
                            })
                        end
                    end
                end
            end
        end
        return enemies
    end
    
    local function startAutoAttack()
        attackRunning = true
        task.spawn(function()
            while attackRunning and DrillUtilities.Enabled and AutoAttack.Enabled do
                if not entitylib.isAlive then
                    task.wait(0.1)
                    continue
                end
                
                local canAttack = getAttackData()
                if not canAttack then
                    task.wait(0.1)
                    continue
                end
                
                if (tick() - lastAttackTime) < 0.3 then
                    task.wait(0.05)
                    continue
                end
                
                local attacked = false
                local drill = Workspace:FindFirstChild("Drill")
                if drill and drill:IsA("Model") and isMyDrill(drill) then
                    local enemies = getEnemiesNearDrill(drill)
                    if #enemies > 0 then
                        table.sort(enemies, function(a, b)
                            return a.distance < b.distance
                        end)
                        local target = enemies[1]
                        pcall(function()
                            game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("node_modules"):WaitForChild("@rbxts"):WaitForChild("net"):WaitForChild("out"):WaitForChild("_NetManaged"):WaitForChild("DrillAttack"):FireServer({
                                targetPosition = target.position
                            })
                        end)
                        lastAttackTime = tick()
                        attacked = true
                    end
                end
                
                for _, obj in pairs(Workspace:GetDescendants()) do
                    if attacked then break end
                    if obj:IsA("Model") and obj.Name == "Drill" and isMyDrill(obj) then
                        local enemies = getEnemiesNearDrill(obj)
                        if #enemies > 0 then
                            table.sort(enemies, function(a, b)
                                return a.distance < b.distance
                            end)
                            local target = enemies[1]
                            pcall(function()
                                game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("node_modules"):WaitForChild("@rbxts"):WaitForChild("net"):WaitForChild("out"):WaitForChild("_NetManaged"):WaitForChild("DrillAttack"):FireServer({
                                    targetPosition = target.position
                                })
                            end)
                            lastAttackTime = tick()
                            attacked = true
                            break
                        end
                    end
                end
                
                if not attacked then
                    task.wait(0.1)
                else
                    task.wait(0.3)
                end
            end
            attackRunning = false
        end)
    end
    
    DrillUtilities = vape.Categories.Kits:CreateModule({
        Name = 'AutoDrill',
        Function = function(callback)
            if callback then
                if AutoAttack.Enabled then
                    startAutoAttack()
                end
            else
                attackRunning = false
                disconnectESP()
                Folder:ClearAllChildren()
                table.clear(Reference)
            end
        end,
        Tooltip = 'Drill utilities: ESP and auto attack'
    })
    
    DrillESP = DrillUtilities:CreateToggle({
        Name = 'Drill ESP',
        Default = false,
        Tooltip = 'ESP for drills showing health and resources',
        Function = function(callback)
            if TeamCheck.Object then TeamCheck.Object.Visible = callback end
            if Background.Object then Background.Object.Visible = callback end
            if Color.Object then Color.Object.Visible = callback end
            if callback then
                setupESPConnections()
                findAllDrills()
            else
                disconnectESP()
                Folder:ClearAllChildren()
                table.clear(Reference)
            end
        end
    })
    
    TeamCheck = DrillUtilities:CreateToggle({
        Name = 'Team Check',
        Default = true,
        Tooltip = 'Hide teammate drills',
        Function = function(callback)
            if DrillESP.Enabled then
                refreshESP()
            end
        end
    })
    TeamCheck.Object.Visible = false
    
    Background = DrillUtilities:CreateToggle({
        Name = 'Background',
        Default = true,
        Function = function(callback)
            if Color.Object then Color.Object.Visible = callback end
            for _, ref in pairs(Reference) do
                if ref.frame then
                    ref.frame.BackgroundTransparency = 1 - (callback and Color.Opacity or 0.3)
                    if ref.billboard and ref.billboard.Blur then
                        ref.billboard.Blur.Visible = callback
                    end
                end
            end
        end
    })
    Background.Object.Visible = false
    
    Color = DrillUtilities:CreateColorSlider({
        Name = 'Background Color',
        DefaultValue = 0,
        DefaultOpacity = 0.3,
        Function = function(hue, sat, val, opacity)
            Color.Hue = hue
            Color.Sat = sat
            Color.Value = val
            Color.Opacity = opacity
            for _, ref in pairs(Reference) do
                if ref.frame then
                    ref.frame.BackgroundColor3 = Color3.fromHSV(hue, sat, val)
                    ref.frame.BackgroundTransparency = 1 - opacity
                end
            end
        end,
        Darker = true
    })
    Color.Object.Visible = false
    
    AutoAttack = DrillUtilities:CreateToggle({
        Name = 'Auto Attack',
        Default = false,
        Tooltip = 'Auto attack enemies near drills',
        Function = function(callback)
            if AttackRange.Object then AttackRange.Object.Visible = callback end
            if callback and DrillUtilities.Enabled then
                startAutoAttack()
            else
                attackRunning = false
            end
        end
    })
    
    AttackRange = DrillUtilities:CreateSlider({
        Name = 'Attack Range',
        Min = 10,
        Max = 20,
        Default = 20,
        Suffix = ' studs',
        Tooltip = 'Range to attack from drill'
    })
    AttackRange.Object.Visible = false
end)

run(function()
    local BlockESP
    local Background
    local Color = {}
    local TeamCheck
    local List
    local Reference = {}   
    local Tracked = {}      
    local PathCache = {}    
    local Folder = Instance.new('Folder')
    Folder.Parent = vape.gui
    local Players = game:GetService("Players")
    local lplr = Players.LocalPlayer

    local function isTeammate(part)
        if not TeamCheck.Enabled then return false end

        local placerId = part:GetAttribute("PlacedByUserId") or part:GetAttribute("PlacerId")
        if not placerId then
            local parent = part.Parent
            if parent then
                placerId = parent:GetAttribute("PlacedByUserId") or parent:GetAttribute("PlacerId")
            end
        end

        if placerId then
            local placer = Players:GetPlayerByUserId(placerId)
            if placer and placer.Team == lplr.Team then
                return true
            end
        end

        return false
    end

    local function Added(part)
        if Reference[part] then return end
        if isTeammate(part) then return end

        local billboard = Instance.new('BillboardGui')
        billboard.Parent = Folder
        billboard.Name = "BlockESP"
        billboard.StudsOffsetWorldSpace = Vector3.new(0, 3, 0)
        billboard.Size = UDim2.fromOffset(36, 36)
        billboard.AlwaysOnTop = true
        billboard.ClipsDescendants = false
        billboard.Adornee = part

        local blur = addBlur(billboard)
        blur.Visible = Background.Enabled

        local image = Instance.new('ImageLabel')
        image.Size = UDim2.fromOffset(36, 36)
        image.Position = UDim2.fromScale(0.5, 0.5)
        image.AnchorPoint = Vector2.new(0.5, 0.5)
        image.BackgroundColor3 = Color3.fromHSV(Color.Hue or 0, Color.Sat or 0, Color.Value or 1)
        image.BackgroundTransparency = 1 - (Background.Enabled and (Color.Opacity or 0.5) or 0)
        image.BorderSizePixel = 0
        image.Image = bedwars.getIcon({ itemType = part.Name }, true)
        image.Parent = billboard

        local uicorner = Instance.new('UICorner')
        uicorner.CornerRadius = UDim.new(0, 4)
        uicorner.Parent = image

        Reference[part] = billboard
    end

    local function Removed(part)
        if Reference[part] then
            Reference[part]:Destroy()
            Reference[part] = nil
        end
    end

    local function learnAndScan(metaName)
        for _, obj in pairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") and obj.Name == metaName then
                
                PathCache[metaName] = obj.Parent
                for _, child in pairs(obj.Parent:GetDescendants()) do
                    if child:IsA("BasePart") and child.Name == metaName and not Reference[child] then
                        Added(child)
                    end
                end
                return true
            end
        end
        return false 
    end

    local function scanCached(metaName)
        local path = PathCache[metaName]
        if not path or not path.Parent then
            return learnAndScan(metaName)
        end
        for _, child in pairs(path:GetDescendants()) do
            if child:IsA("BasePart") and child.Name == metaName and not Reference[child] then
                Added(child)
            end
        end
        return true
    end

    local function findExisting()
        for name in pairs(Tracked) do
            if PathCache[name] then
                scanCached(name)
            else
                learnAndScan(name)
            end
        end
    end

    local function refreshESP()
        Folder:ClearAllChildren()
        table.clear(Reference)
        if BlockESP.Enabled then
            findExisting()
        end
    end

    BlockESP = vape.Categories.Render:CreateModule({
        Name = 'BlockESP',
        Function = function(callback)
            if callback then
                findExisting()

                BlockESP:Clean(workspace.DescendantAdded:Connect(function(obj)
                    if not BlockESP.Enabled then return end
                    if not obj:IsA("BasePart") then return end
                    if not Tracked[obj.Name] then return end

                    task.wait(0.1)

                    if not PathCache[obj.Name] then
                        PathCache[obj.Name] = obj.Parent
                    end

                    Added(obj)
                end))

                BlockESP:Clean(workspace.DescendantRemoving:Connect(function(obj)
                    if obj:IsA("BasePart") and Reference[obj] then
                        Removed(obj)
                    end
                end))
            else
                Folder:ClearAllChildren()
                table.clear(Reference)
            end
        end,
        Tooltip = 'ESP for blocks  type meta names into the list'
    })

    List = BlockESP:CreateTextList({
        Name = 'Block',
        Function = function(entries)
            table.clear(Tracked)
            if entries then
                for _, name in ipairs(entries) do
                    if name and name ~= "" then
                        Tracked[name] = true
                    end
                end
            end

            if BlockESP.Enabled then
                refreshESP()
            end
        end
    })

    TeamCheck = BlockESP:CreateToggle({
        Name = 'Team Check',
        Function = function(callback)
            if BlockESP.Enabled then
                refreshESP()
            end
        end,
        Tooltip = 'Hide blocks placed by teammates',
        Default = true
    })

    Background = BlockESP:CreateToggle({
        Name = 'Background',
        Function = function(callback)
            for _, billboard in pairs(Reference) do
                if billboard then
                    local img = billboard:FindFirstChildOfClass("ImageLabel")
                    if img then
                        img.BackgroundTransparency = 1 - (callback and (Color.Opacity or 0.5) or 0)
                    end
                    local blur = billboard:FindFirstChild("Blur")
                    if blur then
                        blur.Visible = callback
                    end
                end
            end
        end,
        Default = true
    })

    Color = BlockESP:CreateColorSlider({
        Name = 'Background Color',
        DefaultValue = 0,
        DefaultOpacity = 0.5,
        Function = function(hue, sat, val, opacity)
            Color.Hue = hue
            Color.Sat = sat
            Color.Value = val
            Color.Opacity = opacity

            for _, billboard in pairs(Reference) do
                if billboard then
                    local img = billboard:FindFirstChildOfClass("ImageLabel")
                    if img then
                        img.BackgroundColor3 = Color3.fromHSV(hue, sat, val)
                        img.BackgroundTransparency = 1 - opacity
                    end
                end
            end
        end,
        Darker = true
    })
end)

run(function()
	local DisableStreamer
	local old = {}
	DisableStreamer = vape.Categories.Legit:CreateModule({
		Name = 'DisableStreamer',
		Function = function(callback)
			if callback then
				for _, plrs in playersService:GetPlayers() do
					if plrs == lplr then continue end
					old[plrs] = plrs:GetAttribute("Disguised") or true
					plrs:SetAttribute("Disguised", false)
				end
			else
				for _, plrs in playersService:GetPlayers() do
					if plrs == lplr then continue end
					if old[plrs] then
						local arg = old[plrs] or true
						plrs:SetAttribute("Disguised", arg)
						old[plrs] = nil
					end
					
				end
			end
		end,
		Tooltip = 'Disable people streamer mode'
	})
end)

run(function()
	local CustomArmour
	local ArmourColor
	local ArmourTrans
	local BootsToggle
	local HelmetToggle
	local ChestToggle
	local MaterialMode
	local UseOutline
	local OutlineColor
	local OutlineThickness
	local PulseEffect
	local PulseSpeed
	local RainbowCycle
	local RainbowSpeed
	local ApplyToTeammates
	local ApplyToEnemies
	
	local highlightNames = {
		boots = 'vape_ca_boots',
		helmet = 'vape_ca_helmet',
		chestplate = 'vape_ca_chestplate'
	}
	
	local rainbowHue = 0
	local pulseDirection = 1
	local pulseValue = 0
	local animationConnection
	local armorConnections = {}
	
	local function isTeammate(player)
		if not lplr or not player then return false end
		local myTeam = lplr:GetAttribute('Team')
		local theirTeam = player:GetAttribute('Team')
		return myTeam and theirTeam and myTeam == theirTeam
	end
	
	local function shouldApplyToPlayer(player)
		if player == lplr then return true end
		
		if isTeammate(player) then
			return ApplyToTeammates.Enabled
		else
			return ApplyToEnemies.Enabled
		end
	end
	
	local function findArmourPieces(character)
		local pieces = { boots = {}, helmet = {}, chestplate = {} }
		if not character then return pieces end
		
		for _, v in pairs(character:GetChildren()) do
			local nameLower = v.Name:lower()
			if nameLower:find('boot') and v:FindFirstChild('Handle') then
				table.insert(pieces.boots, v)
			elseif nameLower:find('helmet') and v:FindFirstChild('Handle') then
				table.insert(pieces.helmet, v)
			elseif nameLower:find('chestplate') and v:FindFirstChild('Handle') then
				table.insert(pieces.chestplate, v)
			end
		end
		
		return pieces
	end
	
	local function getEffectiveColor()
		if RainbowCycle.Enabled then
			return Color3.fromHSV(rainbowHue, 1, 1)
		else
			return Color3.fromHSV(ArmourColor.Hue, ArmourColor.Sat, ArmourColor.Value)
		end
	end
	
	local function getEffectiveTransparency()
		local baseTrans = ArmourTrans.Value / 100
		
		if PulseEffect.Enabled then
			return math.clamp(baseTrans + (pulseValue * 0.5), 0, 1)
		end
		
		return baseTrans
	end
	
	local function applyMaterial(highlight)
		local mode = MaterialMode.Value
		
		if mode == 'Highlight' then
			highlight.DepthMode = Enum.HighlightDepthMode.Occluded
		elseif mode == 'Neon' then
			highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
		elseif mode == 'ForceField' then
			highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
		end
	end
	
	local function createHighlight(parent, name)
		local existing = parent:FindFirstChild(name)
		if existing then
			existing:Destroy()
		end
		
		local h = Instance.new('Highlight')
		h.Parent = parent
		h.Name = name
		h.Enabled = true
		h.Adornee = parent.Handle
		
		applyMaterial(h)
		
		if UseOutline.Enabled then
			h.FillTransparency = 1
			h.OutlineColor = Color3.fromHSV(OutlineColor.Hue, OutlineColor.Sat, OutlineColor.Value)
			h.OutlineTransparency = getEffectiveTransparency()
		else
			h.FillColor = getEffectiveColor()
			h.FillTransparency = getEffectiveTransparency()
			h.OutlineTransparency = 1
		end
		
		return h
	end
	
	local function applyArmourToCharacter(character, player)
		if not character or not shouldApplyToPlayer(player) then return end
		
		local pieces = findArmourPieces(character)
		
		if BootsToggle.Enabled then
			for _, part in pairs(pieces.boots) do
				createHighlight(part, highlightNames.boots)
			end
		end
		
		if HelmetToggle.Enabled then
			for _, part in pairs(pieces.helmet) do
				createHighlight(part, highlightNames.helmet)
			end
		end
		
		if ChestToggle.Enabled then
			for _, part in pairs(pieces.chestplate) do
				createHighlight(part, highlightNames.chestplate)
			end
		end
	end
	
	local function removeArmourFromCharacter(character)
		if not character then return end
		
		for _, v in pairs(character:GetDescendants()) do
			if v:IsA('Highlight') then
				if v.Name == highlightNames.boots or v.Name == highlightNames.helmet or v.Name == highlightNames.chestplate then
					v:Destroy()
				end
			end
		end
	end
	
	local function updateAllHighlights()
		if not CustomArmour.Enabled then return end
		
		for _, player in pairs(game.Players:GetPlayers()) do
			if player.Character and shouldApplyToPlayer(player) then
				local color = getEffectiveColor()
				local trans = getEffectiveTransparency()
				
				for _, v in pairs(player.Character:GetDescendants()) do
					if v:IsA('Highlight') and (v.Name == highlightNames.boots or v.Name == highlightNames.helmet or v.Name == highlightNames.chestplate) then
						if UseOutline.Enabled then
							v.OutlineColor = Color3.fromHSV(OutlineColor.Hue, OutlineColor.Sat, OutlineColor.Value)
							v.OutlineTransparency = trans
							v.FillTransparency = 1
						else
							v.FillColor = color
							v.FillTransparency = trans
							v.OutlineTransparency = 1
						end
					end
				end
			end
		end
	end
	
	local function setupCharacterMonitoring(character, player)
		if not character or not player then return end
		
		local childAddedConn = character.ChildAdded:Connect(function(child)
			if not CustomArmour.Enabled or not shouldApplyToPlayer(player) then return end
			
			task.wait(0.1)
			
			local nameLower = child.Name:lower()
			if nameLower:find('boot') and BootsToggle.Enabled and child:FindFirstChild('Handle') then
				createHighlight(child, highlightNames.boots)
			elseif nameLower:find('helmet') and HelmetToggle.Enabled and child:FindFirstChild('Handle') then
				createHighlight(child, highlightNames.helmet)
			elseif nameLower:find('chestplate') and ChestToggle.Enabled and child:FindFirstChild('Handle') then
				createHighlight(child, highlightNames.chestplate)
			end
		end)
		
		local childRemovedConn = character.ChildRemoved:Connect(function(child)
			local highlight = child:FindFirstChild(highlightNames.boots) or 
							  child:FindFirstChild(highlightNames.helmet) or 
							  child:FindFirstChild(highlightNames.chestplate)
			if highlight then
				highlight:Destroy()
			end
		end)
		
		table.insert(armorConnections, childAddedConn)
		table.insert(armorConnections, childRemovedConn)
	end
	
	local function applyToAllPlayers()
		for _, player in pairs(game.Players:GetPlayers()) do
			if player.Character then
				applyArmourToCharacter(player.Character, player)
				setupCharacterMonitoring(player.Character, player)
			end
		end
	end
	
	local function removeFromAllPlayers()
		for _, player in pairs(game.Players:GetPlayers()) do
			if player.Character then
				removeArmourFromCharacter(player.Character)
			end
		end
	end
	
	local function refreshArmour()
		removeFromAllPlayers()
		if CustomArmour.Enabled then
			applyToAllPlayers()
		end
	end
	
	local function startAnimations()
		if animationConnection then return end
		
		animationConnection = runService.Heartbeat:Connect(function(dt)
			if not CustomArmour.Enabled then return end
			
			local shouldUpdate = false
			
			if RainbowCycle.Enabled then
				rainbowHue = (rainbowHue + (dt * RainbowSpeed.Value)) % 1
				shouldUpdate = true
			end
			
			if PulseEffect.Enabled then
				pulseValue = pulseValue + (pulseDirection * dt * PulseSpeed.Value)
				if pulseValue >= 1 then
					pulseValue = 1
					pulseDirection = -1
				elseif pulseValue <= 0 then
					pulseValue = 0
					pulseDirection = 1
				end
				shouldUpdate = true
			end
			
			if shouldUpdate then
				updateAllHighlights()
			end
		end)
	end
	
	local function stopAnimations()
		if animationConnection then
			animationConnection:Disconnect()
			animationConnection = nil
		end
		rainbowHue = 0
		pulseValue = 0
		pulseDirection = 1
	end
	
	CustomArmour = vape.Categories.Render:CreateModule({
		Name = 'CustomArmour',
		Function = function(callback)
			if callback then
				applyToAllPlayers()
				
				CustomArmour:Clean(game.Players.PlayerAdded:Connect(function(player)
					player.CharacterAdded:Connect(function(character)
						task.wait(1)
						if CustomArmour.Enabled then
							applyArmourToCharacter(character, player)
							setupCharacterMonitoring(character, player)
						end
					end)
				end))
				
				CustomArmour:Clean(lplr.CharacterAdded:Connect(function(character)
					task.wait(1)
					if CustomArmour.Enabled then
						applyArmourToCharacter(character, lplr)
						setupCharacterMonitoring(character, lplr)
					end
				end))
				
				if RainbowCycle.Enabled or PulseEffect.Enabled then
					startAnimations()
				end
			else
				removeFromAllPlayers()
				stopAnimations()
				
				for _, conn in pairs(armorConnections) do
					pcall(function() conn:Disconnect() end)
				end
				table.clear(armorConnections)
			end
		end,
		Tooltip = 'Customizes the color of armor'
	})
	
	MaterialMode = CustomArmour:CreateDropdown({
		Name = 'Material',
		List = {'Highlight', 'Neon', 'ForceField'},
		Default = 'Highlight',
		Function = function(val)
			refreshArmour()
		end,
		Tooltip = 'Visual style of the armor effect'
	})
	
	UseOutline = CustomArmour:CreateToggle({
		Name = 'Use Outline',
		Default = false,
		Function = function(val)
			if OutlineColor then
				OutlineColor.Object.Visible = val
			end
			if OutlineThickness then
				OutlineThickness.Object.Visible = val
			end
			updateAllHighlights()
		end,
		Tooltip = 'Use outline instead of fill color'
	})
	
	ArmourColor = CustomArmour:CreateColorSlider({
		Name = 'Fill Color',
		Function = function()
			updateAllHighlights()
		end,
		Tooltip = 'Color of the armor fill'
	})
	
	OutlineColor = CustomArmour:CreateColorSlider({
		Name = 'Outline Color',
		Function = function()
			updateAllHighlights()
		end,
		Tooltip = 'Color of the armor outline',
		Visible = false
	})
	
	OutlineThickness = CustomArmour:CreateSlider({
		Name = 'Outline Thickness',
		Min = 1,
		Max = 10,
		Default = 3,
		Function = function(val)
		end,
		Tooltip = 'Thickness of the outline (placeholder)',
		Visible = false
	})
	
	ArmourTrans = CustomArmour:CreateSlider({
		Name = 'Transparency',
		Min = 0,
		Max = 100,
		Default = 0,
		Suffix = '%',
		Function = function(val)
			updateAllHighlights()
		end,
		Tooltip = 'Transparency of the armor effect'
	})
	
	PulseEffect = CustomArmour:CreateToggle({
		Name = 'Pulse Effect',
		Default = false,
		Function = function(val)
			if PulseSpeed then
				PulseSpeed.Object.Visible = val
			end
			if val and CustomArmour.Enabled then
				startAnimations()
			elseif not RainbowCycle.Enabled then
				stopAnimations()
			end
		end,
		Tooltip = 'Pulsing transparency animation'
	})
	
	PulseSpeed = CustomArmour:CreateSlider({
		Name = 'Pulse Speed',
		Min = 0.5,
		Max = 5,
		Default = 2,
		Decimal = 10,
		Function = function(val)
		end,
		Tooltip = 'Speed of pulse animation',
		Visible = false
	})
	
	RainbowCycle = CustomArmour:CreateToggle({
		Name = 'Rainbow Cycle',
		Default = false,
		Function = function(val)
			if RainbowSpeed then
				RainbowSpeed.Object.Visible = val
			end
			if val and CustomArmour.Enabled then
				startAnimations()
			elseif not PulseEffect.Enabled then
				stopAnimations()
			end
		end,
		Tooltip = 'Cycles through rainbow colors'
	})
	
	RainbowSpeed = CustomArmour:CreateSlider({
		Name = 'Rainbow Speed',
		Min = 0.1,
		Max = 2,
		Default = 0.5,
		Decimal = 10,
		Function = function(val)
		end,
		Tooltip = 'Speed of rainbow cycle',
		Visible = false
	})
	
	BootsToggle = CustomArmour:CreateToggle({
		Name = 'Boots',
		Default = true,
		Function = function(val)
			refreshArmour()
		end,
		Tooltip = 'Apply effect to boots'
	})
	
	HelmetToggle = CustomArmour:CreateToggle({
		Name = 'Helmet',
		Default = true,
		Function = function(val)
			refreshArmour()
		end,
		Tooltip = 'Apply effect to helmet'
	})
	
	ChestToggle = CustomArmour:CreateToggle({
		Name = 'Chestplate',
		Default = true,
		Function = function(val)
			refreshArmour()
		end,
		Tooltip = 'Apply effect to chestplate'
	})
	
	ApplyToTeammates = CustomArmour:CreateToggle({
		Name = 'Apply to Teammates',
		Default = false,
		Function = function(val)
			refreshArmour()
		end,
		Tooltip = 'Apply effect to teammate armor'
	})
	
	ApplyToEnemies = CustomArmour:CreateToggle({
		Name = 'Apply to Enemies',
		Default = false,
		Function = function(val)
			refreshArmour()
		end,
		Tooltip = 'Apply effect to enemy armor'
	})
end)

run(function()
	TrapDisabler = vape.Categories.Utility:CreateModule({
		Name = 'TrapDisabler',
		Tooltip = 'Disables Snap Traps'
	})
end)

run(function()
	local RavenTP
	
	RavenTP = vape.Categories.Utility:CreateModule({
		Name = 'RavenTP',
		Function = function(callback)
			if callback then
				RavenTP:Toggle()
				local plr = entitylib.EntityMouse({
					Range = 1000,
					Players = true,
					Part = 'RootPart'
				})
	
				if getItem('raven') and plr then
					bedwars.Client:Get("SpawnRaven"):CallServerAsync():andThen(function(projectile)
						if projectile then
							local ravenPart = projectile:FindFirstChild("Root") or projectile:FindFirstChildWhichIsA("BasePart")
							
							if ravenPart then
								local bodyforce = Instance.new('BodyForce')
								bodyforce.Force = Vector3.new(0, ravenPart.AssemblyMass * workspace.Gravity, 0)
								bodyforce.Parent = ravenPart
		
								if plr then
									task.spawn(function()
										for _ = 1, 20 do
											if plr.RootPart and ravenPart then
												ravenPart.CFrame = CFrame.lookAlong(plr.RootPart.Position, gameCamera.CFrame.LookVector)
											end
											task.wait(0.05)
										end
									end)
									task.wait(0.3)
									bedwars.RavenController:detonateRaven()
								end
							end
						end
					end)
				end
			end
		end,
		Tooltip = 'Spawns and teleports a raven to a player\nnear your mouse.'
	})
end)

run(function()
	local BlockIn
	local SpeedSlider
	local DelaySlider
	local AutoSwitch
	local HandCheck
	local StrongestOnly
	local CpsConstants = nil
	local originalCPS = 12
	local placing = false
	local buildThread = nil
	
	local facesOnly = {
		Vector3.new(3, 0, 0),   
		Vector3.new(-3, 0, 0), 
		Vector3.new(0, 3, 0),   
		Vector3.new(0, -3, 0),  
		Vector3.new(0, 0, 3),   
		Vector3.new(0, 0, -3) 
	}
	
	local function checkFaceAdjacent(pos)
		for _, v in facesOnly do
			if getPlacedBlock(pos + v) then
				return true
			end
		end
		return false
	end
	
	local function hasFaceBelowOrSide(pos)
		if getPlacedBlock(pos - Vector3.new(0, 3, 0)) then
			return true
		end
		
		for _, v in facesOnly do
			if v.Y == 0 and getPlacedBlock(pos + v) then
				return true
			end
		end
		
		return false
	end
	
	local function nearCorner(poscheck, pos)
		local startpos = poscheck - Vector3.new(3, 3, 3)
		local endpos = poscheck + Vector3.new(3, 3, 3)
		local check = poscheck + (pos - poscheck).Unit * 100
		return Vector3.new(math.clamp(check.X, startpos.X, endpos.X), math.clamp(check.Y, startpos.Y, endpos.Y), math.clamp(check.Z, startpos.Z, endpos.Z))
	end
	
	local function blockProximity(pos)
		local mag, returned = 60
		local tab = getBlocksInPoints(
			bedwars.BlockController:getBlockPosition(pos - Vector3.new(21, 21, 21)), 
			bedwars.BlockController:getBlockPosition(pos + Vector3.new(21, 21, 21))
		)
		
		for _, v in tab do
			local blockpos = nearCorner(v, pos)
			local newmag = (pos - blockpos).Magnitude
			
			if hasFaceBelowOrSide(blockpos) and newmag < mag then
				mag, returned = newmag, blockpos
			end
		end
		
		table.clear(tab)
		return returned
	end
	
	local function canPlaceAtPosition(blockpos)
		if not checkFaceAdjacent(blockpos) then
			return false
		end
		
		local checkBelow = blockpos - Vector3.new(0, 3, 0)
		local hasSupport = false
		
		for i = 1, 10 do
			if getPlacedBlock(checkBelow) then
				hasSupport = true
				break
			end
			checkBelow = checkBelow - Vector3.new(0, 3, 0)
		end
		
		return hasSupport or hasFaceBelowOrSide(blockpos)
	end
	
	local function initCPS()
		pcall(function()
			CpsConstants = require(replicatedStorage.TS['shared-constants']).CpsConstants
		end)
		
		if not CpsConstants then
			pcall(function()
				CpsConstants = bedwars.CpsConstants
			end)
		end
		
		if CpsConstants then
			originalCPS = CpsConstants.BLOCK_PLACE_CPS
		end
	end
	
	local function setCPS(value)
		if CpsConstants then
			CpsConstants.BLOCK_PLACE_CPS = value
		end
	end
	
	local function getBlocks()
		local blocks = {}
		
		for _, item in pairs(store.inventory.inventory.items) do
			if bedwars.ItemMeta[item.itemType] and bedwars.ItemMeta[item.itemType].block then
				local meta = bedwars.ItemMeta[item.itemType]
				table.insert(blocks, {
					itemType = item.itemType,
					health = meta.block.health or 0,
					tool = item.tool
				})
			end
		end
		
		table.sort(blocks, function(a, b)
			return a.health > b.health
		end)
		
		return blocks
	end
	
	local function getHotbarSlotForBlock(blockTool)
		for i, v in pairs(store.inventory.hotbar) do
			if v.item and v.item.tool == blockTool then
				return i - 1
			end
		end
		return nil
	end
	
	local function hasBlockAt(pos)
		local block, blockpos = getPlacedBlock(pos)
		return block ~= nil
	end
	
	local function getScaffoldBlock()
		if HandCheck.Enabled then
			if store.hand and store.hand.toolType == 'block' then
				return store.hand.tool.Name
			end
			return nil
		else
			local blocks = getBlocks()
			if #blocks == 0 then
				return nil
			end
			
			if StrongestOnly.Enabled then
				return blocks[1].itemType
			else
				local weakestInHotbar = nil
				local weakestHealth = math.huge
				
				for _, block in ipairs(blocks) do
					local slot = getHotbarSlotForBlock(block.tool)
					if slot then
						if block.health < weakestHealth then
							weakestHealth = block.health
							weakestInHotbar = block
						end
					end
				end
				
				if weakestInHotbar then
					return weakestInHotbar.itemType
				else
					return blocks[1].itemType
				end
			end
		end
	end
	
	local function findGaps(origin)
		local gaps = {}
		
		local offsets = {
			Vector3.new(3, 3, 0),
			Vector3.new(-3, 3, 0),
			Vector3.new(0, 3, 3),
			Vector3.new(0, 3, -3),
			Vector3.new(0, 6, 0),
		}
		
		for _, offset in ipairs(offsets) do
			local pos = origin + offset
			
			if not hasBlockAt(pos) then
				table.insert(gaps, pos)
			end
		end
		
		return gaps
	end
	
	local function hasMovedSignificantly(startPos, currentPos)
		local distance = (startPos - currentPos).Magnitude
		return distance > 2
	end
	
	local function executeBlockIn()
		if placing then return end
		placing = true
		
		buildThread = task.spawn(function()
			while BlockIn.Enabled and placing do
				if not entitylib.isAlive then
					notif('BlockIn', 'Not alive', 2)
					placing = false
					BlockIn:Toggle()
					return
				end
				
				local blockToUse = getScaffoldBlock()
				
				if not blockToUse then
					task.wait(0.1)
					continue
				end
				
				setCPS(SpeedSlider.Value)
				
				local startOrigin = entitylib.character.RootPart.Position
				
				local gaps = findGaps(startOrigin)
				
				if #gaps == 0 then
					if AutoSwitch.Enabled and not HandCheck.Enabled then
						pcall(function()
							hotbarSwitch(store.inventory.hotbarSlot)
						end)
					end
					
					setCPS(originalCPS)
					placing = false
					
					task.wait(0.1)
					if BlockIn.Enabled then
						BlockIn:Toggle()
					end
					return
				end
				
				local originalSlot = store.inventory.hotbarSlot
				local delay = DelaySlider.Value / 1000
				
				if AutoSwitch.Enabled and not HandCheck.Enabled then
					local blocks = getBlocks()
					if #blocks > 0 then
						local targetBlock = nil
						
						if StrongestOnly.Enabled then
							targetBlock = blocks[1]
						else
							local weakestInHotbar = nil
							local weakestHealth = math.huge
							
							for _, block in ipairs(blocks) do
								local slot = getHotbarSlotForBlock(block.tool)
								if slot then
									if block.health < weakestHealth then
										weakestHealth = block.health
										weakestInHotbar = block
									end
								end
							end
							
							targetBlock = weakestInHotbar or blocks[1]
						end
						
						if targetBlock then
							local slot = getHotbarSlotForBlock(targetBlock.tool)
							if slot then
								hotbarSwitch(slot)
								task.wait(0.05)
							end
						end
					end
				end
				
				for i, pos in ipairs(gaps) do
					if not BlockIn.Enabled or not placing then 
						break 
					end
					
					local currentBlock = getScaffoldBlock()
					if not currentBlock then
						break
					end
					
					if not entitylib.isAlive then
						break
					end
					
					local currentPos = entitylib.character.RootPart.Position
					if hasMovedSignificantly(startOrigin, currentPos) then
						break
					end
					
					if not hasBlockAt(pos) then
						if hasFaceBelowOrSide(pos) then
							if canPlaceAtPosition(pos) then
								task.spawn(bedwars.placeBlock, pos, currentBlock, false)
							end
						else
							local nearestBlock = blockProximity(pos)
							if nearestBlock and canPlaceAtPosition(nearestBlock) then
								task.spawn(bedwars.placeBlock, nearestBlock, currentBlock, false)
							end
						end
					end
					
					if i < #gaps then
						task.wait(delay)
					end
				end
				
				task.wait(0.1)
			end
			
			if AutoSwitch.Enabled and not HandCheck.Enabled then
				pcall(function()
					hotbarSwitch(store.inventory.hotbarSlot)
				end)
			end
			setCPS(originalCPS)
			placing = false
		end)
	end
	
	BlockIn = vape.Categories.Utility:CreateModule({
		Name = 'BlockIn',
		Function = function(callback)
			if callback then
				initCPS()
				executeBlockIn()
			else
				placing = false
				if buildThread then
					pcall(function()
						task.cancel(buildThread)
					end)
					buildThread = nil
				end
				setCPS(originalCPS)
			end
		end,
		Tooltip = 'Surrounds you with blocks (real-time gap detection)'
	})
	
	SpeedSlider = BlockIn:CreateSlider({
		Name = 'Speed',
		Min = 12,
		Max = 100,
		Default = 67,
		Suffix = ' CPS',
		Function = function(val)
			if BlockIn.Enabled then
				setCPS(val)
			end
		end,
		Tooltip = 'Block placement speed'
	})
	
	DelaySlider = BlockIn:CreateSlider({
		Name = 'Delay',
		Min = 0,
		Max = 200,
		Default = 50,
		Suffix = 'ms',
		Function = function(val)
		end,
		Tooltip = 'Delay between blocks'
	})
	
	AutoSwitch = BlockIn:CreateToggle({
		Name = 'Auto Switch',
		Default = true,
		Function = function(val)
		end,
		Tooltip = 'Auto switch to blocks'
	})
	
	HandCheck = BlockIn:CreateToggle({
		Name = 'Hand Check',
		Default = false,
		Function = function(val)
		end,
		Tooltip = 'Only build when holding block'
	})
	
	StrongestOnly = BlockIn:CreateToggle({
		Name = 'Strongest Only',
		Default = false,
		Function = function(val)
		end,
		Tooltip = 'Use strongest block only (obsidian)'
	})
end)

run(function()
    local AutoNoelle
    local HealSlimeToggle
    local HealSlimeDropdown
    local HealSlimeRefresh
    local VoidSlimeToggle
    local VoidSlimeDropdown
    local VoidSlimeRefresh
    local StickySlimeToggle
    local StickySlimeDropdown
    local StickySlimeRefresh
    local FrostySlimeToggle
    local FrostySlimeDropdown
    local FrostySlimeRefresh
    
    local running = false
    local slimeCheckThread = nil
    
    local SLIME_TYPES = {
        HEALING = 0,
        VOID = 1,
        STICKY = 2,
        FROSTY = 3
    }
    
    local SLIME_NAMES = {
        [SLIME_TYPES.HEALING] = "Blessed Slime",
        [SLIME_TYPES.VOID] = "Void Slime",
        [SLIME_TYPES.STICKY] = "Sticky Slime",
        [SLIME_TYPES.FROSTY] = "Frosty Slime"
    }
    
    local function getTeammateList()
        local teammates = {"None"}
        local myTeam = lplr:GetAttribute('Team')
        
        if not myTeam then return teammates end
        
        for _, player in playersService:GetPlayers() do
            if player ~= lplr then
                local playerTeam = player:GetAttribute('Team')
                if playerTeam and playerTeam == myTeam then
                    table.insert(teammates, player.Name)
                end
            end
        end
        
        table.sort(teammates)
        return teammates
    end
    
    local function getMySlimes()
        local mySlimes = {}
        
        for _, slimeData in collectionService:GetTagged('SlimeData') do
            if slimeData:WaitForChild("Tamer", 0.1) and slimeData.Tamer.Value == lplr.UserId then
                local slimeType = slimeData:GetAttribute("SlimeType")
                local slimeId = slimeData:GetAttribute("Id")
                
                if slimeType ~= nil and slimeId ~= nil then
                    if not mySlimes[slimeType] then
                        mySlimes[slimeType] = {}
                    end
                    table.insert(mySlimes[slimeType], {
                        data = slimeData,
                        id = slimeId,
                        type = slimeType
                    })
                end
            end
        end
        
        return mySlimes
    end
    
    local function getSlimeCurrentTarget(slimeData)
        if not slimeData or not slimeData:FindFirstChild("Following") then
            return nil
        end
        
        local followingUserId = slimeData.Following.Value
        if followingUserId == 0 or followingUserId ~= followingUserId or not followingUserId then
            return nil
        end
        
        return playersService:GetPlayerByUserId(followingUserId)
    end
    
    local function moveSlimeToPlayer(slimeId, targetPlayer)
        if not targetPlayer then return false end
        
        pcall(function()
            game:GetService("ReplicatedStorage")
                :WaitForChild("events-@easy-games/game-core:shared/game-core-networking@getEvents.Events")
                :WaitForChild("useAbility")
                :FireServer("SLIME_DIRECT")
            
            task.wait(0.05)
            
            game:GetService("ReplicatedStorage")
                :WaitForChild("rbxts_include")
                :WaitForChild("node_modules")
                :WaitForChild("@rbxts")
                :WaitForChild("net")
                :WaitForChild("out")
                :WaitForChild("_NetManaged")
                :WaitForChild("RequestMoveSlime")
                :InvokeServer({
                    slimeId = slimeId,
                    targetPlayerUserId = targetPlayer.UserId
                })
        end)
        
        return true
    end
    
    local function retractSlimeToSelf(slimeId)
        pcall(function()
            game:GetService("ReplicatedStorage")
                :WaitForChild("events-@easy-games/game-core:shared/game-core-networking@getEvents.Events")
                :WaitForChild("useAbility")
                :FireServer("SLIME_DIRECT")
            
            task.wait(0.05)
            
            game:GetService("ReplicatedStorage")
                :WaitForChild("rbxts_include")
                :WaitForChild("node_modules")
                :WaitForChild("@rbxts")
                :WaitForChild("net")
                :WaitForChild("out")
                :WaitForChild("_NetManaged")
                :WaitForChild("RequestMoveSlime")
                :InvokeServer({
                    slimeId = slimeId,
                    targetPlayerUserId = lplr.UserId
                })
        end)
    end
    
    local function manageSlimeType(slimeType, targetDropdown)
        local targetName = targetDropdown.Value
        
        local mySlimes = getMySlimes()
        local slimesOfType = mySlimes[slimeType]
        
        if not slimesOfType or #slimesOfType == 0 then
            return
        end
        
        if targetName == "None" or targetName == "" then
            for _, slimeInfo in ipairs(slimesOfType) do
                local currentTarget = getSlimeCurrentTarget(slimeInfo.data)
                
                if currentTarget and currentTarget ~= lplr then
                    retractSlimeToSelf(slimeInfo.id)
                    task.wait(0.15)
                end
            end
            return
        end
        
        local targetPlayer = playersService:FindFirstChild(targetName)
        if not targetPlayer then
            return
        end
        
        if not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            return
        end
        
        for _, slimeInfo in ipairs(slimesOfType) do
            local currentTarget = getSlimeCurrentTarget(slimeInfo.data)
            
            if currentTarget ~= targetPlayer then
                moveSlimeToPlayer(slimeInfo.id, targetPlayer)
                task.wait(0.15)
            end
        end
    end
    
    local function startSlimeManagement()
        if slimeCheckThread then
            task.cancel(slimeCheckThread)
            slimeCheckThread = nil
        end
        
        running = true
        slimeCheckThread = task.spawn(function()
            while running and AutoNoelle.Enabled do
                if HealSlimeToggle.Enabled then
                    manageSlimeType(SLIME_TYPES.HEALING, HealSlimeDropdown)
                end
                
                if VoidSlimeToggle.Enabled then
                    manageSlimeType(SLIME_TYPES.VOID, VoidSlimeDropdown)
                end
                
                if StickySlimeToggle.Enabled then
                    manageSlimeType(SLIME_TYPES.STICKY, StickySlimeDropdown)
                end
                
                if FrostySlimeToggle.Enabled then
                    manageSlimeType(SLIME_TYPES.FROSTY, FrostySlimeDropdown)
                end
                
                task.wait(1.5)
            end
            slimeCheckThread = nil
        end)
    end
    
    local function stopSlimeManagement()
        running = false
        if slimeCheckThread then
            task.cancel(slimeCheckThread)
            slimeCheckThread = nil
        end
    end
    
    AutoNoelle = vape.Categories.Kits:CreateModule({
        Name = "AutoNoelle",
        Function = function(callback)
            running = callback
            
            if callback then
                startSlimeManagement()
                
                AutoNoelle:Clean(playersService.PlayerAdded:Connect(function()
                    task.wait(0.5)
                    local newList = getTeammateList()
                    if HealSlimeDropdown then HealSlimeDropdown:Change(newList) end
                    if VoidSlimeDropdown then VoidSlimeDropdown:Change(newList) end
                    if StickySlimeDropdown then StickySlimeDropdown:Change(newList) end
                    if FrostySlimeDropdown then FrostySlimeDropdown:Change(newList) end
                end))
                
                AutoNoelle:Clean(playersService.PlayerRemoving:Connect(function()
                    task.wait(0.5)
                    local newList = getTeammateList()
                    if HealSlimeDropdown then HealSlimeDropdown:Change(newList) end
                    if VoidSlimeDropdown then VoidSlimeDropdown:Change(newList) end
                    if StickySlimeDropdown then StickySlimeDropdown:Change(newList) end
                    if FrostySlimeDropdown then FrostySlimeDropdown:Change(newList) end
                end))
                
                AutoNoelle:Clean(lplr:GetAttributeChangedSignal('Team'):Connect(function()
                    task.wait(1)
                    local newList = getTeammateList()
                    if HealSlimeDropdown then HealSlimeDropdown:Change(newList) end
                    if VoidSlimeDropdown then VoidSlimeDropdown:Change(newList) end
                    if StickySlimeDropdown then StickySlimeDropdown:Change(newList) end
                    if FrostySlimeDropdown then FrostySlimeDropdown:Change(newList) end
                end))
            else
                stopSlimeManagement()
            end
        end,
        Tooltip = "Automatically manages slimes to follow specific teammates"
    })
    
    HealSlimeToggle = AutoNoelle:CreateToggle({
        Name = "Heal Slime",
        Default = false,
        Tooltip = "Assign heal slime to teammate",
        Function = function(callback)
            if HealSlimeDropdown and HealSlimeDropdown.Object then
                HealSlimeDropdown.Object.Visible = callback
            end
            if HealSlimeRefresh and HealSlimeRefresh.Object then
                HealSlimeRefresh.Object.Visible = callback
            end
            
            if callback and AutoNoelle.Enabled then
                startSlimeManagement()
            end
        end
    })
    
    HealSlimeDropdown = AutoNoelle:CreateDropdown({
        Name = "Heal Target",
        List = getTeammateList(),
        Function = function(val)
        end,
        Tooltip = "Select teammate for heal slime"
    })
    
    HealSlimeRefresh = AutoNoelle:CreateButton({
        Name = "Refresh Heal List",
        Function = function()
            task.spawn(function()
                local newList = getTeammateList()
                
                if HealSlimeDropdown then
                    pcall(function()
                        HealSlimeDropdown:Change(newList)
                        
                        if #newList > 0 then
                            if not HealSlimeDropdown.Value or HealSlimeDropdown.Value == "" or not table.find(newList, HealSlimeDropdown.Value) then
                                HealSlimeDropdown:SetValue(newList[1])
                            else
                                HealSlimeDropdown:SetValue(HealSlimeDropdown.Value)
                            end
                        end
                    end)
                end
                
                notif("Auto Noelle", string.format("Refreshed heal list (%d teammates)", #newList - 1), 2)
            end)
        end,
        Tooltip = "Manually refresh heal teammate list"
    })
    
    VoidSlimeToggle = AutoNoelle:CreateToggle({
        Name = "Damage Slime",
        Default = false,
        Tooltip = "Assign Damage slime to teammate",
        Function = function(callback)
            if VoidSlimeDropdown and VoidSlimeDropdown.Object then
                VoidSlimeDropdown.Object.Visible = callback
            end
            if VoidSlimeRefresh and VoidSlimeRefresh.Object then
                VoidSlimeRefresh.Object.Visible = callback
            end
            
            if callback and AutoNoelle.Enabled then
                startSlimeManagement()
            end
        end
    })
    
    VoidSlimeDropdown = AutoNoelle:CreateDropdown({
        Name = "Damage Target",
        List = getTeammateList(),
        Function = function(val)
        end,
        Tooltip = "Select teammate for Damage slime"
    })
    
    VoidSlimeRefresh = AutoNoelle:CreateButton({
        Name = "Refresh Damage List",
        Function = function()
            task.spawn(function()
                local newList = getTeammateList()
                
                if VoidSlimeDropdown then
                    pcall(function()
                        VoidSlimeDropdown:Change(newList)
                        
                        if #newList > 0 then
                            if not VoidSlimeDropdown.Value or VoidSlimeDropdown.Value == "" or not table.find(newList, VoidSlimeDropdown.Value) then
                                VoidSlimeDropdown:SetValue(newList[1])
                            else
                                VoidSlimeDropdown:SetValue(VoidSlimeDropdown.Value)
                            end
                        end
                    end)
                end
                
                notif("Auto Noelle", string.format("Refreshed Damage list (%d teammates)", #newList - 1), 2)
            end)
        end,
        Tooltip = "Manually refresh Damage teammate list"
    })
    
    StickySlimeToggle = AutoNoelle:CreateToggle({
        Name = "Cycle Slime",
        Default = false,
        Tooltip = "Assign cycle slime to teammate",
        Function = function(callback)
            if StickySlimeDropdown and StickySlimeDropdown.Object then
                StickySlimeDropdown.Object.Visible = callback
            end
            if StickySlimeRefresh and StickySlimeRefresh.Object then
                StickySlimeRefresh.Object.Visible = callback
            end
            
            if callback and AutoNoelle.Enabled then
                startSlimeManagement()
            end
        end
    })
    
    StickySlimeDropdown = AutoNoelle:CreateDropdown({
        Name = "Cycle Target",
        List = getTeammateList(),
        Function = function(val)
        end,
        Tooltip = "Select teammate for cycle slime"
    })
    
    StickySlimeRefresh = AutoNoelle:CreateButton({
        Name = "Refresh Cycle List",
        Function = function()
            task.spawn(function()
                local newList = getTeammateList()
                
                if StickySlimeDropdown then
                    pcall(function()
                        StickySlimeDropdown:Change(newList)
                        
                        if #newList > 0 then
                            if not StickySlimeDropdown.Value or StickySlimeDropdown.Value == "" or not table.find(newList, StickySlimeDropdown.Value) then
                                StickySlimeDropdown:SetValue(newList[1])
                            else
                                StickySlimeDropdown:SetValue(StickySlimeDropdown.Value)
                            end
                        end
                    end)
                end
                
                notif("Auto Noelle", string.format("Refreshed Cycle list (%d teammates)", #newList - 1), 2)
            end)
        end,
        Tooltip = "Manually refresh Cycle teammate list"
    })
    
    FrostySlimeToggle = AutoNoelle:CreateToggle({
        Name = "Slow Slime",
        Default = false,
        Tooltip = "Assign Slow slime to teammate",
        Function = function(callback)
            if FrostySlimeDropdown and FrostySlimeDropdown.Object then
                FrostySlimeDropdown.Object.Visible = callback
            end
            if FrostySlimeRefresh and FrostySlimeRefresh.Object then
                FrostySlimeRefresh.Object.Visible = callback
            end
            
            if callback and AutoNoelle.Enabled then
                startSlimeManagement()
            end
        end
    })
    
    FrostySlimeDropdown = AutoNoelle:CreateDropdown({
        Name = "Slow Target",
        List = getTeammateList(),
        Function = function(val)
        end,
        Tooltip = "Select teammate for slow slime"
    })
    
    FrostySlimeRefresh = AutoNoelle:CreateButton({
        Name = "Refresh Slow List",
        Function = function()
            task.spawn(function()
                local newList = getTeammateList()
                
                if FrostySlimeDropdown then
                    pcall(function()
                        FrostySlimeDropdown:Change(newList)
                        
                        if #newList > 0 then
                            if not FrostySlimeDropdown.Value or FrostySlimeDropdown.Value == "" or not table.find(newList, FrostySlimeDropdown.Value) then
                                FrostySlimeDropdown:SetValue(newList[1])
                            else
                                FrostySlimeDropdown:SetValue(FrostySlimeDropdown.Value)
                            end
                        end
                    end)
                end
                
                notif("Auto Noelle", string.format("Refreshed slow list (%d teammates)", #newList - 1), 2)
            end)
        end,
        Tooltip = "Manually refresh slow teammate list"
    })
end)

run(function()
	local FrameBuffer
	local Latency
	local Rate
	
	local defaultFFlags = {
		DFIntDebugDefaultTargetWorldStepsPerFrame = nil,
		DFIntMaxMissedWorldStepsRemembered = nil,
		DFIntWorldStepsOffsetAdjustRate = nil,
		DFIntDebugSendDistInSteps = nil,
		DFIntWorldStepMax = nil,
		DFIntWarpFactor = nil
	}
	
	local function captureDefaults()
		for name, _ in pairs(defaultFFlags) do
			local suc, val = pcall(function()
				return getfflag(name)
			end)
			if suc then
				defaultFFlags[name] = val
			end
		end
	end
	captureDefaults()
	
	local function restoreFFlags()
		for name, val in pairs(defaultFFlags) do
			if val then
				pcall(function()
					setfflag(name, val)
				end)
			end
		end
	end
	
	local function applyFFlags(latencyMs, rate)
		rate = math.max(rate, 1)
		local latency = latencyMs
		if latency <= 1 then
			latency = 1.5
		end
		
		local OG = -2147483648
		local NEW = OG * (latency / 1000)
		local NEW2 = NEW * -1
		local str = tostring(NEW)
		local str2 = tostring(NEW2)
		
		pcall(function() setfflag('DFIntDebugDefaultTargetWorldStepsPerFrame', str) end)
		pcall(function() setfflag('DFIntMaxMissedWorldStepsRemembered', str) end)
		pcall(function() setfflag('DFIntWorldStepsOffsetAdjustRate', str2) end)
		pcall(function() setfflag('DFIntDebugSendDistInSteps', str) end)
		pcall(function() setfflag('DFIntWorldStepMax', str) end)
		pcall(function() setfflag('DFIntWarpFactor', str2) end)
	end
	
	FrameBuffer = vape.Categories.Blatant:CreateModule({
		Name = 'FrameBuffer',
		Function = function(callback)
			if callback then
				repeat
					applyFFlags(Latency.Value, Rate.Value)
					task.wait(1 / math.max(Rate.Value, 1))
				until not FrameBuffer.Enabled
				
				restoreFFlags()
			end
		end,
	})
	
	Latency = FrameBuffer:CreateSlider({
		Name = "Latency",
		Min = 0,
		Max = 1000,
		Default = 250,
		Suffix = 'ms'
	})
	
	Rate = FrameBuffer:CreateSlider({
		Name = "Rate",
		Min = 1,
		Max = 360,
		Default = 60,
		Suffix = 'hz'
	})
end)

run(function()
    local AnimChopper
    local ChoppyMode
    local TestOnSelf
    local originalAnimationSpeeds = {}
    local trackedAnimationTracks = {}
    
    local swordAnimationIds = {
        ["rbxassetid://4947108314"] = true,  
        ["rbxassetid://10218627926"] = true, 
        ["rbxassetid://10218629442"] = true, 
        ["rbxassetid://10214626638"] = true, 
        ["rbxassetid://8089691925"] = true,  
    }
    
    local function isSwordAnimation(animationId)
        local normalizedId = string.lower(tostring(animationId))
        
        for id, _ in pairs(swordAnimationIds) do
            if string.find(normalizedId, string.lower(id)) then
                return true
            end
        end
        
        return false
    end
    
    local function setAnimationChoppiness(character, mode)
        if not character then return end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end
        
        local animator = humanoid:FindFirstChildOfClass("Animator")
        if not animator then return end

        local tracks = animator:GetPlayingAnimationTracks()
        
        for _, track in pairs(tracks) do
            if track.Animation and isSwordAnimation(track.Animation.AnimationId) then
                if not originalAnimationSpeeds[track] then
                    originalAnimationSpeeds[track] = track.Speed or 1
                end
                
                if mode == "Choppy" then
                    pcall(function()
                        track:AdjustSpeed(2)
                    end)
                elseif mode == "Very Choppy" then
                    pcall(function()
                        track:AdjustSpeed(3)
                    end)
                elseif mode == "No Animation" then
                    pcall(function()
                        track:Stop()
                    end)
                else
                    pcall(function()
                        track:AdjustSpeed(originalAnimationSpeeds[track] or 1)
                    end)
                end
                
                trackedAnimationTracks[track] = true
            end
        end
    end
    
    local function applyToAllPlayers(mode)
        for _, player in pairs(game.Players:GetPlayers()) do
            if player ~= lplr or TestOnSelf.Enabled then
                if player.Character then
                    setAnimationChoppiness(player.Character, mode)
                end
            end
        end
    end
    
    local function restoreAllAnimations()
        for track, _ in pairs(trackedAnimationTracks) do
            if track then
                pcall(function()
                    local originalSpeed = originalAnimationSpeeds[track] or 1
                    track:AdjustSpeed(originalSpeed)
                end)
            end
        end
        originalAnimationSpeeds = {}
        trackedAnimationTracks = {}
    end
    
    AnimChopper = vape.Categories.Render:CreateModule({
        Name = 'AnimChopper',
        Function = function(callback)
            if callback then
                applyToAllPlayers(ChoppyMode.Value)
                
                AnimChopper:Clean(runService.Heartbeat:Connect(function()
                    if AnimChopper.Enabled then
                        applyToAllPlayers(ChoppyMode.Value)
                    end
                end))
                
                AnimChopper:Clean(game.Players.PlayerAdded:Connect(function(player)
                    if AnimChopper.Enabled and (player ~= lplr or TestOnSelf.Enabled) then
                        player.CharacterAdded:Connect(function(character)
                            task.wait(0.5) 
                            if AnimChopper.Enabled then
                                setAnimationChoppiness(character, ChoppyMode.Value)
                            end
                        end)
                    end
                end))
                
                for _, player in pairs(game.Players:GetPlayers()) do
                    if (player ~= lplr or TestOnSelf.Enabled) and player.Character then
                        AnimChopper:Clean(player.CharacterAdded:Connect(function(character)
                            task.wait(0.5)
                            if AnimChopper.Enabled then
                                setAnimationChoppiness(character, ChoppyMode.Value)
                            end
                        end))
                    end
                end
            else
                restoreAllAnimations()
            end
        end,
        Tooltip = 'Makes sword swing animations choppy (for you and others)'
    })
    
    ChoppyMode = AnimChopper:CreateDropdown({
        Name = 'Mode',
        List = {'Choppy', 'Very Choppy', 'No Animation'},
        Default = 'Choppy',
        Tooltip = 'Choppy: 2x speed\nVery Choppy: 3x speed\nNo Animation: Disables sword animations',
        Function = function(value)
            if AnimChopper.Enabled then
                restoreAllAnimations()
                applyToAllPlayers(value)
            end
        end
    })
    
    TestOnSelf = AnimChopper:CreateToggle({
        Name = 'Test On Self',
        Default = true,
        Tooltip = 'Apply choppy sword animations to yourself (for testing)',
        Function = function(callback)
            if AnimChopper.Enabled then
                if callback then
                    if lplr.Character then
                        setAnimationChoppiness(lplr.Character, ChoppyMode.Value)
                    end
                else
                    if lplr.Character then
                        setAnimationChoppiness(lplr.Character, "Normal")
                    end
                end
            end
        end
    })
end)

run(function()
	local LayeredClothing
	local desc
	local myUserId = lplr.UserId
	local activeConnection = nil
	local isRunning = false

	local function itemAdded(v, manual)
		if (not v:GetAttribute('LayeredClothing')) and (
			(v:IsA('Accessory') and (not v:GetAttribute('InvItem')) and (not v:GetAttribute('ArmorSlot')))
			or v:IsA('ShirtGraphic') or v:IsA('Shirt') or v:IsA('Pants') or v:IsA('BodyColors') or manual
		) then
			repeat
				task.wait()
				v.Parent = game
			until v.Parent == game
			v:ClearAllChildren()
			v:Destroy()
		end
	end

	local function disconnectActive()
		if activeConnection then
			activeConnection:Disconnect()
			activeConnection = nil
		end
	end

	local function cleanup()
		disconnectActive()
		if desc then
			desc:Destroy()
			desc = nil
		end
	end

	local function characterAdded(char)
		if not LayeredClothing.Enabled then return end
		if not char then return end

		disconnectActive()

		task.wait(0.1)

		char.Archivable = true
		local clone = char:Clone()
		clone.Parent = game

		local fetchedDesc = nil
		repeat
			if pcall(function()
				fetchedDesc = playersService:GetHumanoidDescriptionFromUserId(myUserId)
			end) and fetchedDesc then break end
			task.wait(1)
		until not LayeredClothing.Enabled

		if not LayeredClothing.Enabled or not fetchedDesc then
			clone:ClearAllChildren()
			clone:Destroy()
			return
		end

		local humanoid = char:FindFirstChildOfClass('Humanoid')
		local originalDesc = humanoid and humanoid:FindFirstChildOfClass('HumanoidDescription')
		if originalDesc then
			fetchedDesc.JumpAnimation = originalDesc.JumpAnimation
			fetchedDesc.HeightScale = originalDesc.HeightScale
		end

		for _, v in ipairs(clone:GetChildren()) do
			if v:IsA('Accessory') or v:IsA('ShirtGraphic') or v:IsA('Shirt') or v:IsA('Pants') then
				v:ClearAllChildren()
				v:Destroy()
			end
		end

		local cloneHumanoid = clone:FindFirstChildOfClass('Humanoid')
		if cloneHumanoid then
			cloneHumanoid:ApplyDescriptionClientServer(fetchedDesc)
		end

		for _, v in ipairs(char:GetChildren()) do
			itemAdded(v)
		end

		activeConnection = char.ChildAdded:Connect(itemAdded)

		local animateClone = clone:FindFirstChild('Animate')
		local animateReal = char:FindFirstChild('Animate')
		if animateClone and animateReal then
			for _, v in ipairs(animateClone:GetChildren()) do
				local real = animateReal:FindFirstChild(v.Name)
				if real then
					local anim = v:FindFirstChildWhichIsA('Animation')
					local realanim = real:FindFirstChildWhichIsA('Animation')
					if anim and realanim then
						realanim.AnimationId = anim.AnimationId
					end
				end
			end
		end

		local head = char:FindFirstChild('Head')
		for _, v in ipairs(clone:GetChildren()) do
			v:SetAttribute('LayeredClothing', true)
			if v:IsA('Accessory') then
				for _, v2 in ipairs(v:GetDescendants()) do
					if v2:IsA('Weld') and v2.Part1 then
						local part = char:FindFirstChild(v2.Part1.Name)
						if part then v2.Part1 = part end
					end
				end
				v.Parent = char
			elseif v:IsA('ShirtGraphic') or v:IsA('Shirt') or v:IsA('Pants') or v:IsA('BodyColors') then
				v.Parent = char
			elseif head and v.Name == 'Head' and head:IsA('MeshPart') and not head:FindFirstChild('FaceControls') then
				head.MeshId = v.MeshId
			end
		end

		local localface = char:FindFirstChild('face', true)
		local cloneface = clone:FindFirstChild('face', true)
		if localface and cloneface then
			itemAdded(localface, true)
			if head then
				cloneface.Parent = head
			end
		end

		if originalDesc then
			pcall(function()
				originalDesc:SetEmotes(fetchedDesc:GetEmotes())
				originalDesc:SetEquippedEmotes(fetchedDesc:GetEquippedEmotes())
			end)
		end

		task.wait(0.5)
		clone:ClearAllChildren()
		clone:Destroy()
		fetchedDesc:Destroy()
	end

	LayeredClothing = vape.Categories.Render:CreateModule({
		Name = 'LayeredClothing',
		Function = function(callback)
			if callback then
				LayeredClothing:Clean(entitylib.Events.LocalAdded:Connect(characterAdded))
				if entitylib.isAlive then
					characterAdded(entitylib.character)
				end
			else
				cleanup()
			end
		end,
		Tooltip = 'Applies layered clothing from your Roblox avatar, client-sided. Persists through death.'
	})
end)

run(function()
	local CannonReskin
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local LocalPlayer = Players.LocalPlayer
	
	local CANNON_SKINS = {
		Nightmare = "cannon_nightmare_victorious",
		Diamond = "cannon_diamond_victorious",
		Emerald = "cannon_emerald_victorious"
	}
	
	local CANNON_SOUNDS = {
		Nightmare = "CANNON_FIRE_VICTORIOUS_NIGHTMARE",
		Diamond = "CANNON_FIRE_VICTORIOUS_DIAMOND",
		Emerald = "CANNON_FIRE_VICTORIOUS_EMERALD"
	}
	
	local CURRENT_SKIN = "Nightmare"
	
	local hooked = false
	local oldFire
	local oldLaunch
	
	local function getReskinSource()
		return game.ReplicatedStorage
			:WaitForChild("Assets")
			:WaitForChild("Blocks")
			:WaitForChild(CANNON_SKINS[CURRENT_SKIN])
	end
	
	local TARGET_NAME = "cannon"
	
	local OFFSET_HELD = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
	local OFFSET_PLACED = CFrame.new(0, -2.0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
	
	local tagged = setmetatable({}, { __mode = "k" })
	local connections = {}
	local renderConnections = {}
	
	local function firstBasePart(root)
		for _, d in ipairs(root:GetDescendants()) do
			if d:IsA("BasePart") then
				return d
			end
		end
		return nil
	end
	
	local function makeLocalInvisible(root)
		for _, d in ipairs(root:GetDescendants()) do
			if d:IsA("BasePart") then
				d.LocalTransparencyModifier = 1
				d.Transparency = 1
			elseif d:IsA("Decal") or d:IsA("Texture") then
				d.Transparency = 1
			end
		end
	end
	
	local function restoreVisibility(root)
		for _, d in ipairs(root:GetDescendants()) do
			if d:IsA("BasePart") then
				d.LocalTransparencyModifier = 0
				d.Transparency = 0
			elseif d:IsA("Decal") or d:IsA("Texture") then
				d.Transparency = 0
			end
		end
	end
	
	local function setNoCollide(model)
		for _, d in ipairs(model:GetDescendants()) do
			if d:IsA("BasePart") then
				d.CanCollide = false
				d.CanTouch = false
				d.CanQuery = false
				d.Massless = true
				d.Anchored = false
			end
		end
	end
	
	local function weldAllToPrimary(model)
		local primary = model.PrimaryPart
		if not primary then return end
		
		for _, d in ipairs(model:GetDescendants()) do
			if d:IsA("BasePart") and d ~= primary then
				local wc = Instance.new("WeldConstraint")
				wc.Part0 = primary
				wc.Part1 = d
				wc.Parent = primary
			end
		end
	end
	
	local function weldModelToPart(model, targetPart)
		if not model.PrimaryPart then
			local p = firstBasePart(model)
			if p then
				pcall(function() model.PrimaryPart = p end)
			end
		end
		if not model.PrimaryPart then return false end
		
		setNoCollide(model)
		
		pcall(function()
			model:PivotTo(targetPart.CFrame * OFFSET_HELD)
		end)
		
		weldAllToPrimary(model)
		
		local wc = Instance.new("WeldConstraint")
		wc.Part0 = targetPart
		wc.Part1 = model.PrimaryPart
		wc.Parent = model.PrimaryPart
		
		return true
	end
	
	local function attachReskinTo(targetRoot, offset)
		if not targetRoot or tagged[targetRoot] then return end
		tagged[targetRoot] = true
		
		local targetPart = targetRoot:FindFirstChild("Handle")
		if not (targetPart and targetPart:IsA("BasePart")) then
			targetPart = firstBasePart(targetRoot)
		end
		if not targetPart then
			tagged[targetRoot] = nil
			return
		end
		
		makeLocalInvisible(targetRoot)
		
		local RESKIN_SOURCE = getReskinSource()
		local clone = RESKIN_SOURCE:Clone()
		clone.Name = "LOCAL_CANNON_RESKIN"
		
		if clone:IsA("Model") then
			if not clone.PrimaryPart then
				local p = firstBasePart(clone)
				if p then
					pcall(function() clone.PrimaryPart = p end)
				end
			end
			if not clone.PrimaryPart then
				clone:Destroy()
				tagged[targetRoot] = nil
				return
			end
			
			setNoCollide(clone)
			clone.Parent = targetRoot
			
			pcall(function()
				clone:PivotTo(targetPart.CFrame * offset)
			end)
			
			weldAllToPrimary(clone)
			
			local wcMain = Instance.new("WeldConstraint")
			wcMain.Part0 = targetPart
			wcMain.Part1 = clone.PrimaryPart
			wcMain.Parent = clone.PrimaryPart
		else
			clone.Parent = targetRoot
		end
	end
	
	local function hookViewmodel()
		local cam = workspace.CurrentCamera
		if not cam then return end
		
		local function hookVM(vm)
			for _, child in ipairs(vm:GetChildren()) do
				if child.Name == TARGET_NAME then
					attachReskinTo(child, OFFSET_HELD)
				end
			end
			
			local conn = vm.ChildAdded:Connect(function(child)
				if child.Name == TARGET_NAME then
					task.wait()
					attachReskinTo(child, OFFSET_HELD)
				end
			end)
			table.insert(connections, conn)
		end
		
		local vm = cam:FindFirstChild("Viewmodel")
		if vm then hookVM(vm) end
		
		local conn = cam.ChildAdded:Connect(function(child)
			if child.Name == "Viewmodel" then
				task.wait()
				hookVM(child)
			end
		end)
		table.insert(connections, conn)
	end
	
	local function hookThirdPersonInHand(character)
		local function onChildAdded(child)
			if child:IsA("Tool") and child.Name == TARGET_NAME then
				task.wait()
				
				local handle = child:FindFirstChild("Handle")
				if not (handle and handle:IsA("BasePart")) then
					handle = firstBasePart(child)
				end
				if not handle then return end
				
				local existing = child:FindFirstChild("LOCAL_CANNON_RESKIN")
				if existing then
					existing:Destroy()
				end
				
				local RESKIN_SOURCE = getReskinSource()
				local reskin = RESKIN_SOURCE:Clone()
				reskin.Name = "LOCAL_CANNON_RESKIN"
				reskin.Parent = child
				
				if reskin:IsA("Model") then
					weldModelToPart(reskin, handle)
				end
				
				local start = time()
				local conn
				conn = RunService.RenderStepped:Connect(function()
					if not child.Parent then
						conn:Disconnect()
						return
					end
					
					makeLocalInvisible(child)
					
					if reskin and reskin.Parent and reskin:IsA("Model") and reskin.PrimaryPart then
						pcall(function()
							reskin:PivotTo(handle.CFrame * OFFSET_HELD)
						end)
					end
					
					if time() - start > 2 then
						conn:Disconnect()
					end
				end)
				table.insert(renderConnections, conn)
			end
		end
		
		for _, c in ipairs(character:GetChildren()) do
			onChildAdded(c)
		end
		
		local conn = character.ChildAdded:Connect(onChildAdded)
		table.insert(connections, conn)
	end
	
	local function hookTools(container)
		for _, child in ipairs(container:GetChildren()) do
			if child:IsA("Tool") and child.Name == TARGET_NAME then
				attachReskinTo(child, OFFSET_HELD)
			end
		end
		
		local conn = container.ChildAdded:Connect(function(child)
			if child:IsA("Tool") and child.Name == TARGET_NAME then
				task.wait()
				attachReskinTo(child, OFFSET_HELD)
			end
		end)
		table.insert(connections, conn)
	end
	
	local function hookBlocksFolder(blocksFolder)
		for _, child in ipairs(blocksFolder:GetChildren()) do
			if child.Name == TARGET_NAME then
				attachReskinTo(child, OFFSET_PLACED)
			end
		end
		
		local conn = blocksFolder.ChildAdded:Connect(function(child)
			if child.Name == TARGET_NAME then
				task.wait()
				attachReskinTo(child, OFFSET_PLACED)
				task.wait()
				local skin = child:FindFirstChild("LOCAL_CANNON_RESKIN")
				if not (skin and skin:IsA("Model") and skin.PrimaryPart) then return end
				local baseCF = skin.PrimaryPart.CFrame
				local y = baseCF.Position.Y
				local snappedY = math.floor(y)
				local KUSH = snappedY - 1
				local New = KUSH + 0.99
				skin:PivotTo(CFrame.new(Vector3.new(baseCF.Position.X, New, baseCF.Position.Z)))
			end
		end)
		table.insert(connections, conn)
	end
	
	local function hookAllWorldBlocks()
		local map = workspace:FindFirstChild("Map")
		if not map then return end
		
		local worlds = map:FindFirstChild("Worlds")
		if not worlds then return end
		
		for _, world in ipairs(worlds:GetChildren()) do
			local blocks = world:FindFirstChild("Blocks")
			if blocks then
				hookBlocksFolder(blocks)
			end
		end
		
		local conn = worlds.ChildAdded:Connect(function(world)
			task.wait()
			local blocks = world:FindFirstChild("Blocks")
			if blocks then
				hookBlocksFolder(blocks)
			end
		end)
		table.insert(connections, conn)
	end
	
	local function onCharacterAdded(character)
		task.wait(0.2)
		hookTools(LocalPlayer.Backpack)
		hookTools(character)
		hookThirdPersonInHand(character)
	end
	
	local function hookSounds()
		if hooked then return end
		hooked = true
		
		oldFire = bedwars.CannonHandController.fireCannon
		oldLaunch = bedwars.CannonHandController.launchSelf
		
		bedwars.CannonHandController.fireCannon = function(...)
			for _, v in ipairs(workspace.SoundPool:GetChildren()) do
				if v:IsA("Sound") and v.SoundId == "rbxassetid://7121064180" then
					v:Destroy()
				end
			end
			
			bedwars.SoundManager:playSound(bedwars.SoundList[CANNON_SOUNDS[CURRENT_SKIN]])
			return oldFire(...)
		end
		
		bedwars.CannonHandController.launchSelf = function(...)
			for _, v in ipairs(workspace.SoundPool:GetChildren()) do
				if v:IsA("Sound") and v.SoundId == "rbxassetid://7121064180" then
					v:Destroy()
				end
			end
			
			bedwars.SoundManager:playSound(bedwars.SoundList[CANNON_SOUNDS[CURRENT_SKIN]])
			return oldLaunch(...)
		end
	end
	
	local function unhookSounds()
		if hooked then
			bedwars.CannonHandController.fireCannon = oldFire
			bedwars.CannonHandController.launchSelf = oldLaunch
			oldFire = nil
			oldLaunch = nil
			hooked = false
		end
	end
	
	local function cleanup()
		for _, conn in pairs(connections) do
			pcall(function() conn:Disconnect() end)
		end
		for _, conn in pairs(renderConnections) do
			pcall(function() conn:Disconnect() end)
		end
		table.clear(connections)
		table.clear(renderConnections)
		
		for targetRoot, _ in pairs(tagged) do
			if targetRoot and targetRoot.Parent then
				local reskin = targetRoot:FindFirstChild("LOCAL_CANNON_RESKIN")
				if reskin then
					reskin:Destroy()
				end
				restoreVisibility(targetRoot)
			end
		end
		table.clear(tagged)
		
		local map = workspace:FindFirstChild("Map")
		if map then
			local worlds = map:FindFirstChild("Worlds")
			if worlds then
				for _, world in ipairs(worlds:GetChildren()) do
					local blocks = world:FindFirstChild("Blocks")
					if blocks then
						for _, child in ipairs(blocks:GetChildren()) do
							if child.Name == TARGET_NAME then
								local reskin = child:FindFirstChild("LOCAL_CANNON_RESKIN")
								if reskin then
									reskin:Destroy()
								end
								restoreVisibility(child)
							end
						end
					end
				end
			end
		end
		
		unhookSounds()
	end
	
	CannonReskin = vape.Categories.Render:CreateModule({
		Name = 'CannonReskin',
		Function = function(callback)
			if callback then		
				hookViewmodel()
				hookAllWorldBlocks()
				hookSounds()
				
				if LocalPlayer.Character then
					onCharacterAdded(LocalPlayer.Character)
				end
				
				local charConn = LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
				table.insert(connections, charConn)
			else
				cleanup()
			end
		end,
		Tooltip = 'Reskins cannons with victorious skins (credit to soryed and koli for help!)'
	})
	
	local SkinMode = CannonReskin:CreateDropdown({
		Name = 'Skin',
		List = {'Nightmare', 'Diamond', 'Emerald'},
		Function = function(val)
			CURRENT_SKIN = val
			if CannonReskin.Enabled then
				CannonReskin:Toggle()
				CannonReskin:Toggle()
			end
		end
	})
end)

run(function()
    local Kaliyah
    local AutoPunch
    local RangeSlider
    local PunchDelay
    local DelaySlider
    local NoSlow
    local punchActive = false
    local punchDebounce = {}

    local function getKaliyahTargets()
        local targets = {}
        if not entitylib.isAlive then return targets end
        
        local localPosition = entitylib.character.RootPart.Position
        local range = RangeSlider.Value
        
        for _, v in collectionService:GetTagged('KaliyahPunchInteraction') do
            if v:IsA("Model") and v.PrimaryPart then
                local distance = (localPosition - v.PrimaryPart.Position).Magnitude
                if distance <= range then
                    table.insert(targets, v)
                end
            end
        end
        
        return targets
    end

    local function punchTarget(target)
        local targetId = target:GetAttribute('Id') or tostring(target)
        
        if punchDebounce[targetId] then return false end
        punchDebounce[targetId] = true
        
        local character = lplr.Character
        if not character or not character.PrimaryPart then 
            punchDebounce[targetId] = nil
            return false 
        end
        
        pcall(function()
            bedwars.DragonSlayerController:deleteEmblem(target)
        end)
        
        local playerPos = character:GetPrimaryPartCFrame().Position
        local targetPos = target:GetPrimaryPartCFrame().Position * Vector3.new(1, 0, 1) + Vector3.new(0, playerPos.Y, 0)
        local lookAtCFrame = CFrame.new(playerPos, targetPos)
        
        character:PivotTo(lookAtCFrame)
        
        pcall(function()
            bedwars.DragonSlayerController:playPunchAnimation(lookAtCFrame - lookAtCFrame.Position)
        end)
        
        local success = pcall(function()
            bedwars.Client:Get("RequestDragonPunch"):SendToServer({
                target = target
            })
        end)
        
        task.delay(3, function()
            punchDebounce[targetId] = nil
        end)
        
        return success
    end

    local function startAutoPunch()
        if punchActive then return end
        punchActive = true
        
        task.spawn(function()
            while Kaliyah.Enabled and AutoPunch.Enabled and punchActive do
                if not entitylib.isAlive then 
                    task.wait(0.5)
                    continue 
                end
                
                local targets = getKaliyahTargets()
                local punchedThisCycle = false
                
                for _, target in targets do
                    if not Kaliyah.Enabled or not AutoPunch.Enabled or not punchActive then 
                        break 
                    end
                    
                    if PunchDelay.Enabled and DelaySlider.Value > 0 then
                        task.wait(DelaySlider.Value)
                    end
                    
                    if punchTarget(target) then
                        punchedThisCycle = true
                        task.wait(0.2)
                    end
                end
                
                task.wait(punchedThisCycle and 0.5 or 0.3)
            end
            
            punchActive = false
        end)
    end

    local function stopAutoPunch()
        punchActive = false
        table.clear(punchDebounce)
    end

    local originalPlayPunchAnimation
    local function hookNoSlow()
        if not bedwars.DragonSlayerController then return end
        
        originalPlayPunchAnimation = bedwars.DragonSlayerController.playPunchAnimation
        
        bedwars.DragonSlayerController.playPunchAnimation = function(self, arg2)
            if NoSlow.Enabled then
                local any_import_result1_6_upvr = debug.getupvalue(originalPlayPunchAnimation, 1)
                local GameAnimationUtil_upvr = debug.getupvalue(originalPlayPunchAnimation, 2)
                local Players_upvr = debug.getupvalue(originalPlayPunchAnimation, 3)
                local AnimationType_upvr = debug.getupvalue(originalPlayPunchAnimation, 4)
                local KnitClient_upvr = debug.getupvalue(originalPlayPunchAnimation, 5)
                local RunService_upvr = debug.getupvalue(originalPlayPunchAnimation, 6)
                
                local any_new_result1_upvr_2 = any_import_result1_6_upvr.new()
                local any_playAnimation_result1_upvr_2 = GameAnimationUtil_upvr:playAnimation(Players_upvr.LocalPlayer, AnimationType_upvr.DRAGON_SLAYER_PUNCH)
                any_new_result1_upvr_2:GiveTask(function()
                    local var137 = any_playAnimation_result1_upvr_2
                    if var137 ~= nil then
                        var137:Stop()
                    end
                end)
                
                any_new_result1_upvr_2:GiveTask(RunService_upvr.Heartbeat:Connect(function()
                    local Character = Players_upvr.LocalPlayer.Character
                    local var141 = Character
                    if var141 ~= nil then
                        var141 = var141.PrimaryPart
                    end
                    if not var141 then
                        any_new_result1_upvr_2:DoCleaning()
                        return nil
                    end
                    Character:PivotTo(CFrame.new(Character:GetPrimaryPartCFrame().Position) * arg2)
                end))
                
                task.delay(0.46, function()
                    any_new_result1_upvr_2:DoCleaning()
                end)
                
                return any_new_result1_upvr_2
            else
                return originalPlayPunchAnimation(self, arg2)
            end
        end
    end

    local function unhookNoSlow()
        if originalPlayPunchAnimation and bedwars.DragonSlayerController then
            bedwars.DragonSlayerController.playPunchAnimation = originalPlayPunchAnimation
        end
    end

    Kaliyah = vape.Categories.Kits:CreateModule({
        Name = 'AutoKaliyah',
        Function = function(callback)
            if callback then
                if AutoPunch.Enabled then
                    startAutoPunch()
                end
                if NoSlow.Enabled then
                    hookNoSlow()
                end
            else
                stopAutoPunch()
                unhookNoSlow()
            end
        end,
        Tooltip = 'Dragon Slayer kit features - AutoPunch and NoSlow'
    })
    
    AutoPunch = Kaliyah:CreateToggle({
        Name = 'Auto Punch',
        Default = false,
        Tooltip = 'Automatically punch dragon emblems',
        Function = function(callback)
            if RangeSlider and RangeSlider.Object then RangeSlider.Object.Visible = callback end
            if PunchDelay and PunchDelay.Object then PunchDelay.Object.Visible = callback end
            if DelaySlider and DelaySlider.Object then DelaySlider.Object.Visible = (callback and PunchDelay.Enabled) end
            
            if Kaliyah.Enabled then
                if callback then
                    startAutoPunch()
                else
                    stopAutoPunch()
                end
            end
        end
    })
    
    RangeSlider = Kaliyah:CreateSlider({
        Name = 'Range',
        Min = 1, 
        Max = 100,
        Default = 18,
        Decimal = 1,
        Suffix = ' studs',
        Tooltip = 'Distance to auto punch emblems'
    })
    
    PunchDelay = Kaliyah:CreateToggle({
        Name = 'Punch Delay',
        Default = false,
        Tooltip = 'Add delay before punching',
        Function = function(callback)
            if DelaySlider and DelaySlider.Object then
                DelaySlider.Object.Visible = callback
            end
        end
    })
    
    DelaySlider = Kaliyah:CreateSlider({
        Name = 'Delay',
        Min = 1,
        Max = 3,
        Default = 1,
        Decimal = 10,
        Suffix = 's',
        Tooltip = 'Delay in seconds before punching'
    })
    
    NoSlow = Kaliyah:CreateToggle({
        Name = 'No Slow',
        Default = false,
        Tooltip = 'Remove movement lock when punching',
        Function = function(callback)
            if Kaliyah.Enabled then
                if callback then
                    hookNoSlow()
                else
                    unhookNoSlow()
                end
            end
        end
    })
end)

run(function()
    local Grove
    local NoSlow
    local NoSlowOnAbility
    local AutoWater
    local AutoWaterRange
    local AutoCollect
    local CollectRange
    local SpiritESP
    local ESPNotify
    local ESPBackground
    local ESPColor
    local DistanceCheck
    local DistanceLimit
    
    local Folder = Instance.new('Folder')
    Folder.Parent = vape.gui
    local Reference = {}
    local lastNotification = 0
    local spawnQueue = {}
    local notificationCooldown = 1
    local noSlowActive = false
    local autoWaterActive = false
    local autoCollectActive = false
    local originalDisableActionsOnCharge
    local originalCheckForPickup
    
    local function sendNotification(count)
        notif("Spirit ESP", string.format("%d spirit orbs spawned", count), 3)
    end

    local function processSpawnQueue()
        if #spawnQueue > 0 then
            local currentTime = tick()
            if currentTime - lastNotification >= notificationCooldown then
                sendNotification(#spawnQueue)
                lastNotification = currentTime
                spawnQueue = {}
            else
                task.delay(notificationCooldown - (currentTime - lastNotification), function()
                    if #spawnQueue > 0 then
                        sendNotification(#spawnQueue)
                        spawnQueue = {}
                    end
                end)
            end
        end
    end

    local function getProperImage()
        return bedwars.getIcon({itemType = 'spirit'}, true)
    end

    local function Added(v)
        if Reference[v] then return end
        
        local billboard = Instance.new('BillboardGui')
        billboard.Parent = Folder
        billboard.Name = 'spirit-energy'
        billboard.StudsOffsetWorldSpace = Vector3.new(0, 3, 0)
        billboard.Size = UDim2.fromOffset(36, 36)
        billboard.AlwaysOnTop = true
        billboard.ClipsDescendants = false
        billboard.Adornee = v
        
        local blur = addBlur(billboard)
        blur.Visible = ESPBackground.Enabled
        
        local image = Instance.new('ImageLabel')
        image.Size = UDim2.fromOffset(36, 36)
        image.Position = UDim2.fromScale(0.5, 0.5)
        image.AnchorPoint = Vector2.new(0.5, 0.5)
        image.BackgroundColor3 = Color3.fromHSV(ESPColor.Hue, ESPColor.Sat, ESPColor.Value)
        image.BackgroundTransparency = 1 - (ESPBackground.Enabled and ESPColor.Opacity or 0)
        image.BorderSizePixel = 0
        image.Image = getProperImage()
        image.Parent = billboard
        
        local uicorner = Instance.new('UICorner')
        uicorner.CornerRadius = UDim.new(0, 4)
        uicorner.Parent = image
        
        Reference[v] = billboard
        
        if ESPNotify.Enabled then
            table.insert(spawnQueue, {item = 'spirit', time = tick()})
            processSpawnQueue()
        end
    end

    local function Removed(v)
        if Reference[v] then
            Reference[v]:Destroy()
            Reference[v] = nil
        end
    end

    local function setupESP()
        for _, v in workspace:GetChildren() do
            if v.Name == "SpiritGardenerEnergy" and v:IsA("Model") and v.PrimaryPart then
                Added(v.PrimaryPart)
            end
        end

        Grove:Clean(workspace.ChildAdded:Connect(function(v)
            if v.Name == "SpiritGardenerEnergy" and v:IsA("Model") then
                task.wait(0.1)
                if v.PrimaryPart then
                    Added(v.PrimaryPart)
                end
            end
        end))

        Grove:Clean(workspace.ChildRemoved:Connect(function(v)
            if v.Name == "SpiritGardenerEnergy" and v.PrimaryPart then
                Removed(v.PrimaryPart)
            end
        end))

        Grove:Clean(runService.RenderStepped:Connect(function()
            if not SpiritESP.Enabled then return end
            
            for v, billboard in pairs(Reference) do
                if not v or not v.Parent then
                    Removed(v)
                    continue
                end

                local shouldShow = true

                if shouldShow and DistanceCheck.Enabled and entitylib.isAlive then
                    local distance = (entitylib.character.RootPart.Position - v.Position).Magnitude
                    if distance < DistanceLimit.ValueMin or distance > DistanceLimit.ValueMax then
                        shouldShow = false
                    end
                end

                billboard.Enabled = shouldShow
            end
        end))
    end

    local function getNearbyFlowers()
        local flowers = {}
        if not entitylib.isAlive then return flowers end
        
        local localPosition = entitylib.character.RootPart.Position
        local range = AutoWaterRange.Value
        
        for _, v in collectionService:GetTagged('SpiritGardenerFlower') do
            if v:IsA("Model") and v.PrimaryPart then
                if v:GetAttribute("PlacedByUserId") == lplr.UserId then
                    local needsEnergy = not v:GetAttribute("HasFullyGrown")
                    if needsEnergy then
                        local distance = (localPosition - v.PrimaryPart.Position).Magnitude
                        if distance <= range then
                            table.insert(flowers, v)
                        end
                    end
                end
            end
        end
        
        return flowers
    end

    local function useWaterAbility()
        local success = pcall(function()
            game:GetService("ReplicatedStorage"):WaitForChild("events-@easy-games/game-core:shared/game-core-networking@getEvents.Events"):WaitForChild("useAbility"):FireServer("spirit_gardener_water")
        end)
        return success
    end

    local function startAutoWater()
        if autoWaterActive then return end
        autoWaterActive = true
        
        task.spawn(function()
            while Grove.Enabled and AutoWater.Enabled and autoWaterActive do
                if not entitylib.isAlive then 
                    task.wait(0.5)
                    continue 
                end
                
                local flowers = getNearbyFlowers()
                
                if #flowers > 0 then
                    if useWaterAbility() then
                        task.wait(0.6) 
                    else
                        task.wait(0.3)
                    end
                else
                    task.wait(0.5)
                end
            end
            
            autoWaterActive = false
        end)
    end

    local function stopAutoWater()
        autoWaterActive = false
    end

    local function hookAutoCollect()
        if not bedwars.SpiritGardenerSeedController then return end
        
        originalCheckForPickup = bedwars.SpiritGardenerSeedController.checkForPickup
        
        bedwars.SpiritGardenerSeedController.checkForPickup = function(self)
            if not AutoCollect.Enabled then
                return originalCheckForPickup(self)
            end
            
            local Players = game:GetService("Players")
            local CollectionService = game:GetService("CollectionService")
            local Workspace = game:GetService("Workspace")
            
            local Character = Players.LocalPlayer.Character
            if not Character or not Character.PrimaryPart then
                return nil
            end
            
            local localPosition = Character.PrimaryPart.Position
            local range = CollectRange.Value
            
            local validTypes = self:validCollectableEntityTypes()
            
            for _, collectableType in validTypes do
                local tagged = CollectionService:GetTagged(collectableType)
                
                for _, orb in tagged do
                    local spawnTime = orb:GetAttribute("SpawnTime")
                    if spawnTime and (Workspace:GetServerTimeNow() - spawnTime) >= 1 then
                        local orbPosition = orb:GetPivot().Position
                        local distance = (localPosition - orbPosition).Magnitude
                        
                        if distance <= range then
                            self:collectEntity(Players.LocalPlayer, orb, collectableType)
                        end
                    end
                end
            end
        end
    end

    local function unhookAutoCollect()
        if originalCheckForPickup and bedwars.SpiritGardenerSeedController then
            bedwars.SpiritGardenerSeedController.checkForPickup = originalCheckForPickup
        end
    end

    local function startAutoCollect()
        if autoCollectActive then return end
        autoCollectActive = true
        
        hookAutoCollect()
        
        if bedwars.SpiritGardenerSeedController then
            pcall(function()
                bedwars.SpiritGardenerSeedController:listenToPickup()
            end)
        end
    end

    local function stopAutoCollect()
        autoCollectActive = false
        unhookAutoCollect()
    end

    local function hookNoSlow()
        if not bedwars.SpiritGardenerController then return end
        
        originalDisableActionsOnCharge = bedwars.SpiritGardenerController.disableActionsOnCharge
        
        bedwars.SpiritGardenerController.disableActionsOnCharge = function(self, maid, character)
            if not NoSlow.Enabled then
                return originalDisableActionsOnCharge(self, maid, character)
            end
            
            if NoSlowOnAbility.Enabled then
                local isLocalPlayer = character == lplr.Character
                if not isLocalPlayer then
                    return originalDisableActionsOnCharge(self, maid, character)
                end
            end
            
            if character == lplr.Character then
                local KnitClient = bedwars.KnitClient
                
                KnitClient.Controllers.SwordController:toggleSwordSwing(true)
                KnitClient.Controllers.BlockPlacementController:disableBlockPlacer()
                
                local ClientSyncEvents = debug.getupvalue(originalDisableActionsOnCharge, 3)
                local projectileConnection = ClientSyncEvents.BeginProjectileTargeting:connect(function(event)
                    event:setCancelled(true)
                    return nil
                end)
                
                local jumpModifier = KnitClient.Controllers.JumpHeightController:getJumpModifier():addModifier({
                    jumpHeightMultiplier = 0;
                })
                
                maid:GiveTask(function()
                    KnitClient.Controllers.SwordController:toggleSwordSwing(false)
                    KnitClient.Controllers.BlockPlacementController:enableBlockPlacer()
                    projectileConnection:Destroy()
                    jumpModifier.Destroy()
                end)
            end
        end
    end

    local function unhookNoSlow()
        if originalDisableActionsOnCharge and bedwars.SpiritGardenerController then
            bedwars.SpiritGardenerController.disableActionsOnCharge = originalDisableActionsOnCharge
        end
    end

    Grove = vape.Categories.Kits:CreateModule({
        Name = 'AutoGrove',
        Function = function(callback)
            if callback then
                if SpiritESP.Enabled then 
                    setupESP() 
                end
                
                if NoSlow.Enabled then
                    hookNoSlow()
                end
                
                if AutoWater.Enabled then
                    startAutoWater()
                end
                
                if AutoCollect.Enabled then
                    startAutoCollect()
                end
            else
                stopAutoWater()
                stopAutoCollect()
                unhookNoSlow()
                Folder:ClearAllChildren()
                table.clear(Reference)
                table.clear(spawnQueue)
                lastNotification = 0
            end
        end,
        Tooltip = 'Spirit Gardener kit features - NoSlow, Auto Water, Auto Collect, and Spirit ESP'
    })
    
    NoSlow = Grove:CreateToggle({
        Name = 'No Slow',
        Default = false,
        Tooltip = 'Remove movement lock when using water ability',
        Function = function(callback)
            if NoSlowOnAbility and NoSlowOnAbility.Object then 
                NoSlowOnAbility.Object.Visible = callback 
            end
            
            if Grove.Enabled then
                if callback then
                    hookNoSlow()
                else
                    unhookNoSlow()
                end
            end
        end
    })
    
    NoSlowOnAbility = Grove:CreateToggle({
        Name = 'Only On Ability Use',
        Default = false,
        Tooltip = 'NoSlow only works when you manually use the ability'
    })
    
    AutoWater = Grove:CreateToggle({
        Name = 'Auto Water',
        Default = false,
        Tooltip = 'Automatically water nearby flowers that need energy',
        Function = function(callback)
            if AutoWaterRange and AutoWaterRange.Object then 
                AutoWaterRange.Object.Visible = callback 
            end
            
            if Grove.Enabled then
                if callback then
                    startAutoWater()
                else
                    stopAutoWater()
                end
            end
        end
    })
    
    AutoWaterRange = Grove:CreateSlider({
        Name = 'Water Range',
        Min = 1, 
        Max = 30,
        Default = 20,
        Decimal = 1,
        Suffix = ' studs',
        Tooltip = 'Distance to auto water flowers'
    })
    
    AutoCollect = Grove:CreateToggle({
        Name = 'Auto Collect',
        Default = false,
        Tooltip = 'Automatically collect spirit energy orbs from extended range',
        Function = function(callback)
            if CollectRange and CollectRange.Object then 
                CollectRange.Object.Visible = callback 
            end
            
            if Grove.Enabled then
                if callback then
                    startAutoCollect()
                else
                    stopAutoCollect()
                end
            end
        end
    })
    
    CollectRange = Grove:CreateSlider({
        Name = 'Collect Range',
        Min = 5, 
        Max = 12,
        Default = 12,
        Decimal = 10,
        Suffix = ' studs',
        Tooltip = 'Distance to auto collect spirit orbs (default: 5.5)'
    })
    
    SpiritESP = Grove:CreateToggle({
        Name = 'Spirit ESP',
        Default = false,
        Tooltip = 'Shows spirit energy orb locations',
        Function = function(callback)
            if ESPNotify and ESPNotify.Object then ESPNotify.Object.Visible = callback end
            if ESPBackground and ESPBackground.Object then ESPBackground.Object.Visible = callback end
            if ESPColor and ESPColor.Object then ESPColor.Object.Visible = callback end
            if DistanceCheck and DistanceCheck.Object then DistanceCheck.Object.Visible = callback end
            if DistanceLimit and DistanceLimit.Object then
                DistanceLimit.Object.Visible = (callback and DistanceCheck.Enabled)
            end
            
            if Grove.Enabled then
                if callback then 
                    setupESP() 
                else
                    Folder:ClearAllChildren()
                    table.clear(Reference)
                end
            end
        end
    })
    
    ESPNotify = Grove:CreateToggle({
        Name = 'Notify',
        Default = false,
        Tooltip = 'Get notifications when spirit orbs spawn'
    })
    
    ESPBackground = Grove:CreateToggle({
        Name = 'Background',
        Default = true,
        Function = function(callback)
            if ESPColor and ESPColor.Object then ESPColor.Object.Visible = callback end
            for _, v in Reference do
                if v and v:FindFirstChild("ImageLabel") then
                    local blur = v:FindFirstChild("BlurEffect")
                    if blur then blur.Visible = callback end
                    v.ImageLabel.BackgroundTransparency = 1 - (callback and ESPColor.Opacity or 0)
                end
            end
        end
    })
    
    ESPColor = Grove:CreateColorSlider({
        Name = 'Background Color',
        DefaultValue = 0.5,
        DefaultOpacity = 0.5,
        Function = function(hue, sat, val, opacity)
            for _, v in Reference do
                if v and v:FindFirstChild("ImageLabel") then
                    v.ImageLabel.BackgroundColor3 = Color3.fromHSV(hue, sat, val)
                    v.ImageLabel.BackgroundTransparency = 1 - opacity
                end
            end
        end,
        Darker = true
    })
    
    DistanceCheck = Grove:CreateToggle({
        Name = 'Distance Check',
        Default = false,
        Tooltip = 'Only show spirit orbs within distance range',
        Function = function(callback)
            if DistanceLimit and DistanceLimit.Object then
                DistanceLimit.Object.Visible = callback
            end
        end
    })
    
    DistanceLimit = Grove:CreateTwoSlider({
        Name = 'Spirit Distance',
        Min = 0,
        Max = 256,
        DefaultMin = 0,
        DefaultMax = 64,
        Darker = true,
        Tooltip = 'Distance range for showing spirit orbs'
    })
end)

run(function()
    local AutoDrone
    local PriorityDropdown
    local DropLocation
    local FlightHeight
    local FlightSpeed
    local CollectAmount

    local droneActive = false
    local currentState = "idle"
    local targetPosition = nil
    local stateData = {}
    
    local CollectionService = game:GetService("CollectionService")
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local lplr = Players.LocalPlayer

    local priorityOrders = {
        ['Emerald > Diamond > Gold'] = {'emerald', 'diamond', 'iron'},
        ['Diamond > Emerald > Gold'] = {'diamond', 'emerald', 'iron'},
        ['Gold > Diamond > Emerald'] = {'iron', 'diamond', 'emerald'}
    }

    local lastDropTime = 0
    local lastDropPos = nil
    local flightLoop = nil

    local function getMyDrone()
        for _, drone in CollectionService:GetTagged('Drone') do
            if drone:GetAttribute('PlayerUserId') == lplr.UserId then
                return drone
            end
        end
        return nil
    end

    local function getDroneItemCount(drone)
        if not drone then return 0 end
        return drone:GetAttribute('HeldItemAmount') or 0
    end

    local function getOwnBed()
        local team = lplr:GetAttribute('Team')
        if not team then return nil end
        for _, bed in ipairs(CollectionService:GetTagged('bed')) do
            if bed:GetAttribute('Team'..team..'NoBreak') then
                return bed
            end
        end
        return nil
    end

    local function getDropPosition()
        if DropLocation.Value == 'Bed' then
            local bed = getOwnBed()
            if bed then return bed:GetPivot().Position end
        end
        if lplr.Character and lplr.Character:FindFirstChild("HumanoidRootPart") then
            return lplr.Character.HumanoidRootPart.Position
        end
        return nil
    end

    local function isRecentlyDropped(pos)
        if not lastDropPos then return false end
        if tick() - lastDropTime > 5 then return false end
        return (pos - lastDropPos).Magnitude < 25
    end

    local function findNearestLoot(resourceType, dronePos)
        local best = nil
        local bestDist = math.huge

        for _, obj in workspace:GetDescendants() do
            if obj.Name == 'GeneratorAdornee' then
                local genId = obj:GetAttribute('Id')
                if genId and genId:lower():find(resourceType:lower()) then
                    local genPos = obj:GetPivot().Position
                    
                    for _, drop in CollectionService:GetTagged('ItemDrop') do
                        if drop:FindFirstChild('Handle') then
                            if drop.Name:lower():find(resourceType:lower()) then
                                local lootPos = drop.Handle.Position
                                
                                if (lootPos - genPos).Magnitude <= 12 then
                                    if not isRecentlyDropped(lootPos) then
                                        local dist = (lootPos - dronePos).Magnitude
                                        if dist < bestDist and dist < 150 then
                                            best = lootPos
                                            bestDist = dist
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end

        return best
    end

    local function smoothMove(drone, target, speedMult)
        if not drone or not drone.PrimaryPart then return false end
        if not target then return false end

        local current = drone.PrimaryPart.Position
        local distance = (target - current).Magnitude

        if distance < 2 then
            return true
        end

        local direction = (target - current).Unit
        local speed = math.clamp(distance * (speedMult or 1.5), 18, FlightSpeed.Value)

        local targetLook = CFrame.lookAt(current, target)
        drone.PrimaryPart.CFrame = drone.PrimaryPart.CFrame:Lerp(targetLook, 0.05)
        
        drone.PrimaryPart.AssemblyLinearVelocity = direction * speed
        drone.PrimaryPart.AssemblyAngularVelocity = Vector3.zero

        return false
    end

    local function executeState()
        local drone = getMyDrone()
        if not drone or not drone.PrimaryPart then return end

        if currentState == "collecting" then
            if not targetPosition then
                currentState = "searching"
                return
            end

            if smoothMove(drone, targetPosition, 1.8) then
                task.wait(0.4)
                currentState = "searching"
                targetPosition = nil
            end

        elseif currentState == "delivering" then
            local dropPos = getDropPosition()
            if not dropPos then
                currentState = "searching"
                return
            end

            local deliveryTarget = dropPos + Vector3.new(0, FlightHeight.Value, 0)

            if smoothMove(drone, deliveryTarget, 1.5) then
                task.wait(0.3)

                local finalDropPos = dropPos + Vector3.new(
                    math.random(-3, 3),
                    1,
                    math.random(-3, 3)
                )

                pcall(function()
                    game:GetService("ReplicatedStorage")
                        :WaitForChild("rbxts_include")
                        :WaitForChild("node_modules")
                        :WaitForChild("@rbxts")
                        :WaitForChild("net")
                        :WaitForChild("out")
                        :WaitForChild("_NetManaged")
                        :WaitForChild("DropDroneItem")
                        :FireServer({
                            position = finalDropPos,
                            direction = Vector3.new(0, -1, 0)
                        })
                end)

                lastDropPos = dropPos
                lastDropTime = tick()

                local escapeDir = (drone.PrimaryPart.Position - dropPos).Unit
                drone.PrimaryPart.AssemblyLinearVelocity = escapeDir * 35 + Vector3.new(0, 12, 0)

                task.wait(1)
                currentState = "searching"
                targetPosition = nil
            end

        elseif currentState == "searching" then
            if tick() - lastDropTime < 1.5 then
                task.wait(0.5)
                return
            end

            if getDroneItemCount(drone) >= CollectAmount.Value then
                currentState = "delivering"
                return
            end

            local priorityOrder = priorityOrders[PriorityDropdown.Value]
            local foundLoot = false

            for _, resourceType in ipairs(priorityOrder) do
                if getDroneItemCount(drone) >= CollectAmount.Value then
                    currentState = "delivering"
                    return
                end

                local lootPos = findNearestLoot(resourceType, drone.PrimaryPart.Position)
                if lootPos then
                    targetPosition = lootPos + Vector3.new(0, 2, 0)
                    currentState = "collecting"
                    foundLoot = true
                    break
                end
            end

            if not foundLoot then
                currentState = "idle"
            end

        elseif currentState == "idle" then
            drone.PrimaryPart.AssemblyLinearVelocity = Vector3.new(0, 1.5, 0)
            drone.PrimaryPart.AssemblyAngularVelocity = Vector3.zero
            task.wait(1)
            currentState = "searching"
        end
    end

    AutoDrone = vape.Categories.Kits:CreateModule({
        Name = 'Auto Drone',
        Function = function(callback)
            if callback then
                droneActive = true
                currentState = "searching"
                targetPosition = nil
                lastDropTime = 0
                lastDropPos = nil
                stateData = {}

                flightLoop = RunService.Heartbeat:Connect(function()
                    if not AutoDrone.Enabled then return end
                    pcall(executeState)
                end)
            else
                droneActive = false
                currentState = "idle"
                targetPosition = nil
                
                if flightLoop then
                    flightLoop:Disconnect()
                    flightLoop = nil
                end

                local drone = getMyDrone()
                if drone and drone.PrimaryPart then
                    drone.PrimaryPart.AssemblyLinearVelocity = Vector3.zero
                    drone.PrimaryPart.AssemblyAngularVelocity = Vector3.zero
                end
            end
        end,
        Tooltip = 'Automatically collects loot and brings it to you'
    })

    PriorityDropdown = AutoDrone:CreateDropdown({
        Name = 'Priority',
        List = {'Emerald > Diamond > Gold', 'Diamond > Emerald > Gold', 'Gold > Diamond > Emerald'},
        Default = 'Emerald > Diamond > Gold'
    })

    DropLocation = AutoDrone:CreateDropdown({
        Name = 'Deliver To',
        List = {'Player', 'Bed'},
        Default = 'Player'
    })

    FlightHeight = AutoDrone:CreateSlider({
        Name = 'Flight Height',
        Default = 7,
        Min = 4,
        Max = 12
    })

    FlightSpeed = AutoDrone:CreateSlider({
        Name = 'Flight Speed',
        Default = 28,
        Min = 18,
        Max = 45
    })

    CollectAmount = AutoDrone:CreateSlider({
        Name = 'Collect Amount',
        Default = 3,
        Min = 1,
        Max = 10,
        Tooltip = 'How many items to collect before dropping'
    })
end)

run(function()
	local KnitInit, Knit
	repeat
		KnitInit, Knit = pcall(function()
			return debug.getupvalue(require(game:GetService("Players").LocalPlayer.PlayerScripts.TS.knit).setup, 9)
		end)
		if KnitInit then break end
		task.wait()
	until KnitInit

	if not debug.getupvalue(Knit.Start, 1) then
		repeat task.wait() until debug.getupvalue(Knit.Start, 1)
	end

	local Players = game:GetService("Players")

	shared.PERMISSION_CONTROLLER_HASANYPERMISSIONS_REVERT = shared.PERMISSION_CONTROLLER_HASANYPERMISSIONS_REVERT or Knit.Controllers.PermissionController.hasAnyPermissions
	shared.MATCH_CONTROLLER_GETPLAYERPARTY_REVERT = shared.MATCH_CONTROLLER_GETPLAYERPARTY_REVERT or Knit.Controllers.MatchController.getPlayerParty

	local AC_MOD_View = {
		playerConnections = {},
		Enabled = false,
		Friends = {}, 
		parties = {}, 
		teamMap = {}, 
		display = {},
		isRefreshing = false,
		cacheDirty = true,
		disable_disguises = false,
		disguises = {},
		teamData = {}
	}

	AC_MOD_View.controller = Knit.Controllers.PermissionController
	AC_MOD_View.match_controller = Knit.Controllers.MatchController

	function AC_MOD_View:getPartyById(displayId)
		if not displayId then return end
		displayId = tostring(displayId)
		if self.display[displayId] then return self.display[displayId] end
		for _, party in pairs(self.parties) do
			if party.displayId == tostring(displayId) then
				self.display[displayId] = party
				return party
			end
		end
	end

	function AC_MOD_View:refreshDisplayCache()
		for _, plr in pairs(Players:GetPlayers()) do
			local playerId = tostring(plr.UserId)

			local playerPartyId = self.teamMap[playerId]
			if playerPartyId ~= nil then
				self:getPartyById(playerPartyId)
			end
			task.wait()
		end
	end

	function AC_MOD_View:refreshDisplayCacheAsync()
		task.spawn(self.refreshDisplayCache, self)
	end

	function AC_MOD_View:getPlayerTeamData(plr)
		if self.teamData[plr] then return self.teamData[plr] end

		self.teamData[plr] = {}

		local teamMembers = {}
		local playerTeam = plr.Team 
		if not playerTeam then
			return teamMembers 
		end

		local playerId = tostring(plr.UserId)
		self.Friends[playerId] = self.Friends[playerId] or {}

		for _, otherPlayer in pairs(Players:GetPlayers()) do
			if otherPlayer == plr then continue end 

			local otherPlayerId = tostring(otherPlayer.UserId)
			local areFriends = self.Friends[playerId][otherPlayerId]

			if areFriends == nil then
				local suc, res = pcall(function()
					return plr:IsFriendsWith(otherPlayer.UserId)
				end)
				areFriends = suc and res or false

				if suc then
					self.Friends = self.Friends or {}
					self.Friends[playerId] = self.Friends[playerId] or {}
					self.Friends[playerId][otherPlayerId] = areFriends
					self.Friends[otherPlayerId] = self.Friends[otherPlayerId] or {}
					self.Friends[otherPlayerId][playerId] = areFriends
				end
			end

			if areFriends and otherPlayer.Team == playerTeam then
				table.insert(teamMembers, otherPlayerId)
			end
		end

		self.teamData[plr] = teamMembers

		return teamMembers
	end

	function AC_MOD_View:refreshPlayerTeamData()
		for i,v in pairs(Players:GetPlayers()) do
			self:getPlayerTeamData(v)
			task.wait()
		end
	end

	function AC_MOD_View:refreshPlayerTeamDataAsync()
		task.spawn(self.refreshPlayerTeamData, self)
	end

	function AC_MOD_View:refreshTeamMap()
		local allTeams = {}
		for _, p in pairs(Players:GetPlayers()) do
			local teamMembers = self:getPlayerTeamData(p)
			if teamMembers and #teamMembers > 0 then 
				allTeams[p] = teamMembers
			end
		end

		local validTeams = {}
		for playerInTeams, members in pairs(allTeams) do
			local playerIdInTeams = tostring(playerInTeams.UserId)
			local cleanedMembers = {}

			for _, memberId in pairs(members) do
				local memberIdStr = tostring(memberId)
				if memberIdStr == playerIdInTeams then
					print("Warning: Player " .. playerIdInTeams .. " has themselves in their team list.")
				else
					table.insert(cleanedMembers, memberIdStr)
				end
			end

			if #cleanedMembers > 0 then
				validTeams[playerInTeams] = cleanedMembers
			end
		end

		self.parties = {}
		self.teamMap = {}
		local teamId = 0
		for playerInTeams, members in pairs(validTeams) do
			local playerIdInTeams = tostring(playerInTeams.UserId)
			if not self.teamMap[playerIdInTeams] then
				self.teamMap[playerIdInTeams] = teamId
				table.insert(self.parties, {
					displayId = tostring(teamId),
					members = members
				})
				teamId = teamId + 1

				for _, memberId in pairs(members) do
					self.teamMap[memberId] = teamId - 1
				end
			end
		end

		self.cacheDirty = false
		self.isRefreshing = false
	end

	function AC_MOD_View:refreshTeamMapAsync()
		if self.isRefreshing then return end 
		self.isRefreshing = true
		task.spawn(function()
			self:refreshTeamMap()
		end)
	end

	function AC_MOD_View:getPlayerParty(plr)
		if not plr or not plr:IsA("Player") then
			return nil
		end

		local playerId = tostring(plr.UserId)

		if self.cacheDirty or not next(self.teamMap) then
			self:refreshTeamMapAsync()
		end

		local playerPartyId = self.teamMap[playerId]
		if playerPartyId ~= nil then
			return self:getPartyById(playerPartyId)
		end

		return nil 
	end

	AC_MOD_View.mockGetPlayerParty = function(self, plr)
		local parties = self.parties 
		if parties ~= nil and #parties > 0 then
			return shared.MATCH_CONTROLLER_GETPLAYERPARTY_REVERT(self, plr)
		end
		return AC_MOD_View:getPlayerParty(plr)
	end

	function AC_MOD_View:toggleDisableDisguises()
		if not self.Enabled then return end
		if self.disable_disguises then
			for _,v in pairs(Players:GetPlayers()) do
				if v == Players.LocalPlayer then continue end
				if tostring(v:GetAttribute("Disguised")) == "true" then
					v:SetAttribute("Disguised", false)
					notif("Remove Disguises", "Disabled streamer mode for "..tostring(v.Name).."!", 3)
					table.insert(self.disguises, v)
				end
			end
		else
			for i,v in pairs(self.disguises) do
				if tostring(v:GetAttribute("Disguised")) ~= "true" then
					v:SetAttribute("Disguised", true)
					notif("Remove Disguises", "Re - enabled Streamer mode for "..tostring(v.Name).."!", 2)
				end
			end
			table.clear(self.disguises)
		end
	end

	function AC_MOD_View:refreshCore()
		self:refreshTeamMapAsync()
		self:refreshDisplayCacheAsync()
		self:refreshPlayerTeamDataAsync()

		self:toggleDisableDisguises()
	end

	function AC_MOD_View:refreshCoreAsync()
		task.spawn(self.refreshCore, self)
	end

	function AC_MOD_View:init()
		self.Enabled = true
		self.controller.hasAnyPermissions = function(self)
			return true
		end
		self.match_controller.getPlayerParty = self.mockGetPlayerParty

		self.playerConnections = {
			added = Players.PlayerAdded:Connect(function(player)
				self.cacheDirty = true
				self:refreshCoreAsync()
				player:GetPropertyChangedSignal("Team"):Connect(function()
					self.cacheDirty = true
					self:refreshCoreAsync()
				end)
			end),
			removed = Players.PlayerRemoving:Connect(function(player)
				local playerId = tostring(player.UserId)
				self.Friends[playerId] = nil 
				for _, cache in pairs(self.Friends) do
					cache[playerId] = nil
				end
				self.cacheDirty = true
				self:refreshCoreAsync()
			end)
		}

		self:refreshCore()
	end

	function AC_MOD_View:disable()
		self.Enabled = false

		self.controller.hasAnyPermissions = shared.PERMISSION_CONTROLLER_HASANYPERMISSIONS_REVERT
		self.match_controller.getPlayerParty = shared.MATCH_CONTROLLER_GETPLAYERPARTY_REVERT

		if self.playerConnections then
			for _, v in pairs(self.playerConnections) do
				pcall(function() v:Disconnect() end)
			end
			table.clear(self.playerConnections)
		end

		self.parties = {}
		self.teamMap = {}
		self.Friends = {}
		self.display = {}
		self.teamData = {}
		self.cacheDirty = true

		self:toggleDisableDisguises()
	end
	shared.ACMODVIEWENABLED = false
	AC_MOD_View.moduleInstance = vape.Categories.World:CreateModule({
		Name = "AC MOD View",
		Function = function(call)
			shared.ACMODVIEWENABLED = call
			if call then
				AC_MOD_View:init()
			else
				AC_MOD_View:disable()
			end
		end
	})

	AC_MOD_View.disableDisguisesToggle = AC_MOD_View.moduleInstance:CreateToggle({
		Name = "Remove Disguises",
		Function = function(call)
			AC_MOD_View.disable_disguises = call
			AC_MOD_View:toggleDisableDisguises()
		end,
		Default = true
	})
end)

run(function()
	local StreamProof
	local originalNames = {}
	local nametagConnection = nil
	
	local function modifyPlayerName(element)
		if element:IsA("TextLabel") and element.Name == "PlayerName" then
			if element.Text:find(lplr.Name) or element.Text:find(lplr.DisplayName) then
				if not originalNames[element] then
					originalNames[element] = element.Text
				end
				element.Text = "Me"
			end
		end
		
		if element:IsA("TextLabel") and element.Name == "EntityName" then
			if element.Text:find(lplr.Name) or element.Text:find(lplr.DisplayName) then
				if not originalNames[element] then
					originalNames[element] = element.Text
				end
				element.Text = "Me"
			end
		end
		
		if element:IsA("TextLabel") and element.Name == "DisplayName" then
			if element.Text:find(lplr.Name) or element.Text:find(lplr.DisplayName) then
				if not originalNames[element] then
					originalNames[element] = element.Text
				end
				element.Text = "Me"
			end
		end
	end
	
	local function restorePlayerName(element)
		if originalNames[element] then
			element.Text = originalNames[element]
			originalNames[element] = nil
		end
	end
	
	local function processGui(gui)
		for _, descendant in gui:GetDescendants() do
			modifyPlayerName(descendant)
		end
	end
	
	local function modifyNametag(character)
		if not character then return end
		
		local head = character:FindFirstChild("Head")
		if not head then return end
		
		local nametag = head:FindFirstChild("Nametag")
		if not nametag then return end
		
		local displayNameContainer = nametag:FindFirstChild("DisplayNameContainer")
		if not displayNameContainer then return end
		
		local displayName = displayNameContainer:FindFirstChild("DisplayName")
		if displayName and displayName:IsA("TextLabel") then
			modifyPlayerName(displayName)
		end
	end
	
	local function restoreNametag(character)
		if not character then return end
		
		local head = character:FindFirstChild("Head")
		if not head then return end
		
		local nametag = head:FindFirstChild("Nametag")
		if not nametag then return end
		
		local displayNameContainer = nametag:FindFirstChild("DisplayNameContainer")
		if not displayNameContainer then return end
		
		local displayName = displayNameContainer:FindFirstChild("DisplayName")
		if displayName and displayName:IsA("TextLabel") then
			restorePlayerName(displayName)
		end
	end
	
	StreamProof = vape.Categories.Render:CreateModule({
		Name = 'Stream Proof',
		Function = function(callback)
			if callback then
				local existingTabList = lplr.PlayerGui:FindFirstChild("TabListScreenGui")
				if existingTabList then
					processGui(existingTabList)
					
					StreamProof:Clean(existingTabList.DescendantAdded:Connect(function(descendant)
						modifyPlayerName(descendant)
					end))
				end
				
				local existingKillFeed = lplr.PlayerGui:FindFirstChild("KillFeedGui")
				if existingKillFeed then
					processGui(existingKillFeed)
					
					StreamProof:Clean(existingKillFeed.DescendantAdded:Connect(function(descendant)
						modifyPlayerName(descendant)
					end))
				end
				
				StreamProof:Clean(lplr.PlayerGui.ChildAdded:Connect(function(gui)
					if gui.Name == "TabListScreenGui" then
						processGui(gui)
						
						StreamProof:Clean(gui.DescendantAdded:Connect(function(descendant)
							modifyPlayerName(descendant)
						end))
					elseif gui.Name == "KillFeedGui" then
						processGui(gui)
						
						StreamProof:Clean(gui.DescendantAdded:Connect(function(descendant)
							modifyPlayerName(descendant)
						end))
					end
				end))
				
				if lplr.Character then
					modifyNametag(lplr.Character)
				end
				
				StreamProof:Clean(lplr.CharacterAdded:Connect(function(character)
					task.wait(0.5)
					if StreamProof.Enabled then
						modifyNametag(character)
					end
				end))
				
				nametagConnection = runService.RenderStepped:Connect(function()
					if StreamProof.Enabled and lplr.Character then
						pcall(function()
							modifyNametag(lplr.Character)
						end)
					end
				end)
				
			else
				if nametagConnection then
					nametagConnection:Disconnect()
					nametagConnection = nil
				end
				
				local existingTabList = lplr.PlayerGui:FindFirstChild("TabListScreenGui")
				if existingTabList then
					for _, descendant in existingTabList:GetDescendants() do
						restorePlayerName(descendant)
					end
				end
				
				local existingKillFeed = lplr.PlayerGui:FindFirstChild("KillFeedGui")
				if existingKillFeed then
					for _, descendant in existingKillFeed:GetDescendants() do
						restorePlayerName(descendant)
					end
				end
				
				if lplr.Character then
					restoreNametag(lplr.Character)
				end
				
				table.clear(originalNames)
			end
		end,
		Tooltip = 'Hides your name as much as possible  in TabList, KillFeed, and Nametag'
	})
end)

run(function()
    local Lucia
    local AutoDepositToggle
    local RangeSlider
    local DelayToggle
    local DelaySlider
    local LuciaESPToggle
    local CandyESPToggle
    local IgnoreTeammatesESP
    local ESPBackground
    local ESPColor = {}
    local LuciaSpyToggle
    local IgnoreTeammatesSpy
    local DisplayNameToggle
    local CollectionService = game:GetService("CollectionService")
    local RunService = game:GetService("RunService")
    local Players = game:GetService("Players")
    local lplr = Players.LocalPlayer
    local Folder = Instance.new('Folder')
    Folder.Parent = vape.gui
    local Reference = {}
    local collectedPinatas = {}
    local trackedPinatas = {}

    local function kitCollection(id, func, range, specific)
        local objs = type(id) == 'table' and id or collection(id, Lucia)
        repeat
            if entitylib.isAlive then
                local localPosition = entitylib.character.RootPart.Position
                for _, v in objs do
                    if not Lucia.Enabled then break end
                    local part = not v:IsA('Model') and v or v.PrimaryPart
                    if part and (part.Position - localPosition).Magnitude <= range then
                        func(v)
                    end
                end
            end
            task.wait(0.1)
        until not Lucia.Enabled
    end

    local function isTeammateESP(pinataPart)
        if not IgnoreTeammatesESP.Enabled then return false end
        
        local placerId = pinataPart:GetAttribute("PlacedByUserId") or pinataPart:GetAttribute("PlacerId")
        if not placerId then
            local parent = pinataPart.Parent
            if parent then
                placerId = parent:GetAttribute("PlacedByUserId") or parent:GetAttribute("PlacerId")
            end
        end
        
        if placerId then
            if placerId == lplr.UserId then
                return true
            end
            
            local placer = Players:GetPlayerByUserId(placerId)
            if placer and placer.Team == lplr.Team then
                return true
            end
        end
        
        return false
    end
    
    local function isTeammateSpy(pinataPart)
        if not IgnoreTeammatesSpy.Enabled then return false end
        
        local placerId = pinataPart:GetAttribute("PlacedByUserId") or pinataPart:GetAttribute("PlacerId")
        if not placerId then
            local parent = pinataPart.Parent
            if parent then
                placerId = parent:GetAttribute("PlacedByUserId") or parent:GetAttribute("PlacerId")
            end
        end
        
        if placerId then
            if placerId == lplr.UserId then
                return true
            end
            
            local placer = Players:GetPlayerByUserId(placerId)
            if placer and placer.Team == lplr.Team then
                return true
            end
        end
        
        return false
    end

    local function getCandyAmount(pinataPart)
        local coins = pinataPart:GetAttribute("Coin")
        return coins or 0
    end

    local function getProperIcon(iconType)
        local icon = bedwars.getIcon({itemType = iconType}, true)
        if not icon or icon == "" then
            return nil
        end
        return icon
    end

    local function Added(pinataPart)
        if isTeammateESP(pinataPart) then
            return
        end
        
        if Reference[pinataPart] then return end
        
        local billboard = Instance.new('BillboardGui')
        billboard.Parent = Folder
        billboard.Name = 'pinata'
        billboard.StudsOffsetWorldSpace = Vector3.new(0, 3, 0)
        billboard.Size = UDim2.fromOffset(CandyESPToggle.Enabled and 80 or 36, 36)
        billboard.AlwaysOnTop = true
        billboard.ClipsDescendants = false
        billboard.Adornee = pinataPart
        
        local blur = addBlur(billboard)
        blur.Visible = ESPBackground.Enabled
        
        local frame = Instance.new('Frame')
        frame.Size = UDim2.fromScale(1, 1)
        frame.BackgroundColor3 = Color3.fromHSV(ESPColor.Hue, ESPColor.Sat, ESPColor.Value)
        frame.BackgroundTransparency = 1 - (ESPBackground.Enabled and ESPColor.Opacity or 0)
        frame.BorderSizePixel = 0
        frame.Parent = billboard
        
        local uicorner = Instance.new('UICorner')
        uicorner.CornerRadius = UDim.new(0, 4)
        uicorner.Parent = frame
        
        local pinataIcon = getProperIcon('pinata')
        if pinataIcon then
            local image = Instance.new('ImageLabel')
            image.Name = 'PinataIcon'
            image.Size = UDim2.fromOffset(36, 36)
            image.Position = UDim2.new(0, 0, 0.5, 0)
            image.AnchorPoint = Vector2.new(0, 0.5)
            image.BackgroundTransparency = 1
            image.Image = pinataIcon
            image.Parent = frame
        end
        
        local candyAmount = nil
        local candyIcon = nil
        
        if CandyESPToggle.Enabled then
            candyAmount = Instance.new('TextLabel')
            candyAmount.Name = 'CandyAmount'
            candyAmount.Size = UDim2.fromOffset(25, 20)
            candyAmount.Position = UDim2.new(0, 40, 0.5, 0)
            candyAmount.AnchorPoint = Vector2.new(0, 0.5)
            candyAmount.BackgroundTransparency = 1
            candyAmount.Text = tostring(getCandyAmount(pinataPart))
            candyAmount.TextColor3 = Color3.fromRGB(255, 255, 255)
            candyAmount.TextSize = 16
            candyAmount.Font = Enum.Font.GothamBold
            candyAmount.TextStrokeTransparency = 0.5
            candyAmount.TextStrokeColor3 = Color3.new(0, 0, 0)
            candyAmount.Parent = frame
            
            local candyIconImage = getProperIcon('candy')
            if candyIconImage then
                candyIcon = Instance.new('ImageLabel')
                candyIcon.Name = 'CandyIcon'
                candyIcon.Size = UDim2.fromOffset(18, 18)
                candyIcon.Position = UDim2.new(0, 65, 0.5, 0)
                candyIcon.AnchorPoint = Vector2.new(0, 0.5)
                candyIcon.BackgroundTransparency = 1
                candyIcon.Image = candyIconImage
                candyIcon.Parent = frame
            end
        end
        
        Reference[pinataPart] = {
            billboard = billboard,
            frame = frame,
            candyAmount = candyAmount,
            candyIcon = candyIcon
        }
    end

    local function Removed(pinataPart)
        if Reference[pinataPart] then
            Reference[pinataPart].billboard:Destroy()
            Reference[pinataPart] = nil
        end
    end

    local function updateCandyDisplay(pinataPart)
        local ref = Reference[pinataPart]
        if not ref then return end
        
        if CandyESPToggle.Enabled then
            if not ref.candyAmount then
                ref.candyAmount = Instance.new('TextLabel')
                ref.candyAmount.Name = 'CandyAmount'
                ref.candyAmount.Size = UDim2.fromOffset(25, 20)
                ref.candyAmount.Position = UDim2.new(0, 40, 0.5, 0)
                ref.candyAmount.AnchorPoint = Vector2.new(0, 0.5)
                ref.candyAmount.BackgroundTransparency = 1
                ref.candyAmount.TextColor3 = Color3.fromRGB(255, 255, 255)
                ref.candyAmount.TextSize = 16
                ref.candyAmount.Font = Enum.Font.GothamBold
                ref.candyAmount.TextStrokeTransparency = 0.5
                ref.candyAmount.TextStrokeColor3 = Color3.new(0, 0, 0)
                ref.candyAmount.Parent = ref.frame
                
                local candyIconImage = getProperIcon('candy')
                if candyIconImage and not ref.candyIcon then
                    ref.candyIcon = Instance.new('ImageLabel')
                    ref.candyIcon.Name = 'CandyIcon'
                    ref.candyIcon.Size = UDim2.fromOffset(18, 18)
                    ref.candyIcon.Position = UDim2.new(0, 65, 0.5, 0)
                    ref.candyIcon.AnchorPoint = Vector2.new(0, 0.5)
                    ref.candyIcon.BackgroundTransparency = 1
                    ref.candyIcon.Image = candyIconImage
                    ref.candyIcon.Parent = ref.frame
                end
                
                ref.billboard.Size = UDim2.fromOffset(80, 36)
            end
            
            if ref.candyAmount then
                ref.candyAmount.Text = tostring(getCandyAmount(pinataPart))
            end
        else
            if ref.candyAmount then
                ref.candyAmount:Destroy()
                ref.candyAmount = nil
            end
            if ref.candyIcon then
                ref.candyIcon:Destroy()
                ref.candyIcon = nil
            end
            ref.billboard.Size = UDim2.fromOffset(36, 36)
        end
    end

    local function findExistingPinatas()
        for _, obj in pairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") and obj.Name == "pinata" then
                if not Reference[obj] and not isTeammateESP(obj) then
                    Added(obj)
                end
            end
        end
    end

    local function refreshESP()
        Folder:ClearAllChildren()
        table.clear(Reference)
        findExistingPinatas()
    end

    local function getPlayerName(player)
        if DisplayNameToggle.Enabled then
            return player.DisplayName ~= "" and player.DisplayName or player.Name
        else
            return player.Name
        end
    end

    local function getTeamName(player)
        if player.Team then
            return player.Team.Name
        end
        return "Unknown"
    end

    local function setupLuciaSpy()
        local util = require(game:GetService("ReplicatedStorage").TS.games.bedwars.kit.kits['piggy-bank']['piggy-bank-util']).PiggyBankUtil
        
        for _, obj in pairs(workspace:GetDescendants()) do
            if obj:IsA("BasePart") and obj.Name == "pinata" then
                if not isTeammateSpy(obj) then
                    local placerId = obj:GetAttribute("PlacedByUserId") or obj:GetAttribute("PlacerId")
                    
                    if placerId then
                        local placer = Players:GetPlayerByUserId(placerId)
                        local initialCandy = getCandyAmount(obj)
                        
                        trackedPinatas[obj] = {
                            player = placer,
                            lastCandy = initialCandy,
                            exists = true,
                            placedTime = tick()
                        }
                    end
                end
            end
        end
        
        Lucia:Clean(workspace.DescendantAdded:Connect(function(obj)
            if not LuciaSpyToggle.Enabled then return end
            
            if obj:IsA("BasePart") and obj.Name == "pinata" then
                task.wait(0.2) 
                
                if not isTeammateSpy(obj) then
                    local placerId = obj:GetAttribute("PlacedByUserId") or obj:GetAttribute("PlacerId")
                    
                    if placerId then
                        local placer = Players:GetPlayerByUserId(placerId)
                        local initialCandy = getCandyAmount(obj)
                        
                        trackedPinatas[obj] = {
                            player = placer,
                            lastCandy = initialCandy,
                            exists = true,
                            placedTime = tick()
                        }
                    end
                end
            end
        end))
        
        Lucia:Clean(bedwars.Client:Get("PiggyBankPop"):Connect(function(self)
            if not LuciaSpyToggle.Enabled then return end
            local plr = self.awardedPlayer
            if not plr then return end
            if IgnoreTeammatesSpy.Enabled then
                if plr == lplr or (plr.Team and plr.Team == lplr.Team) then
                    return
                end
            end
            
            local rewards = util:getRewardsFromCoins(self.coins)
            local I = rewards[1]
            local D = rewards[2]
            local E = rewards[3]
            local irons = I and I.amount or 0
            local diamond = D and D.amount or 0
            local emeralds = E and E.amount or 0
            
            local playerName = getPlayerName(plr)
            local teamName = getTeamName(plr)
            local loot = irons.." irons, "..diamond.." diamonds, "..emeralds.." emeralds"
            
            vape:CreateNotification(
                "Lucia Spy", 
                string.format("%s (%s) opened their pinata and got %s", playerName, teamName, loot), 
                8
            )
            
            for pinataPart, data in pairs(trackedPinatas) do
                if data.player and data.player.UserId == plr.UserId then
                    trackedPinatas[pinataPart] = nil
                end
            end
        end))
        
        Lucia:Clean(RunService.Heartbeat:Connect(function()
            if not LuciaSpyToggle.Enabled then return end
            local toRemove = {}
            for pinataPart, data in pairs(trackedPinatas) do
                if pinataPart and pinataPart.Parent then
                    local currentCandy = getCandyAmount(pinataPart)
                
                    if currentCandy ~= data.lastCandy then
                        local difference = currentCandy - data.lastCandy
                        
                        if difference > 0 and data.player then
                            local playerName = getPlayerName(data.player)
                            local teamName = getTeamName(data.player)
                            
                            vape:CreateNotification(
                                "Lucia Spy",
                                string.format("%s (%s) has just deposited %d candy and now has %d candy", 
                                    playerName, teamName, difference, currentCandy),
                                5
                            )
                        end
                        
                        data.lastCandy = currentCandy
                    end
                else
                    if data.exists and data.player then
                        local timeSincePlaced = tick() - (data.placedTime or tick())
                        
                        if timeSincePlaced > 2 then 
                            local playerName = getPlayerName(data.player)
                            local teamName = getTeamName(data.player)
                            
                            vape:CreateNotification(
                                "Lucia Spy",
                                string.format("%s (%s) has just broken their pinata with %d candy", 
                                    playerName, teamName, data.lastCandy),
                                5
                            )
                        end
                    end
                    
                    table.insert(toRemove, pinataPart)
                end
            end
            
            for _, pinataPart in ipairs(toRemove) do
                trackedPinatas[pinataPart] = nil
            end
        end))
    end

    Lucia = vape.Categories.Kits:CreateModule({
        Name = 'AutoLucia',
        Function = function(callback)
            if callback then
                if LuciaESPToggle.Enabled then
                    findExistingPinatas()
                    
                    Lucia:Clean(workspace.DescendantAdded:Connect(function(obj)
                        if Lucia.Enabled and obj:IsA("BasePart") and obj.Name == "pinata" then
                            task.wait(0.1)
                            if not isTeammateESP(obj) then
                                Added(obj)
                            end
                        end
                    end))
                    
                    Lucia:Clean(workspace.DescendantRemoving:Connect(function(obj)
                        if obj:IsA("BasePart") and obj.Name == "pinata" and Reference[obj] then
                            Removed(obj)
                        end
                    end))

                    Lucia:Clean(RunService.Heartbeat:Connect(function()
                        if not Lucia.Enabled or not LuciaESPToggle.Enabled then return end
                        
                        for pinataPart, ref in pairs(Reference) do
                            if pinataPart and pinataPart.Parent then
                                updateCandyDisplay(pinataPart)
                            else
                                if ref.billboard then
                                    ref.billboard:Destroy()
                                end
                                Reference[pinataPart] = nil
                            end
                        end
                    end))
                end
                
                if AutoDepositToggle.Enabled then
                    task.spawn(function()
                        local r = RangeSlider.Value
                        kitCollection(lplr.Name..':pinata', function(v)
                            if getItem('candy') then
                                bedwars.Client:Get('DepositCoins'):CallServer(v)
                            end
                        end, r, true)
                    end)
                end
                
                if LuciaSpyToggle.Enabled then
                    setupLuciaSpy()
                end
            else
                Folder:ClearAllChildren()
                table.clear(Reference)
                table.clear(collectedPinatas)
                table.clear(trackedPinatas)
            end
        end,
        Tooltip = 'Lucia (Pinata) Kit Module'
    })

    AutoDepositToggle = Lucia:CreateToggle({
        Name = 'Auto Deposit',
        Default = false,
        Function = function(callback)
            if RangeSlider and RangeSlider.Object then
                RangeSlider.Object.Visible = callback
            end
            if DelayToggle and DelayToggle.Object then
                DelayToggle.Object.Visible = callback
            end
            if DelaySlider and DelaySlider.Object then
                DelaySlider.Object.Visible = callback
            end
        end
    })

    RangeSlider = Lucia:CreateSlider({
        Name = 'Range',
        Min = 1,
        Max = 18,
        Default = 8,
        Suffix = ' studs',
        Visible = false
    })

    DelayToggle = Lucia:CreateToggle({
        Name = 'Delay',
        Default = false,
        Visible = false,
        Function = function(callback)
            if DelaySlider and DelaySlider.Object then
                DelaySlider.Object.Visible = callback
            end
        end
    })

    DelaySlider = Lucia:CreateSlider({
        Name = 'Delay Amount',
        Min = 0,
        Max = 2,
        Default = 0.5,
        Decimal = 10,
        Suffix = 's',
        Visible = false
    })

    LuciaESPToggle = Lucia:CreateToggle({
        Name = 'Pinata ESP',
        Default = false,
        Tooltip = 'Shows pinata locations',
        Function = function(callback)
            if CandyESPToggle and CandyESPToggle.Object then
                CandyESPToggle.Object.Visible = callback
            end
            if IgnoreTeammatesESP and IgnoreTeammatesESP.Object then
                IgnoreTeammatesESP.Object.Visible = callback
            end
            if ESPBackground and ESPBackground.Object then
                ESPBackground.Object.Visible = callback
            end
            if ESPColor and ESPColor.Object then
                ESPColor.Object.Visible = callback
            end
            
            if Lucia.Enabled then
                if callback then
                    findExistingPinatas()
                else
                    Folder:ClearAllChildren()
                    table.clear(Reference)
                end
            end
        end
    })

    CandyESPToggle = Lucia:CreateToggle({
        Name = 'Candy ESP',
        Default = false,
        Visible = false,
        Tooltip = 'Shows candy amount in pinatas',
        Function = function(callback)
            for pinataPart in pairs(Reference) do
                updateCandyDisplay(pinataPart)
            end
        end
    })

    IgnoreTeammatesESP = Lucia:CreateToggle({
        Name = 'Ignore Teammates',
        Default = true,
        Visible = false,
        Tooltip = 'Hide ESP for teammates',
        Function = function(callback)
            if Lucia.Enabled and LuciaESPToggle.Enabled then
                refreshESP()
            end
        end
    })

    ESPBackground = Lucia:CreateToggle({
        Name = 'Background',
        Default = true,
        Visible = false,
        Function = function(callback)
            if ESPColor and ESPColor.Object then
                ESPColor.Object.Visible = callback
            end
            for _, ref in pairs(Reference) do
                if ref.frame then
                    ref.frame.BackgroundTransparency = 1 - (callback and ESPColor.Opacity or 0)
                    if ref.billboard.Blur then
                        ref.billboard.Blur.Visible = callback
                    end
                end
            end
        end
    })

    ESPColor = Lucia:CreateColorSlider({
        Name = 'Background Color',
        DefaultValue = 0,
        DefaultOpacity = 0.5,
        Visible = false,
        Function = function(hue, sat, val, opacity)
            ESPColor.Hue = hue
            ESPColor.Sat = sat
            ESPColor.Value = val
            ESPColor.Opacity = opacity
            
            for _, ref in pairs(Reference) do
                if ref.frame then
                    ref.frame.BackgroundColor3 = Color3.fromHSV(hue, sat, val)
                    ref.frame.BackgroundTransparency = 1 - opacity
                end
            end
        end,
        Darker = true
    })

    LuciaSpyToggle = Lucia:CreateToggle({
        Name = 'Lucia Spy',
        Default = false,
        Tooltip = 'Notifies when players deposit, break, or open pinatas',
        Function = function(callback)
            if IgnoreTeammatesSpy and IgnoreTeammatesSpy.Object then
                IgnoreTeammatesSpy.Object.Visible = callback
            end
            if DisplayNameToggle and DisplayNameToggle.Object then
                DisplayNameToggle.Object.Visible = callback
            end
            
            if Lucia.Enabled and callback then
                setupLuciaSpy()
            else
                table.clear(trackedPinatas)
            end
        end
    })

    IgnoreTeammatesSpy = Lucia:CreateToggle({
        Name = 'Ignore Teammates',
        Default = true,
        Visible = false
    })

    DisplayNameToggle = Lucia:CreateToggle({
        Name = 'Display Name',
        Default = false,
        Visible = false,
        Tooltip = 'Show display names instead of usernames'
    })
end)

run(function()
    local AutoAdetunde
    local AdetundeRemote

    local ShieldTargetSlider
    local SpeedTargetSlider
    local StrengthTargetSlider
    local DelaySlider
    local CycleToggle
    local OrderDropdown
    local StatusLabel

    local currentThread = nil

    local function getRemote()
        if AdetundeRemote then return AdetundeRemote end
        local ok, result = pcall(function()
            return bedwars.Client:Get(remotes.UpgradeFrostyHammer).instance
        end)
        if ok and result then
            AdetundeRemote = result
            return AdetundeRemote
        end
        local ok2, result2 = pcall(function()
            return game:GetService("ReplicatedStorage")
                :WaitForChild("rbxts_include")
                :WaitForChild("node_modules")
                :WaitForChild("@rbxts")
                :WaitForChild("net")
                :WaitForChild("out")
                :WaitForChild("_NetManaged")
                :WaitForChild("UpgradeFrostyHammer")
        end)
        if ok2 and result2 then
            AdetundeRemote = result2
            return AdetundeRemote
        end
        return nil
    end

    local function hasFrostyHammer()
        if not store or not store.inventory then return false end
        local ok, inv = pcall(function()
            return store.inventory.inventory.items
        end)
        if not ok or not inv then return false end
        for _, item in pairs(inv) do
            if item and item.itemType == "frosty_hammer" then
                return true
            end
        end
        return false
    end

    local function doUpgrade(upgradeType)
        local remote = getRemote()
        if not remote then return nil end
        local ok, result = pcall(function()
            return remote:InvokeServer(upgradeType)
        end)
        if ok then return result end
        return nil
    end

    local function getCurrentLevels()
        local result = doUpgrade("shield")
        if type(result) == "table" then
            return {
                shield   = result.shield   or 0,
                speed    = result.speed    or 0,
                strength = result.strength or 0,
            }
        end
        return nil
    end

    local UPGRADE_MAP = {
        Shield   = "shield",
        Speed    = "speed",
        Strength = "strength",
    }

    local ORDER_SEQUENCES = {
        ["Shield  Speed  Strength"] = {"Shield", "Speed", "Strength"},
        ["Shield  Strength  Speed"] = {"Shield", "Strength", "Speed"},
        ["Speed  Shield  Strength"] = {"Speed", "Shield", "Strength"},
        ["Speed  Strength  Shield"] = {"Speed", "Strength", "Shield"},
        ["Strength  Shield  Speed"] = {"Strength", "Shield", "Speed"},
        ["Strength  Speed  Shield"] = {"Strength", "Speed", "Shield"},
        ["Round Robin"]               = {"Shield", "Speed", "Strength"},
    }

    local function getTargetForUpgrade(name)
        if name == "Shield"   then return ShieldTargetSlider   and ShieldTargetSlider.Value   or 3 end
        if name == "Speed"    then return SpeedTargetSlider     and SpeedTargetSlider.Value     or 3 end
        if name == "Strength" then return StrengthTargetSlider and StrengthTargetSlider.Value or 3 end
        return 3
    end

    local function runUpgradeLoop()
        if not hasFrostyHammer() then
            notif("AutoAdetunde", "No Frosty Hammer in inventory!", 3)
            if AutoAdetunde.Enabled then AutoAdetunde:Toggle() end
            return
        end

        local orderKey = OrderDropdown and OrderDropdown.Value or "Shield  Speed  Strength"
        local isRoundRobin = orderKey == "Round Robin"
        local sequence = ORDER_SEQUENCES[orderKey] or {"Shield", "Speed", "Strength"}

        local delay = DelaySlider and DelaySlider.Value or 0.15
        local shouldCycle = CycleToggle and CycleToggle.Enabled

        local levels = getCurrentLevels()
        if not levels then
            notif("AutoAdetunde", "Failed to read upgrade levels!", 3)
            if AutoAdetunde.Enabled then AutoAdetunde:Toggle() end
            return
        end

        repeat
            local didAnything = false

            if isRoundRobin then
                for _, upgradeName in ipairs(sequence) do
                    if not AutoAdetunde.Enabled then break end
                    local key = UPGRADE_MAP[upgradeName]
                    local target = getTargetForUpgrade(upgradeName)
                    local current = levels[key] or 0

                    if current < target and current < 3 then
                        local result = doUpgrade(key)
                        if type(result) == "table" then
                            levels.shield   = result.shield   or levels.shield
                            levels.speed    = result.speed    or levels.speed
                            levels.strength = result.strength or levels.strength
                            didAnything = true
                        end
                        task.wait(delay)
                    end
                end
            else
                for _, upgradeName in ipairs(sequence) do
                    if not AutoAdetunde.Enabled then break end
                    local key = UPGRADE_MAP[upgradeName]
                    local target = getTargetForUpgrade(upgradeName)
                    local current = levels[key] or 0

                    while AutoAdetunde.Enabled and current < target and current < 3 do
                        local result = doUpgrade(key)
                        if type(result) == "table" then
                            levels.shield   = result.shield   or levels.shield
                            levels.speed    = result.speed    or levels.speed
                            levels.strength = result.strength or levels.strength
                            current = levels[key] or current
                            didAnything = true
                        else
                            break
                        end
                        task.wait(delay)
                    end
                end
            end

            local allDone = true
            for _, upgradeName in ipairs(sequence) do
                local key = UPGRADE_MAP[upgradeName]
                local target = math.min(getTargetForUpgrade(upgradeName), 3)
                if (levels[key] or 0) < target then
                    allDone = false
                    break
                end
            end

            if allDone then
                local s = levels.shield or 0
                local sp = levels.speed or 0
                local st = levels.strength or 0
                notif("AutoAdetunde", ("Done! Shield %d/3 | Speed %d/3 | Strength %d/3"):format(s, sp, st), 6)
                if not shouldCycle then
                    if AutoAdetunde.Enabled then AutoAdetunde:Toggle() end
                    return
                end
                task.wait(1)
            elseif not didAnything then
                task.wait(0.5)
            end

        until not AutoAdetunde.Enabled
    end

    AutoAdetunde = vape.Categories.Kits:CreateModule({
        Name = 'AutoAdetunde',
        Function = function(callback)
            if callback then
                if currentThread then
                    task.cancel(currentThread)
                    currentThread = nil
                end
                currentThread = task.spawn(runUpgradeLoop)
            else
                if currentThread then
                    task.cancel(currentThread)
                    currentThread = nil
                end
            end
        end,
        Tooltip = 'Auto upgrades Frosty Hammer with full control'
    })

    OrderDropdown = AutoAdetunde:CreateDropdown({
        Name = 'Upgrade Order',
        List = {
            "Shield  Speed  Strength",
            "Shield  Strength  Speed",
            "Speed  Shield  Strength",
            "Speed  Strength  Shield",
            "Strength  Shield  Speed",
            "Strength  Speed  Shield",
            "Round Robin",
        },
        Default = "Shield  Speed  Strength",
        Tooltip = 'Order to upgrade in. Round Robin does 1 of each at a time.',
        Function = function() end
    })

    ShieldTargetSlider = AutoAdetunde:CreateSlider({
        Name = 'Shield Target',
        Min = 0,
        Max = 3,
        Default = 3,
        Suffix = '/3',
        Tooltip = '0 = skip Shield entirely, 1-3 = upgrade to that level'
    })

    SpeedTargetSlider = AutoAdetunde:CreateSlider({
        Name = 'Speed Target',
        Min = 0,
        Max = 3,
        Default = 3,
        Suffix = '/3',
        Tooltip = '0 = skip Speed entirely, 1-3 = upgrade to that level'
    })

    StrengthTargetSlider = AutoAdetunde:CreateSlider({
        Name = 'Strength Target',
        Min = 0,
        Max = 3,
        Default = 3,
        Suffix = '/3',
        Tooltip = '0 = skip Strength entirely, 1-3 = upgrade to that level'
    })

    DelaySlider = AutoAdetunde:CreateSlider({
        Name = 'Upgrade Delay',
        Min = 0.05,
        Max = 2,
        Default = 0.15,
        Decimal = 100,
        Suffix = 's',
        Tooltip = 'Delay between each upgrade call. Lower = faster but more suspicious'
    })

    CycleToggle = AutoAdetunde:CreateToggle({
        Name = 'Keep Cycling',
        Default = false,
        Tooltip = 'After hitting all targets, loop back and keep trying (useful mid-game when you get more diamonds)'
    })
end)

run(function()
	local CrocBlocks
	local connections = {}
	local originalData = {}
	local processedBlocks = {}
	local TEXTURE_ID = 'rbxassetid://125197310764304'

	local function isBlock(obj)
		if not obj:IsA('BasePart') then return false end
		return collectionService:HasTag(obj, 'block') or
			(bedwars.ItemMeta and bedwars.ItemMeta[obj.Name] and bedwars.ItemMeta[obj.Name].block ~= nil)
	end

	local function applyTexture(obj)
		if not obj or not obj.Parent or processedBlocks[obj] then return end
		if not isBlock(obj) then return end

		local saved = {
			Material = obj.Material,
			Color = obj.Color,
			TextureID = obj:IsA('MeshPart') and obj.TextureID or nil,
			clones = {}
		}

		for _, child in obj:GetChildren() do
			if child:IsA('Decal') or child:IsA('Texture') or child:IsA('SurfaceAppearance') or child:IsA('SpecialMesh') then
				local clone = child:Clone()
				clone.Parent = workspace.CurrentCamera
				table.insert(saved.clones, {clone = clone, class = child.ClassName})
				child:Destroy()
			end
		end

		originalData[obj] = saved

		if obj:IsA('MeshPart') then
			pcall(function() obj.TextureID = '' end)
		end
		pcall(function() obj.Material = Enum.Material.SmoothPlastic end)

		for _, face in Enum.NormalId:GetEnumItems() do
			local decal = Instance.new('Decal')
			decal.Name = 'CrocBlock'
			decal.Texture = TEXTURE_ID
			decal.Face = face
			decal.Parent = obj
		end

		processedBlocks[obj] = true
	end

	local function restoreTexture(obj)
		if not obj then return end

		if obj:IsA('BasePart') then
			for _, child in obj:GetChildren() do
				if child:IsA('Decal') and child.Name == 'CrocBlock' then
					child:Destroy()
				end
			end
		end

		local saved = originalData[obj]
		if saved and obj.Parent then
			pcall(function() obj.Material = saved.Material end)
			pcall(function() obj.Color = saved.Color end)
			if saved.TextureID and obj:IsA('MeshPart') then
				pcall(function() obj.TextureID = saved.TextureID end)
			end
			for _, entry in saved.clones do
				pcall(function()
					local restored = entry.clone:Clone()
					restored.Parent = obj
					entry.clone:Destroy()
				end)
			end
		end

		originalData[obj] = nil
		processedBlocks[obj] = nil
	end

	local function processAll(apply)
		task.spawn(function()
			local descendants = workspace:GetDescendants()
			for i, obj in descendants do
				if apply then
					applyTexture(obj)
				else
					restoreTexture(obj)
				end
				if i % 50 == 0 then task.wait() end
			end
		end)
	end

	CrocBlocks = vape.Categories.Blatant:CreateModule({
		Name = 'CrocBlocks',
		Function = function(callback)
			if callback then
				processAll(true)
				table.insert(connections, workspace.DescendantAdded:Connect(function(obj)
					if CrocBlocks.Enabled and isBlock(obj) then
						applyTexture(obj)
					end
				end))
			else
				for _, conn in connections do
					conn:Disconnect()
				end
				table.clear(connections)
				processAll(false)
				task.delay(2, function()
					for _, data in originalData do
						for _, entry in data.clones do
							pcall(function() entry.clone:Destroy() end)
						end
					end
					table.clear(originalData)
					table.clear(processedBlocks)
				end)
			end
		end,
		Tooltip = 'Replaces all block textures with the croc texture on all sides'
	})
end)

